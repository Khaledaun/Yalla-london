<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yalla London — Connection Validator</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 20px; }
  h1 { text-align: center; margin-bottom: 8px; font-size: 1.6rem; color: #fff; }
  .subtitle { text-align: center; color: #888; margin-bottom: 24px; font-size: 0.9rem; }
  .section { background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; }
  .section h2 { font-size: 1rem; color: #aaa; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
  .test-row { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #1a1a1a; }
  .test-row:last-child { border-bottom: none; }
  .test-name { flex: 1; font-size: 0.9rem; }
  .test-status { font-size: 0.85rem; font-weight: 600; min-width: 100px; text-align: right; }
  .pass { color: #4ade80; }
  .fail { color: #f87171; }
  .warn { color: #fbbf24; }
  .pending { color: #666; }
  .detail { color: #888; font-size: 0.8rem; margin-top: 2px; word-break: break-all; }
  .summary-bar { display: flex; gap: 24px; justify-content: center; padding: 16px; background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; margin-bottom: 16px; }
  .summary-item { text-align: center; }
  .summary-num { font-size: 2rem; font-weight: 700; }
  .summary-label { font-size: 0.75rem; color: #888; text-transform: uppercase; }
  .status-banner { text-align: center; padding: 16px; border-radius: 12px; font-size: 1.1rem; font-weight: 700; margin-top: 16px; }
  .status-ok { background: #052e16; border: 1px solid #166534; color: #4ade80; }
  .status-warn { background: #422006; border: 1px solid #92400e; color: #fbbf24; }
  .status-fail { background: #450a0a; border: 1px solid #991b1b; color: #f87171; }
  button { background: #2563eb; color: white; border: none; padding: 12px 32px; border-radius: 8px; font-size: 1rem; cursor: pointer; display: block; margin: 0 auto 20px; }
  button:hover { background: #1d4ed8; }
  button:disabled { background: #333; color: #666; cursor: not-allowed; }
  .cron-input { background: #1a1a1a; border: 1px solid #333; color: #e0e0e0; padding: 8px 12px; border-radius: 6px; width: 100%; margin-bottom: 12px; font-family: monospace; }
  .cron-input::placeholder { color: #555; }
  .log { background: #0a0a0a; border: 1px solid #222; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; max-height: 300px; overflow-y: auto; margin-top: 12px; white-space: pre-wrap; color: #888; }
  .json-block { background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 12px; font-family: monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; margin-top: 8px; white-space: pre-wrap; color: #7ee787; }
  .diag { background: #1a0000; border: 1px solid #4a1a1a; border-radius: 6px; padding: 8px 12px; margin-top: 6px; font-size: 0.78rem; color: #fca5a5; }
  .diag strong { color: #f87171; }
  .diag code { background: #2a1010; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.75rem; }
  .diag-warn { background: #1a1400; border-color: #4a3a1a; color: #fde68a; }
  .diag-warn strong { color: #fbbf24; }
  .diag-warn code { background: #2a2010; }
  .tab-bar { display: flex; gap: 8px; margin-bottom: 16px; justify-content: center; flex-wrap: wrap; }
  .tab-btn { background: #1a1a1a; border: 1px solid #333; color: #888; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
  .tab-btn.active { background: #2563eb; color: white; border-color: #2563eb; }
  .tab-btn.audit-tab.active { background: #d97706; border-color: #d97706; }
  .audit-panel { display: none; }
  .audit-panel.visible { display: block; }
  .gate-row { display: flex; align-items: center; padding: 10px 12px; border-bottom: 1px solid #1a1a1a; gap: 12px; }
  .gate-row:last-child { border-bottom: none; }
  .gate-icon { font-size: 1.1rem; width: 24px; text-align: center; }
  .gate-info { flex: 1; }
  .gate-name { font-size: 0.9rem; }
  .gate-detail { font-size: 0.75rem; color: #666; margin-top: 2px; }
  .gate-badge { font-size: 0.75rem; font-weight: 700; padding: 3px 10px; border-radius: 4px; }
  .gate-pass { background: #052e16; color: #4ade80; }
  .gate-fail { background: #450a0a; color: #f87171; }
  .severity-p0 { background: #450a0a; color: #f87171; }
  .severity-p1 { background: #422006; color: #fbbf24; }
  .severity-p2 { background: #0c1a3a; color: #60a5fa; }
  .severity-badge { font-size: 0.7rem; font-weight: 600; padding: 2px 6px; border-radius: 3px; font-family: monospace; }
  .page-row { padding: 8px 12px; border-bottom: 1px solid #1a1a1a; cursor: pointer; }
  .page-row:hover { background: #1a1a1a; }
  .page-header { display: flex; align-items: center; gap: 8px; }
  .page-detail { display: none; padding: 8px 0 4px 32px; }
  .page-detail.open { display: block; }
  .page-signals { display: flex; gap: 12px; flex-wrap: wrap; font-size: 0.75rem; color: #888; margin-top: 4px; }
  .signal-ok { color: #4ade80; }
  .signal-bad { color: #f87171; }
  .audit-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 16px; }
  .audit-card { border-radius: 8px; padding: 12px; border: 1px solid #2a2a2a; text-align: center; }
  .audit-card-val { font-size: 1.6rem; font-weight: 700; }
  .audit-card-label { font-size: 0.7rem; color: #888; text-transform: uppercase; margin-top: 2px; }
  .audit-card-blue { background: #0c1a3a; border-color: #1e3a5f; color: #60a5fa; }
  .audit-card-green { background: #052e16; border-color: #166534; color: #4ade80; }
  .audit-card-amber { background: #422006; border-color: #92400e; color: #fbbf24; }
  .audit-card-red { background: #450a0a; border-color: #991b1b; color: #f87171; }
  .audit-card-gray { background: #1a1a1a; border-color: #333; color: #aaa; }
  .audit-progress { height: 4px; background: #222; border-radius: 2px; overflow: hidden; margin: 12px 0; }
  .audit-progress-bar { height: 100%; border-radius: 2px; transition: width 0.3s; }
  .audit-history-row { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #1a1a1a; gap: 10px; font-size: 0.85rem; }
  .audit-history-row:last-child { border-bottom: none; }
</style>
</head>
<body>

<h1>Yalla London — System Validator</h1>
<p class="subtitle">Full pipeline test: GA4, Assets, Pages, SEO, Crons, Database, AI, Yacht Platform, Content, Orchestrator, Indexing, X/Twitter API, Site Health, Schema Audit (24 sections) + One-Click DB Migration + Comprehensive JSON Export</p>

<div class="tab-bar">
  <button class="tab-btn active" onclick="switchMode('quick')">Quick Test</button>
  <button class="tab-btn" onclick="switchMode('full')">Full Pipeline Test (needs CRON_SECRET)</button>
  <button class="tab-btn audit-tab" onclick="switchMode('audit')">Master SEO Audit</button>
</div>

<div class="section" id="cronSection" style="display:none">
  <h2>Authentication</h2>
  <input type="password" id="cronSecret" class="cron-input" placeholder="Enter your CRON_SECRET to test cron endpoints and content pipeline...">
</div>

<!-- Standard test buttons (hidden in audit mode) -->
<div id="testButtons" style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-bottom:20px;">
  <button id="runBtn" onclick="runAllTests()">Run All Tests</button>
  <button id="scanBtn" onclick="scanDatabase()" style="background:#7c3aed;">Scan Missing Tables/Columns</button>
  <button id="migrateBtn" onclick="migrateDatabase()" style="background:#dc2626;">Fix Missing Tables &amp; Columns</button>
  <button id="seedBtn" onclick="seedStaticContent()" style="background:#059669;">Seed Static Articles → DB</button>
  <button id="jobsBtn" onclick="runAllJobs()" style="background:#d97706;">Run All Cron Jobs</button>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════ -->
<!-- MASTER AUDIT PANEL                                                      -->
<!-- ═══════════════════════════════════════════════════════════════════════ -->
<div class="audit-panel" id="auditPanel">
  <div class="section">
    <h2>Master SEO Audit</h2>
    <p style="color:#888;font-size:0.82rem;margin-bottom:12px;">
      Full-site crawl with 8 validators (HTTP, canonical, hreflang, JSON-LD schema, internal links, metadata, robots, sitemap) and 6 hard gates.
      Quick mode scans static routes (~20s). Full mode includes all blog posts from sitemap (~40-50s).
    </p>
    <div style="margin-bottom:12px;">
      <input type="password" id="auditSecret" class="cron-input" placeholder="Enter your CRON_SECRET to authenticate..." oninput="syncSecrets(this.value)">
    </div>
    <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-bottom:12px;">
      <button id="auditQuickBtn" onclick="runMasterAudit('quick')" style="background:#d97706;">Run Quick Audit (static pages)</button>
      <button id="auditFullBtn" onclick="runMasterAudit('full')" style="background:#2563eb;">Run Full Audit (all pages)</button>
      <button id="auditHistoryBtn" onclick="loadAuditHistory()" style="background:#333;color:#aaa;">Load History</button>
    </div>
    <div class="audit-progress" id="auditProgress" style="display:none;">
      <div class="audit-progress-bar" id="auditProgressBar" style="width:0%;background:#d97706;"></div>
    </div>
    <div id="auditStatus" style="text-align:center;color:#888;font-size:0.85rem;margin-bottom:8px;"></div>
  </div>
  <div id="auditResults"></div>
  <div id="auditHistory"></div>
</div>

<div class="summary-bar">
  <div class="summary-item"><div class="summary-num pass" id="passCount">-</div><div class="summary-label">Passed</div></div>
  <div class="summary-item"><div class="summary-num warn" id="warnCount">-</div><div class="summary-label">Warnings</div></div>
  <div class="summary-item"><div class="summary-num fail" id="failCount">-</div><div class="summary-label">Failed</div></div>
</div>

<div id="results"></div>
<div id="statusBanner"></div>

<div class="section" style="margin-top:16px">
  <h2>Live Log</h2>
  <div class="log" id="log"></div>
</div>

<script>
let pass = 0, fail = 0, warn = 0;
let testMode = 'quick';
let allResults = []; // Collect all results for JSON export

function switchMode(mode) {
  testMode = mode;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  const tabIdx = mode === 'quick' ? 0 : mode === 'full' ? 1 : 2;
  document.querySelectorAll('.tab-btn')[tabIdx].classList.add('active');
  document.getElementById('cronSection').style.display = mode === 'full' ? 'block' : 'none';

  // Toggle between test view and audit view
  const isAudit = mode === 'audit';
  document.getElementById('testButtons').style.display = isAudit ? 'none' : 'flex';
  document.getElementById('auditPanel').classList.toggle('visible', isAudit);
  // Hide standard results/summary/log when in audit mode
  document.querySelector('.summary-bar').style.display = isAudit ? 'none' : 'flex';
  document.getElementById('results').style.display = isAudit ? 'none' : 'block';
  document.getElementById('statusBanner').style.display = isAudit ? 'none' : 'block';
  document.querySelector('.section:has(#log)').style.display = isAudit ? 'none' : 'block';
}

function log(msg) {
  const el = document.getElementById('log');
  el.textContent += new Date().toISOString().substring(11,19) + ' ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}

function addSection(id, title) {
  const html = `<div class="section" id="section-${id}"><h2>${title}</h2><div id="tests-${id}"></div></div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function addResult(sectionId, name, status, detail, diagnostic) {
  if (status === 'pass') pass++;
  else if (status === 'fail') fail++;
  else warn++;

  // Track for JSON export
  allResults.push({ section: sectionId, name, status, detail: detail || null });

  const cls = status === 'pass' ? 'pass' : status === 'fail' ? 'fail' : 'warn';
  const icon = status === 'pass' ? '\u2713' : status === 'fail' ? '\u2717' : '\u26A0';
  const safeDetail = detail ? escapeHtml(String(detail)) : '';

  // Auto-diagnose common error patterns if no diagnostic provided
  let autoDiag = diagnostic || '';
  if (!diagnostic && status !== 'pass' && safeDetail) {
    const d = safeDetail.toLowerCase();
    if (d.includes('p2022') || d.includes('column') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2022:</strong> A column referenced in the query does not exist in the database. The Prisma schema defines it but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page, or run <code>npx prisma db push</code>.';
    } else if (d.includes('p2021') || d.includes('table') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2021:</strong> The table does not exist in the database. The model is defined in <code>prisma/schema.prisma</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page.';
    } else if (d.includes('p2002') || d.includes('unique constraint')) {
      autoDiag = '<strong>Prisma P2002:</strong> Unique constraint violation — a record with this value already exists. This usually means duplicate data or a re-run of a cron that already created this record.';
    } else if (d.includes('p1001') || d.includes('can\'t reach database') || d.includes('connection refused')) {
      autoDiag = '<strong>Database unreachable:</strong> The database server is not responding. Check that <code>DATABASE_URL</code> in Vercel env vars points to a running Supabase/PostgreSQL instance. If using Supabase, check that the project is not paused (free tier pauses after 7 days of inactivity).';
    } else if (d.includes('p1008') || d.includes('timed out')) {
      autoDiag = '<strong>Database timeout:</strong> The query took too long. This may be a cold start issue, a slow query, or the connection pool is exhausted. Check Supabase dashboard for connection count.';
    } else if (d.includes('type error') || d.includes('typeerror')) {
      autoDiag = '<strong>JavaScript TypeError:</strong> A code error is preventing this route from executing. Common causes: (1) A missing or misnamed import, (2) A function being called on <code>undefined</code>, (3) A build-time error that broke the serverless function chunk. Check Vercel Function Logs for the full stack trace.';
    } else if (d.includes('maxclientsinsessionmode') || d.includes('max clients reached') || d.includes('pool_size')) {
      autoDiag = '<strong>Connection Pool Exhausted:</strong> Supabase reached its connection limit. This happens when many API calls run in quick succession. Wait 30 seconds and retry, or increase the pool size in Supabase Dashboard → Settings → Database → Connection Pooling.';
    } else if (d.includes('http 0') || d.includes('failed to fetch') || d.includes('networkerror')) {
      autoDiag = '<strong>Network Error (HTTP 0):</strong> The request never reached the server. Causes: (1) The serverless function failed to load (build error), (2) Vercel is redeploying, (3) CORS or firewall blocking. Check Vercel deployment status and Function Logs.';
    } else if (d.includes('500')) {
      autoDiag = '<strong>HTTP 500 — Server Error:</strong> The route handler crashed. Check Vercel Function Logs for this specific path to see the full error and stack trace.';
    }
  }

  let diagHtml = '';
  if (autoDiag && status !== 'pass') {
    const diagCls = status === 'fail' ? 'diag' : 'diag diag-warn';
    diagHtml = `<div class="${diagCls}"><strong>Diagnosis:</strong> ${autoDiag}</div>`;
  }
  const html = `<div class="test-row">
    <div><div class="test-name">${escapeHtml(name)}</div>${safeDetail ? `<div class="detail">${safeDetail}</div>` : ''}${diagHtml}</div>
    <div class="test-status ${cls}">${icon} ${status.toUpperCase()}</div>
  </div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
  updateSummary();
}

function escapeHtml(str) {
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function addJsonBlock(sectionId, data) {
  const escaped = escapeHtml(JSON.stringify(data, null, 2));
  const html = `<div class="json-block">${escaped}</div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
}

function updateSummary() {
  document.getElementById('passCount').textContent = pass;
  document.getElementById('warnCount').textContent = warn;
  document.getElementById('failCount').textContent = fail;
}

async function testFetch(url, options = {}) {
  try {
    const resp = await fetch(url, { ...options, signal: AbortSignal.timeout(30000) });
    const text = await resp.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}
    // For non-OK responses, extract the most useful error detail
    let errorDetail = '';
    if (!resp.ok) {
      if (json?.error) errorDetail = json.error;
      else if (json?.message) errorDetail = json.message;
      else if (text.length < 500) errorDetail = text;
      else errorDetail = text.substring(0, 500);
    }
    return { ok: resp.ok, status: resp.status, text, json, headers: resp.headers, errorDetail };
  } catch (e) {
    return { ok: false, status: 0, text: e.message, json: null, error: e, errorDetail: e.message };
  }
}

// ─── Database Scan / Migrate ──────────────────────────────────────────
function getCronSecret() {
  return document.getElementById('cronSecret')?.value || '';
}

async function scanDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  document.getElementById('scanBtn').disabled = true;
  document.getElementById('scanBtn').textContent = 'Scanning...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbscan', 'Database Schema Scan — Missing Tables & Columns');
  log('Scanning database for missing tables and columns...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const s = j.summary || {};

      // Overall status
      if (s.needsMigration) {
        addResult('dbscan', 'Schema Status', 'fail',
          s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
          'Your database is out of sync with the Prisma schema. Click <strong>"Fix Missing Tables & Columns"</strong> to create the missing items automatically. This is safe — it only adds new tables/columns and never deletes existing data.');
      } else {
        addResult('dbscan', 'Schema Status', 'pass', 'All expected tables and columns exist');
      }

      // Missing tables
      if (j.missingTables && j.missingTables.length > 0) {
        for (const t of j.missingTables) {
          addResult('dbscan', 'Missing Table: ' + t.table, 'fail',
            'Prisma model ' + t.model + ' has no corresponding table in the database',
            'The <code>' + escapeHtml(t.table) + '</code> table needs to be created. This table is defined in <code>prisma/schema.prisma</code> as model <code>' + escapeHtml(t.model) + '</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> to create it.');
        }
      }

      // Missing columns
      if (j.missingColumns && j.missingColumns.length > 0) {
        for (const c of j.missingColumns) {
          addResult('dbscan', 'Missing Column: ' + c.table + '.' + c.column, 'fail',
            'Type: ' + c.type + ' — model ' + c.model,
            'Column <code>' + escapeHtml(c.column) + '</code> (' + escapeHtml(c.type) + ') is defined in the Prisma schema for model <code>' + escapeHtml(c.model) + '</code> but doesn\'t exist in the actual database table <code>' + escapeHtml(c.table) + '</code>. This will cause runtime errors (Prisma error P2022) when any API route tries to read or write this column. Click <strong>"Fix Missing Tables & Columns"</strong> to add it.');
        }
      }

      // Existing tables (info)
      if (j.existingTables) {
        addResult('dbscan', 'Existing Tables', 'pass',
          j.existingTables.length + ' tables found: ' + j.existingTables.slice(0, 15).join(', ') + (j.existingTables.length > 15 ? '...' : ''));
      }

      addJsonBlock('dbscan', j);
    } else if (resp.status === 401) {
      addResult('dbscan', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match. Go to Vercel → Settings → Environment Variables and copy the exact value.');
    } else {
      addResult('dbscan', 'Scan', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        resp.json?.hint || 'Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbscan', resp.json);
    }
  } catch (e) {
    addResult('dbscan', 'Scan', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">DATABASE SCHEMA IS IN SYNC</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SCHEMA ISSUE(S) — Click "Fix Missing Tables & Columns" to resolve</div>';
  }

  document.getElementById('scanBtn').disabled = false;
  document.getElementById('scanBtn').textContent = 'Scan Missing Tables/Columns';
}

async function migrateDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  if (!confirm('This will CREATE missing tables and ADD missing columns to your production database.\n\nIt will NOT delete any existing data.\n\nProceed?')) {
    return;
  }

  document.getElementById('migrateBtn').disabled = true;
  document.getElementById('migrateBtn').textContent = 'Migrating...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbmigrate', 'Database Migration — Creating Missing Tables & Columns');
  log('Running database migration...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const r = j.result || {};

      // Before/After summary
      addResult('dbmigrate', 'Before Migration',
        j.before.missingTables > 0 || j.before.missingColumns > 0 ? 'warn' : 'pass',
        j.before.missingTables + ' missing tables, ' + j.before.missingColumns + ' missing columns');

      addResult('dbmigrate', 'After Migration',
        j.after.missingTables === 0 && j.after.missingColumns === 0 ? 'pass' : 'warn',
        j.after.missingTables + ' missing tables, ' + j.after.missingColumns + ' missing columns',
        j.after.missingTables > 0 || j.after.missingColumns > 0 ? 'Some items could not be created. Check the errors below for details.' : undefined);

      // Tables created
      if (r.tablesCreated && r.tablesCreated.length > 0) {
        for (const t of r.tablesCreated) {
          addResult('dbmigrate', 'Created Table: ' + t, 'pass', 'Table created successfully');
        }
      }

      // Columns added
      if (r.columnsAdded && r.columnsAdded.length > 0) {
        for (const c of r.columnsAdded) {
          addResult('dbmigrate', 'Added Column: ' + c, 'pass', 'Column added successfully');
        }
      }

      // Indexes created
      if (r.indexesCreated && r.indexesCreated.length > 0) {
        addResult('dbmigrate', 'Indexes Created', 'pass', r.indexesCreated.length + ' indexes: ' + r.indexesCreated.slice(0, 8).join(', ') + (r.indexesCreated.length > 8 ? '...' : ''));
      }

      // Nothing to do
      if ((!r.tablesCreated || r.tablesCreated.length === 0) &&
          (!r.columnsAdded || r.columnsAdded.length === 0)) {
        addResult('dbmigrate', 'Result', 'pass', 'Nothing to migrate — database is already in sync');
      }

      // Errors
      if (r.errors && r.errors.length > 0) {
        for (const err of r.errors) {
          addResult('dbmigrate', 'Migration Error', 'fail', err,
            'This operation failed. It may require manual intervention or higher database permissions. Check that your database user has <code>CREATE TABLE</code> and <code>ALTER TABLE</code> privileges.');
        }
      }

      addJsonBlock('dbmigrate', j);
    } else if (resp.status === 401) {
      addResult('dbmigrate', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match.');
    } else {
      addResult('dbmigrate', 'Migration', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        (resp.json?.hint || '') + ' Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbmigrate', resp.json);
    }
  } catch (e) {
    addResult('dbmigrate', 'Migration', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">MIGRATION COMPLETE — All tables and columns synced</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' MIGRATION ERROR(S) — See details above</div>';
  }

  document.getElementById('migrateBtn').disabled = false;
  document.getElementById('migrateBtn').textContent = 'Fix Missing Tables & Columns';
}

// ─── Seed Static Content ──────────────────────────────────────────────────
async function seedStaticContent() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('seedBtn').disabled = true;
  document.getElementById('seedBtn').textContent = 'Seeding...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('seed', 'Seed Static Articles into Database');

  // First do a dry run
  log('Running dry-run scan of static content...');
  try {
    const dryResp = await testFetch('/api/admin/seed-content', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (dryResp.ok && dryResp.json) {
      const j = dryResp.json;
      addResult('seed', 'Static Articles Found', 'pass', j.totalStatic + ' published articles in data files');
      addResult('seed', 'Categories', 'pass', j.categories + ' categories');
      addResult('seed', 'Already in DB', j.alreadyInDb > 0 ? 'pass' : 'warn', j.alreadyInDb + ' articles already exist');
      addResult('seed', 'To Create', j.toCreate > 0 ? 'warn' : 'pass', j.toCreate + ' new articles to insert');
      addResult('seed', 'To Update', 'pass', j.toUpdate + ' existing articles to refresh');
      addJsonBlock('seed', j);
    } else if (dryResp.status === 401) {
      addResult('seed', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch');
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    } else {
      addResult('seed', 'Dry Run', 'fail', 'HTTP ' + dryResp.status + ' — ' + (dryResp.json?.error || ''));
      if (dryResp.json) addJsonBlock('seed', dryResp.json);
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    }
  } catch (e) {
    addResult('seed', 'Dry Run', 'fail', 'JS Error: ' + e.message);
    updateSummary();
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  if (!confirm('This will INSERT/UPDATE static articles into the BlogPost database table.\n\nArticles will be:\n• Published immediately\n• Assigned to site: yalla-london\n• Tagged with "imported-static"\n• Available to SEO agent, indexing, and CMS\n\nProceed?')) {
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  // Execute the seed in batches of 8 to avoid timeout
  const BATCH_SIZE = 8;
  let currentOffset = 0;
  let batchNum = 0;
  let totalCreated = 0, totalUpdated = 0, totalErrors = 0, totalSeoMeta = 0, totalUrlIdx = 0;
  let allCreatedSlugs = [], allUpdatedSlugs = [], allSkipped = [], allErrors = [];
  let lastAuthor = null, lastCategories = 0;
  let totalDurationMs = 0;

  log('Seeding static articles into database (batches of ' + BATCH_SIZE + ')...');

  while (true) {
    batchNum++;
    log('  Batch ' + batchNum + ': offset=' + currentOffset + ' limit=' + BATCH_SIZE);

    let seedResp;
    try {
      // Use 55s timeout for each batch (server has 50s budget)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 55000);
      const resp = await fetch('/api/admin/seed-content?offset=' + currentOffset + '&limit=' + BATCH_SIZE, {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}
      seedResp = { ok: resp.ok, status: resp.status, json, text };
    } catch (e) {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'Network error: ' + e.message + '. Try clicking Seed again — it will resume from where it stopped.');
      break;
    }

    if (seedResp.ok && seedResp.json) {
      const j = seedResp.json;
      const r = j.results || {};
      const b = j.batch || {};

      totalCreated += (r.created || []).length;
      totalUpdated += (r.updated || []).length;
      totalErrors += (r.errors || []).length;
      totalSeoMeta += r.seoMetaCreated || 0;
      totalUrlIdx += r.urlIndexingCreated || 0;
      totalDurationMs += j.durationMs || 0;
      allCreatedSlugs = allCreatedSlugs.concat(r.created || []);
      allUpdatedSlugs = allUpdatedSlugs.concat(r.updated || []);
      allSkipped = allSkipped.concat(r.skipped || []);
      allErrors = allErrors.concat(r.errors || []);
      if (j.author) lastAuthor = j.author;
      if (j.categories) lastCategories = j.categories;

      addResult('seed', 'Batch ' + batchNum, 'pass',
        (r.created||[]).length + ' created, ' + (r.updated||[]).length + ' updated' +
        (b.stoppedEarly ? ' (time-limited)' : '') + ' (' + j.durationMs + 'ms)');

      // Check if there are more articles to process
      if (!b.hasMore) {
        log('  All articles processed.');
        break;
      }
      currentOffset = b.nextOffset;
    } else {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'HTTP ' + seedResp.status + ' — ' + (seedResp.json?.error || seedResp.text?.substring(0, 200) || ''));
      if (seedResp.json) addJsonBlock('seed', seedResp.json);
      break;
    }
  }

  // Show combined results
  if (totalCreated + totalUpdated > 0) {
    addResult('seed', 'Seed Complete', 'pass',
      totalCreated + ' created, ' + totalUpdated + ' updated, ' + totalSeoMeta + ' SeoMeta, ' +
      totalUrlIdx + ' URLIndexing, ' + totalErrors + ' errors (' + totalDurationMs + 'ms total)');
    if (lastAuthor) addResult('seed', 'System Author', 'pass', lastAuthor.email + ' (ID: ' + lastAuthor.id + ')');
    addResult('seed', 'Categories', 'pass', lastCategories + ' categories in database');

    if (allCreatedSlugs.length > 0) {
      addResult('seed', 'New Articles', 'pass', allCreatedSlugs.length + ': ' + allCreatedSlugs.slice(0, 5).join(', ') + (allCreatedSlugs.length > 5 ? ' +' + (allCreatedSlugs.length-5) + ' more' : ''));
    }
    if (allUpdatedSlugs.length > 0) {
      addResult('seed', 'Updated Articles', 'pass', allUpdatedSlugs.length + ': ' + allUpdatedSlugs.slice(0, 5).join(', ') + (allUpdatedSlugs.length > 5 ? ' +' + (allUpdatedSlugs.length-5) + ' more' : ''));
    }
    if (allSkipped.length > 0) {
      addResult('seed', 'Skipped', 'warn', allSkipped.join(', '));
    }
    if (allErrors.length > 0) {
      for (const err of allErrors) {
        addResult('seed', 'Error: ' + err.slug, 'fail', err.error);
      }
    }
    addResult('seed', 'SEO Records', 'pass', totalSeoMeta + ' SeoMeta + ' + totalUrlIdx + ' URLIndexingStatus records created');

    addJsonBlock('seed', {
      action: 'seed-complete',
      batches: batchNum,
      totalDurationMs,
      created: allCreatedSlugs,
      updated: allUpdatedSlugs,
      skipped: allSkipped,
      errors: allErrors,
      seoMetaRecords: totalSeoMeta,
      urlIndexingRecords: totalUrlIdx,
    });
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">SEED COMPLETE — Static articles are now in the database</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SEED ERROR(S) — See details above</div>';
  }

  document.getElementById('seedBtn').disabled = false;
  document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
}

// ─── Run All Cron Jobs ────────────────────────────────────────────────────
// ── Smart Response Body Analyzer ──────────────────────────────────────────
// Detects hidden failures inside HTTP 200 responses from cron jobs.
// Returns null if the response looks genuinely healthy.
function analyzeJobResponse(jobName, json) {
  const issues = [];

  // 1. Explicit error fields buried in the response
  if (json.errors && typeof json.errors === 'object' && !Array.isArray(json.errors)) {
    const errorKeys = Object.keys(json.errors);
    if (errorKeys.length > 0) {
      const allErrored = errorKeys.every(k => json.errors[k] && String(json.errors[k]).length > 10);
      if (allErrored) {
        issues.push({
          severity: 'fail',
          msg: errorKeys.length + '/' + errorKeys.length + ' sites have errors',
          diag: 'All sites returned errors in the response body. First error: <code>' +
            escapeHtml(String(json.errors[errorKeys[0]]).substring(0, 200)) + '</code>'
        });
      } else if (errorKeys.some(k => json.errors[k] && String(json.errors[k]).length > 10)) {
        const failedSites = errorKeys.filter(k => json.errors[k] && String(json.errors[k]).length > 10);
        issues.push({
          severity: 'warn',
          msg: failedSites.length + '/' + errorKeys.length + ' sites have errors',
          diag: 'Some sites have errors: ' + failedSites.join(', ') + '. Check the JSON output for details.'
        });
      }
    }
  }

  // 2. Last run was timed_out (healthcheck endpoints report previous run status)
  if (json.lastRun?.status === 'timed_out' || json.lastRun?.duration_ms > 60000) {
    issues.push({
      severity: 'warn',
      msg: 'Last actual run timed out (' + (json.lastRun?.duration_ms || '?') + 'ms)',
      diag: 'The healthcheck passed but the last real execution timed out. The job likely needs optimization or a higher <code>maxDuration</code>.'
    });
  }

  // 3. All items failed (completed: 0, failed: N where N > 0)
  if (typeof json.completed === 'number' && typeof json.failed === 'number' &&
      json.failed > 0 && json.completed === 0) {
    issues.push({
      severity: 'fail',
      msg: 'All ' + json.failed + ' items failed, 0 completed',
      diag: 'Every item the job processed ended in failure. Check the error details in the JSON response.'
    });
  }

  // 4. items.failed > 0 or items_failed > 0 (withCronLog format)
  const itemsFailed = json.items?.failed ?? json.items_failed ?? json.metrics?.errors ?? 0;
  const itemsProcessed = json.items?.processed ?? json.items_processed ?? 0;
  if (itemsFailed > 0 && itemsProcessed > 0 && itemsFailed === itemsProcessed) {
    issues.push({
      severity: 'fail',
      msg: 'All ' + itemsFailed + ' processed items failed',
      diag: 'Every item the job attempted to process failed. None succeeded.'
    });
  } else if (itemsFailed > 0 && itemsFailed > itemsProcessed * 0.5) {
    issues.push({
      severity: 'warn',
      msg: itemsFailed + '/' + itemsProcessed + ' items failed (>' + Math.round(itemsFailed / itemsProcessed * 100) + '%)',
      diag: 'More than half of processed items failed. The job is degraded.'
    });
  }

  // 5. Absurd numeric values (e.g. interest scores in the trillions)
  if (json.keywordTrends && Array.isArray(json.keywordTrends)) {
    const absurdScores = json.keywordTrends.filter(t => t.interestScore > 1e9);
    if (absurdScores.length > 0) {
      issues.push({
        severity: 'warn',
        msg: absurdScores.length + ' keywords have nonsensical interest scores (>' + absurdScores[0].interestScore.toExponential(1) + ')',
        diag: 'Interest scores should typically range 0-100. Values in the billions/trillions indicate the trends data source is returning corrupt or unscaled data. The SERP API response may have changed format.'
      });
    }
  }
  if (json.contentOpportunities && Array.isArray(json.contentOpportunities)) {
    const absurdTraffic = json.contentOpportunities.filter(o => o.estimatedTraffic > 1e9);
    if (absurdTraffic.length > 0) {
      issues.push({
        severity: 'warn',
        msg: 'Estimated traffic values are nonsensical (' + absurdTraffic[0].estimatedTraffic.toExponential(1) + ')',
        diag: 'Traffic estimates are in the billions+. These numbers are not usable for content prioritization.'
      });
    }
  }

  // 6. Prisma/DB errors nested inside response objects
  const jsonStr = JSON.stringify(json);
  if (jsonStr.includes('Unknown argument') || jsonStr.includes('P2022') || jsonStr.includes('P2021') ||
      jsonStr.includes('does not exist') || jsonStr.includes('Invalid `prisma')) {
    issues.push({
      severity: 'fail',
      msg: 'Prisma/database schema errors in response',
      diag: 'The response contains Prisma errors indicating schema mismatches. The database may be missing columns or tables referenced by the code. Run <strong>"Fix Missing Tables & Columns"</strong> or <code>npx prisma db push</code>.'
    });
  }

  // 7. Permission errors (403) inside nested results
  if (jsonStr.includes('Insufficient Permission') || jsonStr.includes('insufficient authentication scopes') ||
      jsonStr.includes('"code": 403') || jsonStr.includes('"code":403')) {
    issues.push({
      severity: 'warn',
      msg: 'Permission errors (403) in sub-requests',
      diag: 'Some external API calls within the job returned 403 Forbidden. Check API credentials and OAuth scopes (e.g. Google Search Console service account permissions).'
    });
  }

  // 8. Zero work done when work was expected (not healthcheck responses)
  const isHealthcheck = json.status === 'healthy' || json.endpoint;
  if (!isHealthcheck) {
    const ran = json.ran ?? json.postsProcessed ?? null;
    const published = json.published ?? json.succeeded ?? null;
    if (typeof ran === 'number' && ran === 0 && typeof published === 'number' && published === 0) {
      // Only warn if this isn't a "nothing to do" situation
      const hasNothingToDo = json.message?.includes('No ') || json.availableTopics === 0;
      if (!hasNothingToDo) {
        issues.push({
          severity: 'warn',
          msg: 'Job ran 0 tasks, published 0 items',
          diag: 'The job completed but did nothing. This may indicate missing configuration, empty queues, or a silent failure mode.'
        });
      }
    }
  }

  // 9. totalErrors > 0 in response
  if (typeof json.totalErrors === 'number' && json.totalErrors > 0) {
    issues.push({
      severity: 'warn',
      msg: json.totalErrors + ' error(s) reported in response',
      diag: 'The job reported errors in its response. Check the detailed JSON output for specifics.'
    });
  }

  // 10. Most sites have zero URLs (indexing)
  if (json.results && Array.isArray(json.results)) {
    const siteResults = json.results.filter(r => r.siteId);
    const zeroUrlSites = siteResults.filter(r => r.urlsFound === 0);
    if (siteResults.length > 2 && zeroUrlSites.length >= siteResults.length - 1) {
      issues.push({
        severity: 'warn',
        msg: zeroUrlSites.length + '/' + siteResults.length + ' sites have 0 URLs to index',
        diag: 'Most sites have no URLs for indexing. This usually means no content has been published for those sites yet, or the URL discovery query is too restrictive.'
      });
    }
  }

  if (issues.length === 0) return null;

  // Pick the worst severity
  const hasFail = issues.some(i => i.severity === 'fail');
  const summary = issues.map(i => i.msg).join('; ');
  const diagnosis = issues.map(i => i.diag).join('<br><br>');

  return {
    severity: hasFail ? 'fail' : 'warn',
    summary: summary.substring(0, 250),
    diagnosis: diagnosis,
  };
}

// ── Expanded Job Detail Extractors ──────────────────────────────────────
// Each function extracts rich details from a specific cron job response
// to display exactly what was generated, where it was saved, and why things failed.

function extractJobDetails(jobName, json) {
  if (!json) return [];
  const details = [];
  const d = (label, value, cls) => details.push({ label, value: String(value).substring(0, 300), cls: cls || 'pass' });
  const w = (label, value) => d(label, value, 'warn');
  const f = (label, value) => d(label, value, 'fail');

  switch (jobName) {
    case 'Analytics Sync': {
      const ga = json.results?.ga4 || {};
      const gsc = json.results?.gsc || {};
      if (ga.status === 'not_configured') {
        w('GA4 Status', 'NOT CONFIGURED — Missing: ' + (ga.missing || ['GA4_PROPERTY_ID', 'GOOGLE_ANALYTICS_CLIENT_EMAIL', 'GOOGLE_ANALYTICS_PRIVATE_KEY']).join(', '));
        w('Action Required', 'Set these env vars in Vercel → Settings → Environment Variables. GA4 is needed for traffic analytics.');
      } else if (ga.status === 'success') {
        d('GA4 Sessions (30d)', (ga.sessions || 0).toLocaleString());
        d('GA4 Users (30d)', (ga.users || 0).toLocaleString());
        d('GA4 Page Views (30d)', (ga.pageViews || 0).toLocaleString());
        d('GA4 Bounce Rate', (ga.bounceRate || 0).toFixed(1) + '%');
        d('GA4 Top Pages Collected', (ga.topPagesCount || 0) + ' pages');
      } else if (ga.status === 'error') {
        f('GA4 Error', ga.error || 'Unknown GA4 error');
      }
      if (gsc.status === 'success') {
        d('GSC Queries (30d)', (gsc.queriesCount || 0) + ' search queries');
        if (gsc.topQueries?.length) d('Top GSC Query', gsc.topQueries[0].query + ' (' + gsc.topQueries[0].clicks + ' clicks, CTR ' + (gsc.topQueries[0].ctr || 0).toFixed(1) + '%, pos ' + (gsc.topQueries[0].position || 0).toFixed(1) + ')');
      } else if (gsc.status === 'error') {
        w('GSC Error', gsc.error || 'Unknown GSC error');
      } else {
        w('GSC Status', 'Not configured — need GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL + PRIVATE_KEY');
      }
      if (json.results?.snapshot?.status === 'created') d('Snapshot Saved', 'AnalyticsSnapshot record created in DB');
      break;
    }
    case 'Site Health Check': {
      if (json.results && Array.isArray(json.results)) {
        for (const s of json.results) {
          const score = s.health_score !== undefined ? ' (score: ' + s.health_score + '/100)' : '';
          d('Site: ' + s.site_id, s.status + score);
        }
      } else if (json.message) d('Status', json.message);
      break;
    }
    case 'Trends Monitor': {
      if (json.summary) {
        d('Relevant Trending Topics', json.summary.relevantTrendingTopics || 0);
        if (json.summary.risingKeywords?.length) d('Rising Keywords', json.summary.risingKeywords.join(', '));
        d('Content Opportunities', json.summary.contentOpportunities || 0);
      }
      if (json.trendingTopics?.length) d('Top Trend', json.trendingTopics[0].title + ' (traffic: ' + json.trendingTopics[0].traffic + ')');
      if (json.keywordTrends?.length) d('Keywords Tracked', json.keywordTrends.length + ' keywords');
      if (json.grokSocialTrends?.length) d('X/Twitter Trends (via Grok)', json.grokSocialTrends.length + ' social trends captured');
      else w('X/Twitter Trends', 'Not available — XAI_API_KEY needed for Grok live X search');
      d('Data Saved', 'SeoReport table (type: trends-monitor)');
      break;
    }
    case 'Weekly Topics': {
      const gen = json.generated;
      if (gen && typeof gen === 'object') {
        d('Topics Generated', (gen.total || 0) + ' total (' + (gen.english || 0) + ' EN + ' + (gen.arabic || 0) + ' AR)');
        if (gen.newSaved !== undefined) d('New Topics Saved', gen.newSaved + ' new to DB');
        if (gen.duplicatesSkipped > 0) d('Duplicates Skipped', gen.duplicatesSkipped + ' already existed');
      } else {
        d('Topics Generated', json.topicsGenerated || gen || 0);
      }
      if (json.pendingCountBefore !== undefined) d('Pending Backlog (before)', json.pendingCountBefore);
      else d('Pending Backlog', json.pendingCount || json.backlog || '?');
      if (json.reason === 'sufficient_backlog') d('Skipped', 'Backlog is sufficient — no new topics needed');
      else if (json.reason) d('Trigger Reason', json.reason === 'weekly_scheduled' ? 'Weekly schedule (Sunday)' : json.reason === 'low_backlog_trigger' ? 'Low backlog (< 10 pending)' : json.reason);
      else if (json.skipped) d('Skipped', json.reason || 'Not Sunday / backlog sufficient');
      if (json.source) d('AI Source Used', json.source);
      if (gen && (gen.total > 0 || json.topicsGenerated > 0)) d('Saved To', 'TopicProposal table (status: ready, auto-queued for content generation)');
      if (json.sites) {
        for (const [siteId, siteData] of Object.entries(json.sites || {})) {
          d('Site: ' + siteId, (siteData.en || 0) + ' EN + ' + (siteData.ar || 0) + ' AR topics');
        }
      }
      break;
    }
    case 'Content Builder': {
      // Healthcheck response: { status, phaseCounts, reservoirCount, ... }
      // Execution response: { draftId, keyword, previousPhase, nextPhase, phaseSuccess, ... }
      if (json.phaseCounts) {
        const pc = json.phaseCounts;
        const phases = ['research', 'outline', 'drafting', 'assembly', 'images', 'seo', 'scoring', 'reservoir', 'published', 'rejected'];
        for (const p of phases) {
          if (pc[p] !== undefined && pc[p] > 0) d('Phase: ' + p, pc[p] + ' drafts');
        }
        const total = Object.values(pc).reduce((a, b) => Number(a) + Number(b), 0);
        d('Total Drafts', total);
      }
      if (json.draftId) {
        d('Draft ID', json.draftId);
        d('Keyword', json.keyword || '?');
        d('Phase', (json.previousPhase || '?') + ' → ' + (json.nextPhase || '?'));
        d('Phase Success', json.phaseSuccess ? 'Yes' : 'No' + (json.phaseError ? ' — ' + json.phaseError : ''));
        if (json.strategy) d('Strategy', json.strategy);
      }
      if (json.reservoirCount !== undefined) d('Reservoir Count', json.reservoirCount + ' articles ready');
      if (json.durationMs) d('Duration', json.durationMs + 'ms');
      d('Pipeline', 'research → outline → drafting → assembly → images → seo → scoring → reservoir');
      d('Bilingual', 'Each topic creates EN + AR drafts (paired, independent pipelines)');
      break;
    }
    case 'Content Selector': {
      // Healthcheck response: { reservoirCount, publishedCount, minQualityScore, maxPerRun }
      // Execution response: { reservoirCandidates, selected, published, articles: [...] }
      if (json.reservoirCount !== undefined) d('Reservoir Articles', json.reservoirCount);
      if (json.publishedCount !== undefined) d('Published (total)', json.publishedCount);
      if (json.minQualityScore !== undefined) d('Min Quality Score', json.minQualityScore + '/100');
      if (json.maxPerRun !== undefined) d('Max Per Run', json.maxPerRun + ' articles');
      if (json.reservoirCandidates !== undefined) d('Candidates Found', json.reservoirCandidates);
      if (json.selected !== undefined) d('Selected', json.selected);
      if (json.published !== undefined) d('Published This Run', json.published + ' articles');
      if (json.articles && json.articles.length > 0) {
        for (const a of json.articles) {
          d('  ↳ Published', '"' + a.keyword + '" (score: ' + a.score + ')');
        }
      }
      if (json.durationMs) d('Duration', json.durationMs + 'ms');
      d('Pipeline', 'ArticleDraft (reservoir) → BlogPost (auto-published, tagged needs-review)');
      break;
    }
    case 'SEO Orchestrator': {
      if (json.lastRun) {
        const status = json.lastRun.status;
        const statusCls = status === 'healthy' ? 'pass' : status === 'needs_attention' ? 'warn' : 'fail';
        details.push({ label: 'Last Run', value: status + (json.lastRun.at ? ' at ' + new Date(json.lastRun.at).toLocaleString() : ''), cls: statusCls });
        if (json.lastRun.healthScore !== undefined) {
          const hs = json.lastRun.healthScore;
          details.push({ label: 'Health Score', value: hs + '/100' + (hs < 60 ? ' — needs improvement' : hs < 80 ? ' — acceptable' : ' — good'), cls: hs >= 70 ? 'pass' : hs >= 50 ? 'warn' : 'fail' });
        }
        if (json.lastRun.issuesFound !== undefined) details.push({ label: 'Issues Found', value: String(json.lastRun.issuesFound), cls: json.lastRun.issuesFound > 0 ? 'warn' : 'pass' });
        if (json.lastRun.fixesApplied !== undefined) d('Auto-Fixes Applied', json.lastRun.fixesApplied);
      }
      d('Sites Monitored', json.sites || '?');
      d('Report Saved', 'SeoReport + SiteHealthCheck tables');
      break;
    }
    case 'SEO Agent': {
      if (json.lastRun) {
        const status = json.lastRun.status;
        const statusCls = status === 'completed' ? 'pass' : status === 'timed_out' ? 'warn' : 'fail';
        details.push({ label: 'Last Run', value: status + ' — ' + new Date(json.lastRun.started_at || json.lastRun.at).toLocaleString(), cls: statusCls });
        if (json.lastRun.duration_ms) {
          const dur = json.lastRun.duration_ms;
          details.push({ label: 'Duration', value: dur + 'ms' + (dur > 60000 ? ' (over 60s — risk of timeout)' : ''), cls: dur > 60000 ? 'warn' : 'pass' });
        }
        if (status === 'timed_out') w('Timeout Fix', 'AI batch sizes reduced: meta optimization 5→2, content expansion 3→1, token limit 4096→2048. Re-run to verify.');
      }
      if (json.sites) d('Active Sites', json.sites);
      if (json.activeSites) d('Live Sites', json.activeSites.join(', '));
      d('Agent Tasks', '13-step autonomous SEO: audit → schema → indexing → GSC → content rewrite queue');
      d('Report Saved', 'SeoReport table + URLIndexingStatus + TopicProposal (rewrites)');
      break;
    }
    case 'SEO Health Report': {
      d('Status', json.message || json.status || 'Generated');
      if (json.score !== undefined) d('Overall SEO Score', json.score + '/100');
      d('Saved To', 'SeoReport table (type: weekly-health-report)');
      break;
    }
    case 'Daily Content Generate': {
      if (json.lastRun) {
        d('Last Run', json.lastRun.status + ' — ' + new Date(json.lastRun.started_at || json.lastRun.at).toLocaleString());
        if (json.lastRun.duration_ms > 60000) w('Duration', json.lastRun.duration_ms + 'ms (SLOW — risk of timeout)');
        else if (json.lastRun.duration_ms) d('Duration', json.lastRun.duration_ms + 'ms');
      }
      if (json.activeSites) d('Active Sites', json.activeSites.join(', '));
      if (json.sites && typeof json.sites === 'object' && !Array.isArray(json.sites)) {
        for (const [siteId, siteData] of Object.entries(json.sites)) {
          if (siteData.results) {
            const successes = siteData.results.filter(r => r.status === 'success');
            const slugs = successes.map(r => r.articleSlug).filter(Boolean);
            if (slugs.length) d('Generated (' + siteId + ')', slugs.join(', '));
            else if (siteData.status === 'failed') f('Failed (' + siteId + ')', siteData.error || 'Unknown error');
            else if (siteData.status === 'skipped') w('Skipped (' + siteId + ')', siteData.reason || 'Timeout or site not live');
          }
        }
      }
      d('AI Provider', 'Grok (primary) → Claude → OpenAI → Gemini → AbacusAI');
      d('Saved To', 'BlogPost table (status: published) + SeoMeta + URLIndexingStatus');
      d('Timeout Budget', '290s (300s maxDuration - 10s safety margin)');
      break;
    }
    case 'Daily Publish': {
      d('Status', json.message || 'Completed');
      if (json.published) d('Published', json.published + ' posts');
      if (json.availableTopics !== undefined) d('Available Topics', json.availableTopics);
      if (json.message?.includes('No approved')) w('Note', 'No approved topics in queue — daily-publish requires manual approval via admin UI. Content is auto-generated by daily-content-generate cron instead.');
      break;
    }
    case 'Scheduled Publish': {
      d('Status', json.message || 'Completed');
      const pubCount = json.published ?? json.publishedCount ?? json.count ?? 0;
      d('Published This Run', pubCount + ' posts');
      if (json.pending !== undefined) d('Still Pending', json.pending + ' posts');
      if (json.nextScheduled?.length) d('Next Scheduled', json.nextScheduled.map(p => (p.title || '').substring(0, 40)).join('; '));
      break;
    }
    case 'Auto Generate': {
      d('Status', json.message || 'Completed');
      if (json.generated !== undefined) d('Generated', json.generated + ' articles');
      if (json.queued !== undefined) d('Queued', json.queued + ' articles');
      break;
    }
    case 'Fact Verification': {
      if (json.status === 'healthy') d('Status', 'Healthy (healthcheck mode)');
      else {
        d('Status', json.message || 'Completed');
        if (json.factsChecked !== undefined) d('Facts Checked', json.factsChecked);
        if (json.issuesFound !== undefined) d('Issues Found', json.issuesFound);
      }
      d('Saved To', 'FactEntry table (flagged facts for manual review)');
      break;
    }
    case 'London News': {
      d('Status', json.message || json.status || 'Completed');
      const m = json.metrics || {};
      if (m.itemsPublished !== undefined) d('News Items Published', m.itemsPublished);
      if (m.itemsArchived !== undefined) d('Expired Items Archived', m.itemsArchived);
      if (m.templatesActive !== undefined) d('Templates Active', m.templatesActive);
      if (m.sourcesChecked?.length) d('Sources Checked', m.sourcesChecked.join(', '));
      // Check if Grok was used by looking at sourcesChecked array or grok-tagged items
      const grokUsed = (m.sourcesChecked || []).some(s => s.toLowerCase().includes('grok'));
      const grokItems = (json.createdItems || []).filter(i => JSON.stringify(i).toLowerCase().includes('grok'));
      if (grokUsed) d('Grok Live News', 'Active — real-time news from X/Twitter integrated' + (grokItems.length ? ' (' + grokItems.length + ' items)' : ''));
      else if (grokItems.length > 0) d('Grok Live News', 'Active — ' + grokItems.length + ' items from Grok');
      else d('Grok Live News', 'Not used this run — Grok supplements template news when XAI_API_KEY is set');
      if (json.createdItems?.length) {
        for (const item of json.createdItems.slice(0, 5)) {
          d('  ↳ ' + (item.category || 'news'), (item.headline || item.slug || '').substring(0, 60));
        }
      }
      if (json.durationMs) d('Duration', json.durationMs + 'ms');
      d('Saved To', 'NewsItem table + NewsResearchLog');
      break;
    }
    case 'Real-Time Optimization': {
      const checked = json.checked || json.articlesChecked || 0;
      const flagged = json.flagged || json.optimizationsNeeded || 0;
      d('Articles Checked', checked);
      d('Flagged for Optimization', flagged);
      if (flagged > 0) w('Action', flagged + ' articles need SEO score improvements or content updates');
      else d('Result', 'All checked articles meet quality thresholds');
      break;
    }
    case 'Google Indexing': {
      d('Total URLs Submitted', json.totalUrlsSubmitted || 0);
      if (json.totalErrors > 0) w('Submission Errors', json.totalErrors);
      if (json.results && Array.isArray(json.results)) {
        for (const r of json.results) {
          const inStatus = r.indexNow?.status || 'unknown';
          const inCount = r.indexNow?.submitted || 0;
          const gscOk = r.gscSitemap?.success;
          const siteLabel = r.siteId || 'unknown';
          if (r.urlsFound === 0) {
            w('Site: ' + siteLabel, '0 URLs found — no new/updated content in last 3 days');
          } else {
            d('Site: ' + siteLabel, r.urlsFound + ' URLs found → IndexNow: ' + inCount + ' submitted (' + inStatus + ')' + (gscOk ? ' | GSC sitemap: pinged' : gscOk === false ? ' | GSC sitemap: FAILED' : ''));
          }
        }
      }
      w('Indexing Pipeline', 'IndexNow → Bing/Yandex (instant) | GSC sitemap ping → Google (hours-days)');
      if (!json.hasIndexNowKey && json.hasIndexNowKey !== undefined) f('INDEXNOW_KEY', 'NOT SET — URLs cannot be submitted to Bing/Yandex. Set INDEXNOW_KEY in Vercel env vars.');
      if (!json.hasGscCredentials && json.hasGscCredentials !== undefined) w('GSC Credentials', 'Not configured — Google sitemap ping disabled');
      d('Tracking Table', 'URLIndexingStatus (per-URL status: submitted → pending_review → indexed | failed)');
      break;
    }
    case 'Autopilot': {
      d('Status', json.message || json.status || 'Completed');
      if (json.tasksRun !== undefined) d('Tasks Executed', json.tasksRun);
      if (json.tasksSeeded !== undefined) d('Tasks Self-Seeded', json.tasksSeeded);
      if (json.nextDue) d('Next Due Task', json.nextDue);
      break;
    }
    case 'Social': {
      const processed = json.postsProcessed || json.ran || 0;
      const published = json.published || json.succeeded || 0;
      const failed = json.failed || 0;
      if (processed === 0 && published === 0) {
        w('Status', 'MOCK IMPLEMENTATION — No posts queued. Social API integration not yet connected.');
        w('Note', 'Posts are marked "published" in DB but NOT actually sent to Twitter/X, Instagram, or LinkedIn.');
        w('Requires', 'TWITTER_API_KEY + TWITTER_API_SECRET + TWITTER_ACCESS_TOKEN + TWITTER_ACCESS_TOKEN_SECRET (just updated on Vercel)');
      } else {
        d('Posts Processed', processed);
        d('Published', published);
        if (failed > 0) f('Failed', failed);
      }
      if (json.results?.length) {
        for (const r of json.results) {
          d('Post: ' + r.platform, r.status + (r.note ? ' — ' + r.note : ''));
        }
      }
      break;
    }
  }
  return details;
}

async function runAllJobs() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('jobsBtn').disabled = true;
  document.getElementById('jobsBtn').textContent = 'Running Jobs...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  // Active sites banner
  addSection('sites-info', 'Active Sites Configuration');
  addResult('sites-info', 'Live Sites', 'pass', 'yalla-london (yalla-london.com)');
  addResult('sites-info', 'Inactive Sites (no website yet)', 'warn',
    'arabaldives, french-riviera, istanbul, thailand — cron jobs skip these sites to save AI tokens and time',
    'These sites are defined in <code>config/sites.ts</code> but have no deployed website. Cron jobs use <code>getActiveSiteIds()</code> to process only live sites. Add site IDs to <code>LIVE_SITES</code> array when their websites go live.');

  addSection('jobs', 'Cron Job Execution Results');

  // Jobs ordered by dependency chain: foundational first, then consumers
  const jobs = [
    { name: 'Analytics Sync',          path: '/api/cron/analytics',               method: 'GET',  timeout: 55000, category: 'Analytics & Data' },
    { name: 'Site Health Check',        path: '/api/cron/site-health-check',       method: 'GET',  timeout: 55000, category: 'Analytics & Data' },
    { name: 'Trends Monitor',          path: '/api/cron/trends-monitor',          method: 'GET',  timeout: 55000, category: 'Research & Intelligence' },
    { name: 'Weekly Topics',           path: '/api/cron/weekly-topics',           method: 'GET',  timeout: 55000, category: 'Research & Intelligence' },
    { name: 'SEO Orchestrator',        path: '/api/cron/seo-orchestrator?healthcheck=true', method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'SEO Agent',               path: '/api/cron/seo-agent?healthcheck=true',       method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'SEO Health Report',       path: '/api/cron/seo-health-report',      method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'Daily Content Generate',  path: '/api/cron/daily-content-generate',  method: 'GET',  timeout: 115000, category: 'Content' },
    { name: 'Daily Publish',           path: '/api/cron/daily-publish',           method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Scheduled Publish',       path: '/api/cron/scheduled-publish',       method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Auto Generate',           path: '/api/cron/auto-generate',           method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Fact Verification',       path: '/api/cron/fact-verification?healthcheck=true', method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'London News',             path: '/api/cron/london-news',             method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Content Builder',         path: '/api/cron/content-builder?healthcheck=true', method: 'GET',  timeout: 55000, category: 'Content Pipeline' },
    { name: 'Content Selector',        path: '/api/cron/content-selector?healthcheck=true', method: 'GET',  timeout: 55000, category: 'Content Pipeline' },
    { name: 'Real-Time Optimization',  path: '/api/cron/real-time-optimization',  method: 'POST', timeout: 55000, category: 'SEO' },
    { name: 'Google Indexing',          path: '/api/cron/google-indexing',          method: 'GET',  timeout: 55000, category: 'Indexing' },
    { name: 'Autopilot',              path: '/api/cron/autopilot',               method: 'GET',  timeout: 55000, category: 'Orchestration' },
    { name: 'Social',                 path: '/api/cron/social',                  method: 'GET',  timeout: 55000, category: 'Social' },
  ];

  let jobPass = 0, jobFail = 0, jobWarn = 0;
  const jobResults = [];
  const envStatus = {
    confirmed: ['DATABASE_URL', 'CRON_SECRET', 'NEXTAUTH_SECRET', 'NODE_ENV'],
    justUpdated: ['XAI_API_KEY', 'TWITTER_API_KEY'],
    needsVerification: [],
    missing: [],
  };

  for (let i = 0; i < jobs.length; i++) {
    const job = jobs[i];
    const startTime = Date.now();
    log('  [' + (i + 1) + '/' + jobs.length + '] ' + job.name + ' (' + job.path + ')...');
    updateSummary();

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), job.timeout);
      const resp = await fetch(job.path, {
        method: job.method,
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const elapsed = Date.now() - startTime;
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}

      const durationHint = json?.durationMs ? ' (' + json.durationMs + 'ms)' : ' (' + elapsed + 'ms)';

      // Smart response-body analysis
      const bodyIssues = resp.ok && json ? analyzeJobResponse(job.name, json) : null;

      // Determine overall status
      let status, detail, diagnosis;
      if (resp.ok && bodyIssues) {
        status = bodyIssues.severity;
        detail = 'HTTP ' + resp.status + durationHint + ' — ' + bodyIssues.summary;
        diagnosis = bodyIssues.diagnosis;
      } else if (resp.ok) {
        status = 'pass';
        detail = 'HTTP ' + resp.status + durationHint + ' — OK';
      } else if (resp.status === 504 || resp.status === 503) {
        status = 'warn';
        detail = 'HTTP ' + resp.status + ' — Timeout/Unavailable';
        diagnosis = resp.status === 504 ? 'Function exceeded Vercel timeout. This job needs a higher <code>maxDuration</code> or task splitting.' :
          'Service temporarily unavailable. May be a build error or cold start issue.';
      } else if (resp.status === 401) {
        status = 'fail';
        detail = 'HTTP 401 — CRON_SECRET mismatch';
      } else {
        status = 'fail';
        detail = 'HTTP ' + resp.status + ' — ' + (json?.error || text?.substring(0, 150) || 'Unknown error');
      }

      // Add main result
      addResult('jobs', job.name + '  [' + job.category + ']', status, detail, diagnosis);

      // Add expanded details
      const details = extractJobDetails(job.name, json);
      for (const dt of details) {
        addResult('jobs', '  ↳ ' + dt.label, dt.cls, dt.value);
      }

      // Track env var status from responses
      if (json) {
        if (json.results?.ga4?.status === 'not_configured') {
          (json.results.ga4.missing || ['GA4_PROPERTY_ID', 'GOOGLE_ANALYTICS_CLIENT_EMAIL', 'GOOGLE_ANALYTICS_PRIVATE_KEY']).forEach(v => {
            if (!envStatus.missing.includes(v)) envStatus.missing.push(v);
          });
        }
        if (json.hasIndexNowKey === false && !envStatus.missing.includes('INDEXNOW_KEY')) envStatus.missing.push('INDEXNOW_KEY');
        if (json.hasGscCredentials === false) {
          ['GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL', 'GOOGLE_SEARCH_CONSOLE_PRIVATE_KEY'].forEach(v => {
            if (!envStatus.missing.includes(v) && !envStatus.needsVerification.includes(v)) envStatus.needsVerification.push(v);
          });
        }
      }

      if (json) addJsonBlock('jobs', json);

      if (status === 'fail') jobFail++;
      else if (status === 'warn') jobWarn++;
      else jobPass++;

      jobResults.push({
        name: job.name,
        category: job.category,
        status,
        httpStatus: resp.status,
        durationMs: json?.durationMs || elapsed,
        detail: detail.substring(0, 250),
        expandedDetails: details,
        responseKeys: json ? Object.keys(json) : [],
      });
    } catch (e) {
      const elapsed = Date.now() - startTime;
      const isTimeout = e.name === 'AbortError' || e.message?.includes('aborted');
      if (isTimeout) {
        addResult('jobs', job.name + '  [' + job.category + ']', 'warn',
          'Client timeout (' + Math.round(elapsed / 1000) + 's) — function may still be running on server',
          job.name === 'Daily Content Generate'
            ? 'Content generation takes up to 290s. It likely completed on the server. Check Vercel Function Logs. Consider splitting per-site generation into separate cron entries.'
            : 'The function exceeded the client timeout. It may have completed on the server. Check Vercel Function Logs.');
        jobWarn++;
      } else {
        addResult('jobs', job.name + '  [' + job.category + ']', 'fail', 'Network error: ' + e.message);
        jobFail++;
      }
      jobResults.push({ name: job.name, category: job.category, status: isTimeout ? 'warn' : 'fail', durationMs: elapsed, error: e.message });
    }

    // 3s pause between jobs for PgBouncer session drain
    if (i < jobs.length - 1) {
      await new Promise(r => setTimeout(r, 3000));
    }
  }

  // ── Environment Variables Status ──
  addSection('envstatus', 'Environment Variables Status');
  for (const v of envStatus.confirmed) addResult('envstatus', v, 'pass', 'Confirmed set on Vercel');
  for (const v of envStatus.justUpdated) addResult('envstatus', v, 'pass', 'Just updated on Vercel (verify working)');
  for (const v of envStatus.needsVerification) addResult('envstatus', v, 'warn', 'Needs verification — set in Vercel but not confirmed working');
  for (const v of envStatus.missing) addResult('envstatus', v, 'fail', 'MISSING — not set in Vercel. Required for full functionality.',
    'Set this env var in Vercel → Settings → Environment Variables. See <code>.env.example</code> for format and description.');

  // ── Summary ──
  addResult('jobs', 'Summary', jobFail === 0 ? 'pass' : 'fail',
    jobPass + ' passed, ' + jobWarn + ' warnings, ' + jobFail + ' failed out of ' + jobs.length + ' jobs');

  // ── Extensive Summary JSON + Copy Button ──
  const fullSummary = {
    action: 'run-all-jobs',
    timestamp: new Date().toISOString(),
    platform: {
      activeSites: ['yalla-london'],
      inactiveSites: ['arabaldives', 'french-riviera', 'istanbul', 'thailand'],
      reason: 'Only yalla-london has a deployed website. Other sites skip cron processing.',
    },
    summary: {
      passed: jobPass,
      warnings: jobWarn,
      failed: jobFail,
      total: jobs.length,
      verdict: jobFail === 0 && jobWarn === 0 ? 'ALL_CLEAR' : jobFail === 0 ? 'OPERATIONAL_WITH_WARNINGS' : 'NEEDS_ATTENTION',
    },
    environmentVariables: envStatus,
    results: jobResults,
    recommendations: [
      ...(envStatus.missing.includes('INDEXNOW_KEY') ? ['Set INDEXNOW_KEY for Bing/Yandex fast indexing'] : []),
      ...(envStatus.missing.some(v => v.includes('GA4')) ? ['Set GA4_PROPERTY_ID + service account for analytics data'] : []),
      ...(envStatus.missing.some(v => v.includes('GSC') || v.includes('SEARCH_CONSOLE')) ? ['Set GSC service account credentials for search performance data'] : []),
      ...(jobResults.some(r => r.name === 'Social' && r.status === 'warn') ? ['Social posting is MOCK — implement real Twitter/X API integration when ready'] : []),
      ...(jobResults.some(r => r.name === 'Daily Content Generate' && r.durationMs > 60000) ? ['Content generation is slow — consider splitting per-site into separate cron entries'] : []),
    ],
    cronSchedule: {
      '3:00 UTC': 'Analytics sync',
      '4:00 UTC Mon': 'Weekly topic research',
      '5:00 UTC': 'Daily content generation',
      '5:00 UTC Sun': 'SEO orchestrator (weekly)',
      '6:00 UTC': 'Trends monitor + SEO orchestrator (daily)',
      '7:00 UTC': 'SEO agent run 1',
      '7:30 UTC': 'SEO daily cron',
      '8:00 UTC Sun': 'SEO weekly cron',
      '9:00 UTC': 'Scheduled publish (morning)',
      '10:00 UTC': 'Google indexing',
      '13:00 UTC': 'SEO agent run 2',
      '16:00 UTC': 'Scheduled publish (afternoon)',
      '20:00 UTC': 'SEO agent run 3',
    },
    knownIssues: [
      'Social cron is MOCK — marks published in DB but does NOT post to Twitter/X/Instagram/LinkedIn',
      'Soft-delete migrations not deployed — deletedAt column dormant',
      'PgBouncer connection_limit=1 workaround for Supabase session mode',
      'Content generation timeout risk at 290s budget — works for 1 site, may need splitting for 5',
    ],
  };

  // Remove existing JSON export
  const existing = document.getElementById('section-jobsjson');
  if (existing) existing.remove();

  const jsonStr = JSON.stringify(fullSummary, null, 2);
  const jsonHtml = `<div class="section" id="section-jobsjson">
    <h2>Full Operations Report — JSON</h2>
    <p style="color:#888;font-size:0.8rem;margin-bottom:8px;">Complete diagnostic data including env vars, recommendations, schedule, and known issues.</p>
    <button onclick="copyJobsJson()" id="copyJobsBtn" style="margin:0 0 12px;padding:8px 20px;font-size:0.85rem;background:#7c3aed;">Copy JSON to Clipboard</button>
    <textarea id="jobsJsonArea" readonly style="width:100%;height:400px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.75rem;resize:vertical;">${escapeHtml(jsonStr)}</textarea>
  </div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', jsonHtml);

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (jobFail === 0 && jobWarn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL ' + jobs.length + ' CRON JOBS PASSED</div>';
  } else if (jobFail === 0) {
    banner.innerHTML = '<div class="status-banner status-warn">' + jobPass + ' JOBS PASSED, ' + jobWarn + ' WARNINGS — No critical failures</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + jobFail + ' JOB(S) FAILED — See details above</div>';
  }

  document.getElementById('jobsBtn').disabled = false;
  document.getElementById('jobsBtn').textContent = 'Run All Cron Jobs';
}

function copyJobsJson() {
  const area = document.getElementById('jobsJsonArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = document.getElementById('copyJobsBtn');
    btn.textContent = 'Copied!';
    btn.style.background = '#16a34a';
    setTimeout(() => { btn.textContent = 'Copy JSON to Clipboard'; btn.style.background = '#7c3aed'; }, 2000);
  }).catch(() => { document.execCommand('copy'); });
}

// ─── Test Runner ──────────────────────────────────────────────────────────
async function runAllTests() {
  pass = 0; fail = 0; warn = 0;
  allResults = [];
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  document.getElementById('runBtn').disabled = true;
  document.getElementById('runBtn').textContent = 'Testing...';

  const cronSecret = document.getElementById('cronSecret')?.value || '';

  // ── 1. GA4 Client-Side ──
  log('Testing GA4 client-side tracking...');
  addSection('ga4', '1. GA4 Client-Side Tracking');

  const homeResp = await testFetch('/');
  if (homeResp.ok) {
    const gaMatch = homeResp.text.match(/G-[A-Z0-9]{8,12}/);
    if (gaMatch) {
      addResult('ga4', 'GA4 Measurement ID', 'pass', 'Found on homepage: ' + gaMatch[0]);
      if (homeResp.text.includes('googletagmanager.com/gtag')) {
        addResult('ga4', 'gtag.js Script', 'pass', 'Script tag present on homepage');
      } else {
        addResult('ga4', 'gtag.js Script', 'warn', 'ID found but script tag not detected (may load async)');
      }
    } else {
      addResult('ga4', 'GA4 Measurement ID', 'fail', 'Not found in homepage source',
        'The <code>NEXT_PUBLIC_GA_MEASUREMENT_ID</code> env var may be missing in Vercel, or the GA4 script is not injected in <code>app/layout.tsx</code>. Check Vercel → Settings → Environment Variables for a value like <code>G-XXXXXXXXXX</code>.');
    }
  } else {
    addResult('ga4', 'Homepage Load', 'fail', 'Could not load homepage: HTTP ' + homeResp.status,
      homeResp.status === 0 ? 'Network error — site may be down or Cloudflare is blocking. Check Vercel deployment status.' :
      homeResp.status === 500 ? 'Server error — check Vercel Function Logs for the root cause (likely a missing env var or DB connection issue).' :
      homeResp.status === 503 ? 'Service unavailable — Vercel may be redeploying or the function timed out.' :
      'Unexpected HTTP ' + homeResp.status + ' — check Vercel logs.');
  }

  // ── 2. Static Assets (cache-bust to bypass stale CDN 404s) ──
  log('Testing static assets (with cache-bust)...');
  addSection('assets', '2. Static Assets');

  const cacheBust = '?v=' + Date.now();
  const assets = [
    ['/og-image.jpg' + cacheBust, 'OG Image (og-image.jpg)'],
    ['/icons/icon-512x512.png' + cacheBust, 'Icon 512x512'],
    ['/icons/icon-192x192.png' + cacheBust, 'Icon 192x192'],
    ['/favicon.ico' + cacheBust, 'Favicon ICO'],
    ['/favicon.png' + cacheBust, 'Favicon PNG'],
    ['/favicon.svg' + cacheBust, 'Favicon SVG'],
    ['/manifest.json' + cacheBust, 'Manifest'],
  ];

  for (const [url, label] of assets) {
    const resp = await testFetch(url, { method: 'HEAD' });
    if (resp.ok) {
      addResult('assets', label, 'pass', url.split('?')[0] + ' — HTTP ' + resp.status);
    } else {
      addResult('assets', label, 'fail', url.split('?')[0] + ' — HTTP ' + resp.status,
        resp.status === 404 ? 'File missing from <code>public/</code> folder. Ensure the file exists at <code>yalla_london/app/public' + url.split('?')[0] + '</code> and redeploy.' :
        'HTTP ' + resp.status + ' — may need Cloudflare cache purge. Try: Cloudflare Dashboard → Caching → Purge Everything.');
    }
  }

  // ── 3. Core Pages ──
  log('Testing core pages...');
  addSection('pages', '3. Core Pages');

  const pages = [
    ['/', 'Homepage'],
    ['/events', 'Events'],
    ['/blog', 'Blog'],
    ['/about', 'About'],
    ['/recommendations', 'Recommendations'],
    ['/sitemap.xml', 'Sitemap XML'],
  ];

  for (const [url, label] of pages) {
    const resp = await testFetch(url);
    if (resp.ok) {
      addResult('pages', label, 'pass', 'HTTP ' + resp.status);
    } else if (resp.status === 404) {
      addResult('pages', label, 'warn', 'HTTP 404',
        'Page not found. Check that <code>app/' + url.replace(/^\//, '') + '/page.tsx</code> exists in the App Router. If using dynamic routes, the page may need published content in the database to render.');
    } else {
      addResult('pages', label, 'fail', 'HTTP ' + resp.status,
        resp.status === 500 ? 'Server error rendering this page. Check Vercel Function Logs → filter by path <code>' + url + '</code> for the stack trace.' :
        resp.status === 0 ? 'Network timeout — page may be too slow to render. Check for expensive DB queries or missing data.' :
        'HTTP ' + resp.status + ' — check Vercel logs for this route.');
    }
  }

  // ── 4. SEO Meta Tags ──
  log('Testing SEO meta tags...');
  addSection('meta', '4. SEO Meta Tags');

  if (homeResp.ok) {
    const checks = [
      [/property="og:image"[^>]*content="([^"]+)"/, 'og:image'],
      [/property="og:title"[^>]*content="([^"]+)"/, 'og:title'],
      [/property="og:description"[^>]*content="([^"]+)"/, 'og:description'],
      [/rel="canonical"[^>]*href="([^"]+)"/, 'Canonical URL'],
    ];
    for (const [regex, label] of checks) {
      const match = homeResp.text.match(regex);
      if (match) addResult('meta', label, 'pass', match[1].substring(0, 80));
      else addResult('meta', label, 'warn', 'Not found on homepage',
        'Meta tag <code>' + label + '</code> is missing. Check the homepage <code>metadata</code> export in <code>app/page.tsx</code> or <code>app/layout.tsx</code>. For og:image, ensure <code>public/og-image.jpg</code> exists and is referenced in the metadata.');
    }
    const jsonLd = homeResp.text.match(/type="application\/ld\+json"/);
    if (jsonLd) addResult('meta', 'JSON-LD Schema', 'pass', 'Present');
    else addResult('meta', 'JSON-LD Schema', 'warn', 'Not found',
      'No JSON-LD structured data on homepage. Add a <code>&lt;script type="application/ld+json"&gt;</code> block in the layout or use the schema generator at <code>lib/seo/schema-generator.ts</code>.');
  }

  // ── 5. Database ──
  log('Testing database connection...');
  addSection('db', '5. Database Connection');

  const blogApiResp = await testFetch('/api/blog?limit=1');
  if (blogApiResp.ok && blogApiResp.json) {
    const j = blogApiResp.json;
    const count = j.total || j.posts?.length || j.length || '?';
    addResult('db', 'Blog API', 'pass', 'Connected — ' + count + ' posts returned');
  } else if (blogApiResp.status === 404) {
    addResult('db', 'Blog API', 'warn', 'No public blog API (DB may work via internal routes)',
      'No <code>/api/blog</code> route found. The blog API may be under <code>/api/admin/blog</code> (auth-required). The database itself is likely fine — this just means there is no public unauthenticated blog API.');
  } else {
    addResult('db', 'Blog API', blogApiResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + blogApiResp.status,
      blogApiResp.status === 500 ? 'Database connection failed. Check <code>DATABASE_URL</code> in Vercel env vars. The Prisma client may need <code>prisma generate</code> or the DB may be unreachable.' :
      blogApiResp.status === 503 ? 'Database temporarily unavailable — Supabase may be paused or connection pool exhausted.' :
      'HTTP ' + blogApiResp.status + ' — check <code>/api/blog/route.ts</code> for issues.');
  }

  // ── 6. AI Provider ──
  log('Testing AI provider...');
  addSection('ai', '6. AI Provider');

  const aiResp = await testFetch('/api/ai/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  if (aiResp.status === 401 || aiResp.status === 403) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (auth-protected)');
  } else if (aiResp.status === 400) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (needs valid payload)');
  } else if (aiResp.status === 404) {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'Not found at /api/ai/generate',
      'The AI generate endpoint doesn\'t exist at this path. Content generation uses the internal <code>lib/ai/provider.ts</code> layer directly from cron jobs — this is expected if there\'s no public AI endpoint.');
  } else if (aiResp.ok) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Responded OK');
  } else {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'HTTP ' + aiResp.status,
      aiResp.status === 500 ? 'AI provider error. Check that <code>ANTHROPIC_API_KEY</code> (or <code>OPENAI_API_KEY</code> / <code>ABACUSAI_API_KEY</code>) is set in Vercel env vars. Also check <code>ModelProvider</code> table in the DB.' :
      'Unexpected response — check Vercel function logs for <code>/api/ai/generate</code>.');
  }

  // ── 6b. Yacht Platform — Public APIs ──
  log('Testing Yacht Platform public APIs...');
  addSection('yachts-public', '6b. Yacht Platform — Public APIs');

  // GET /api/yachts — Public yacht search
  try {
    const yachtsResp = await testFetch('/api/yachts?limit=3');
    if (yachtsResp.ok && yachtsResp.json) {
      const j = yachtsResp.json;
      const count = j.total ?? j.yachts?.length ?? j.length ?? '?';
      addResult('yachts-public', 'Yacht Search API', 'pass', 'Connected — ' + count + ' yachts returned');
      if (j.yachts && j.yachts.length > 0) {
        addResult('yachts-public', 'Sample Yacht', 'pass', j.yachts[0].name + ' (' + (j.yachts[0].type || 'unknown type') + ')');
      }
    } else if (yachtsResp.status === 404) {
      addResult('yachts-public', 'Yacht Search API', 'warn', 'HTTP 404 — endpoint not deployed yet',
        'The <code>/api/yachts</code> route does not exist. Ensure <code>app/api/yachts/route.ts</code> is deployed. The yacht platform may not be active yet.');
    } else {
      addResult('yachts-public', 'Yacht Search API', yachtsResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + yachtsResp.status + ' — ' + (yachtsResp.errorDetail || ''),
        yachtsResp.status === 500 ? 'Server error. The <code>Yacht</code> table may not exist in the database. Click <strong>"Fix Missing Tables & Columns"</strong> or run <code>npx prisma db push</code>.' :
        'Unexpected response from yacht search API.');
    }
  } catch (e) { log('  ERROR: ' + e.message); addResult('yachts-public', 'Yacht Search API', 'fail', 'JS Error: ' + e.message); }

  // GET /api/yachts/destinations — Public destinations
  try {
    const destResp = await testFetch('/api/yachts/destinations');
    if (destResp.ok && destResp.json) {
      const j = destResp.json;
      const count = j.total ?? j.destinations?.length ?? j.length ?? '?';
      addResult('yachts-public', 'Destinations API', 'pass', 'Connected — ' + count + ' destinations returned');
    } else if (destResp.status === 404) {
      addResult('yachts-public', 'Destinations API', 'warn', 'HTTP 404 — endpoint not deployed yet',
        'The <code>/api/yachts/destinations</code> route is not deployed. Ensure <code>app/api/yachts/destinations/route.ts</code> exists.');
    } else {
      addResult('yachts-public', 'Destinations API', destResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + destResp.status + ' — ' + (destResp.errorDetail || ''));
    }
  } catch (e) { log('  ERROR: ' + e.message); addResult('yachts-public', 'Destinations API', 'fail', 'JS Error: ' + e.message); }

  // GET /api/yachts/itineraries — Public itineraries
  try {
    const itinResp = await testFetch('/api/yachts/itineraries');
    if (itinResp.ok && itinResp.json) {
      const j = itinResp.json;
      const count = j.total ?? j.itineraries?.length ?? j.length ?? '?';
      addResult('yachts-public', 'Itineraries API', 'pass', 'Connected — ' + count + ' itineraries returned');
    } else if (itinResp.status === 404) {
      addResult('yachts-public', 'Itineraries API', 'warn', 'HTTP 404 — endpoint not deployed yet',
        'The <code>/api/yachts/itineraries</code> route is not deployed.');
    } else {
      addResult('yachts-public', 'Itineraries API', itinResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + itinResp.status + ' — ' + (itinResp.errorDetail || ''));
    }
  } catch (e) { log('  ERROR: ' + e.message); addResult('yachts-public', 'Itineraries API', 'fail', 'JS Error: ' + e.message); }

  // POST /api/inquiry — Charter inquiry submission (test with sample data)
  try {
    const inquiryResp = await testFetch('/api/inquiry', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        firstName: '__TEST__',
        lastName: 'Validator',
        email: 'test-validator@example.com',
        destination: 'Mediterranean',
        guestCount: 4,
        message: 'Automated connectivity test — please ignore',
        _testMode: true,
      }),
    });
    if (inquiryResp.ok) {
      addResult('yachts-public', 'Charter Inquiry API (POST)', 'pass', 'Accepted — inquiry endpoint is functional');
    } else if (inquiryResp.status === 400) {
      addResult('yachts-public', 'Charter Inquiry API (POST)', 'pass', 'Exists — returned 400 (validation active, expected for test payload)');
    } else if (inquiryResp.status === 404) {
      addResult('yachts-public', 'Charter Inquiry API (POST)', 'warn', 'HTTP 404 — endpoint not deployed yet',
        'The <code>/api/inquiry</code> route is not deployed. Ensure <code>app/api/inquiry/route.ts</code> exists.');
    } else if (inquiryResp.status === 401 || inquiryResp.status === 403) {
      addResult('yachts-public', 'Charter Inquiry API (POST)', 'pass', 'Exists (auth-protected) — HTTP ' + inquiryResp.status);
    } else {
      addResult('yachts-public', 'Charter Inquiry API (POST)', inquiryResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + inquiryResp.status + ' — ' + (inquiryResp.errorDetail || ''),
        inquiryResp.status === 500 ? 'The <code>CharterInquiry</code> table may not exist. Run <code>npx prisma db push</code> to create it.' :
        'Unexpected response from inquiry endpoint.');
    }
  } catch (e) { log('  ERROR: ' + e.message); addResult('yachts-public', 'Charter Inquiry API (POST)', 'fail', 'JS Error: ' + e.message); }

  // ── Full pipeline tests (need CRON_SECRET) ──
  if (testMode === 'full' && cronSecret) {
    const cronHeaders = { 'Authorization': 'Bearer ' + cronSecret };

    // ── 7. Content Generation Pipeline ──
    log('Testing content generation pipeline...');
    addSection('pipeline', '7. Content Generation Pipeline');
    try {
      log('  Testing daily-content-generate...');
      const contentResp = await testFetch('/api/cron/daily-content-generate?healthcheck=true', { headers: cronHeaders });
      if (contentResp.ok && contentResp.json) {
        const j = contentResp.json;
        addResult('pipeline', 'Daily Content Generate', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) {
          const runCls = j.lastRun.status === 'completed' ? 'pass' : j.lastRun.status === 'timed_out' ? 'warn' : 'fail';
          addResult('pipeline', 'Last Run', runCls, j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        }
        if (j.sites !== undefined) addResult('pipeline', 'Active Sites', 'pass', j.sites + ' sites configured');
        addJsonBlock('pipeline', j);
      } else if (contentResp.status === 401) {
        addResult('pipeline', 'Daily Content Generate', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'The CRON_SECRET you entered doesn\'t match what\'s in Vercel. Go to Vercel → Settings → Environment Variables → find <code>CRON_SECRET</code> and copy the exact value.');
      } else {
        const err = contentResp.json?.error || contentResp.text?.substring(0, 150) || 'Unknown error';
        const pipelineStatus = contentResp.status === 503 ? 'warn' : 'fail';
        addResult('pipeline', 'Daily Content Generate', pipelineStatus, 'HTTP ' + contentResp.status + ' — ' + err,
          contentResp.status === 500 ? 'Content generation crashed. Common causes: (1) No AI API key set (<code>ANTHROPIC_API_KEY</code>), (2) Database unreachable (<code>DATABASE_URL</code>), (3) No categories/authors seeded. Check Vercel Function Logs → filter <code>/api/cron/daily-content-generate</code>.' :
          contentResp.status === 503 ? 'The endpoint returned 503 (unhealthy). This usually means a dependent service (AI API, database, or config) is not available. Check that <code>ANTHROPIC_API_KEY</code> or another AI provider key is set in Vercel Environment Variables.' :
          'Check Vercel Function Logs for the full error stack trace.');
        if (contentResp.json) addJsonBlock('pipeline', contentResp.json);
      }
    } catch (e) { log('  ERROR in section 7: ' + e.message); addResult('pipeline', 'Daily Content Generate', 'fail', 'JS Error: ' + e.message); }

    // ── 8. Scheduled Publish ──
    log('  Testing scheduled-publish...');
    addSection('publish', '8. Scheduled Publish');
    try {
      const publishResp = await testFetch('/api/cron/scheduled-publish', { headers: cronHeaders });
      if (publishResp.ok && publishResp.json) {
        const j = publishResp.json;
        addResult('publish', 'Scheduled Publish', 'pass', j.message || 'OK');
        const pubCount = j.published_count !== undefined ? j.published_count : (Array.isArray(j.published) ? j.published.length : j.published);
        if (pubCount !== undefined) addResult('publish', 'Posts Published', 'pass', pubCount + ' posts published this run');
        if (j.pending !== undefined) addResult('publish', 'Pending Schedule', 'pass', j.pending + ' posts pending');
        if (Array.isArray(j.nextScheduled) && j.nextScheduled.length) addResult('publish', 'Next Scheduled', 'pass', j.nextScheduled.map(p => (p.title || '').substring(0,40) + ' @ ' + (p.scheduled_at || '')).join('; '));
        addJsonBlock('publish', j);
      } else if (publishResp.status === 401) {
        addResult('publish', 'Scheduled Publish', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('publish', 'Scheduled Publish', 'warn', 'HTTP ' + publishResp.status + ' — ' + (publishResp.json?.error || publishResp.text?.substring(0,100) || ''),
          publishResp.status === 500 ? 'Publisher crashed. Likely a DB issue or no <code>ScheduledContent</code> records. Check Vercel logs for <code>/api/cron/scheduled-publish</code>.' :
          'Check Vercel Function Logs for details.');
        if (publishResp.json) addJsonBlock('publish', publishResp.json);
      }
    } catch (e) { log('  ERROR in section 8: ' + e.message); addResult('publish', 'Scheduled Publish', 'fail', 'JS Error: ' + e.message); }

    // ── 9. Weekly Topics ──
    log('  Testing weekly-topics...');
    addSection('topics', '9. Weekly Topics Research');
    try {
      const topicsResp = await testFetch('/api/cron/weekly-topics', { headers: cronHeaders });
      if (topicsResp.ok && topicsResp.json) {
        const j = topicsResp.json;
        addResult('topics', 'Weekly Topics', 'pass', j.message || 'OK');
        if (j.topicsGenerated !== undefined) addResult('topics', 'Topics Generated', 'pass', j.topicsGenerated + ' topics');
        if (j.pendingCount !== undefined) addResult('topics', 'Pending Backlog', 'pass', j.pendingCount + ' topics in backlog');
        if (j.skipped) addResult('topics', 'Status', 'pass', 'Skipped (not Sunday / backlog sufficient)');
        addJsonBlock('topics', j);
      } else if (topicsResp.status === 401) {
        addResult('topics', 'Weekly Topics', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('topics', 'Weekly Topics', 'warn', 'HTTP ' + topicsResp.status + ' — ' + (topicsResp.json?.error || topicsResp.text?.substring(0,100) || ''),
          topicsResp.status === 500 ? 'Topic research crashed. This cron uses AI to generate topics — check that AI API keys are configured and the <code>TopicProposal</code> table exists in Prisma.' :
          'Check Vercel Function Logs for <code>/api/cron/weekly-topics</code>.');
        if (topicsResp.json) addJsonBlock('topics', topicsResp.json);
      }
    } catch (e) { log('  ERROR in section 9: ' + e.message); addResult('topics', 'Weekly Topics', 'fail', 'JS Error: ' + e.message); }

    // ── 10. Trends Monitor ──
    log('  Testing trends-monitor...');
    addSection('trends', '10. Trends Monitor');
    try {
      const trendsResp = await testFetch('/api/cron/trends-monitor?healthcheck=true', { headers: cronHeaders });
      if (trendsResp.ok && trendsResp.json) {
        const j = trendsResp.json;
        addResult('trends', 'Trends Monitor', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('trends', 'Last Run', 'pass', new Date(j.lastRun.generatedAt).toLocaleString());
        if (j.monitoredKeywords) addResult('trends', 'Monitored Keywords', 'pass', j.monitoredKeywords + ' keywords tracked');
        addJsonBlock('trends', j);
      } else if (trendsResp.status === 401) {
        addResult('trends', 'Trends Monitor', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('trends', 'Trends Monitor', 'warn', 'HTTP ' + trendsResp.status + ' — ' + (trendsResp.json?.error || trendsResp.text?.substring(0,100) || ''),
          trendsResp.status === 500 ? 'Trends monitor crashed. It fetches RSS feeds and Google Trends data. Check <code>SERPAPI_API_KEY</code> env var and Vercel logs for <code>/api/cron/trends-monitor</code>.' :
          'Check Vercel Function Logs for details.');
        if (trendsResp.json) addJsonBlock('trends', trendsResp.json);
      }
    } catch (e) { log('  ERROR in section 10: ' + e.message); addResult('trends', 'Trends Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 11. Analytics Sync (Extensive) ──
    log('  Testing analytics sync (full run)...');
    addSection('analytics', '11. Analytics & Website Status — GA4 + GSC');
    try {
      const analyticsResp = await testFetch('/api/cron/analytics', { headers: cronHeaders });
      if (analyticsResp.ok && analyticsResp.json) {
        const j = analyticsResp.json;
        const ga = j.results?.ga4 || {};
        const gsc = j.results?.gsc || {};
        const snap = j.results?.snapshot || {};

        // GA4 Configuration Status
        if (ga.status === 'not_configured') {
          addResult('analytics', 'GA4 Configuration', 'fail', 'NOT CONFIGURED — Missing env vars: ' + (ga.missing || []).join(', '),
            'GA4 requires 3 env vars in Vercel: <code>GA4_PROPERTY_ID</code> (numeric), <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> (service account), <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> (PEM key). Service account needs "Viewer" role on GA4 property.');
        } else if (ga.status === 'error') {
          addResult('analytics', 'GA4 Data', 'fail', 'Error: ' + (ga.message || 'Unknown error'));
        } else if (ga.status === 'success') {
          addResult('analytics', 'GA4 Status', 'pass', 'Connected and returning data');

          // Core metrics
          addResult('analytics', 'Sessions (30d)', ga.sessions > 0 ? 'pass' : 'warn', (ga.sessions || 0).toLocaleString());
          addResult('analytics', 'Users (30d)', ga.users > 0 ? 'pass' : 'warn', (ga.users || 0).toLocaleString());
          addResult('analytics', 'Page Views (30d)', ga.pageViews > 0 ? 'pass' : 'warn', (ga.pageViews || 0).toLocaleString());
          addResult('analytics', 'Bounce Rate', ga.bounceRate < 70 ? 'pass' : 'warn', (ga.bounceRate || 0).toFixed(1) + '%',
            ga.bounceRate > 70 ? 'Bounce rate above 70% indicates visitors leave quickly. Improve content quality, page speed, and calls to action.' : undefined);
          addResult('analytics', 'Engagement Rate', ga.engagementRate > 30 ? 'pass' : 'warn', (ga.engagementRate || 0).toFixed(1) + '%',
            ga.engagementRate < 30 ? 'Low engagement rate (<30%) suggests content isn\'t holding attention. Consider better headlines, images, and content depth.' : undefined);
          if (ga.avgSessionDuration !== undefined) addResult('analytics', 'Avg Session Duration', ga.avgSessionDuration > 30 ? 'pass' : 'warn', (ga.avgSessionDuration || 0).toFixed(0) + 's');

          // Insights
          if (ga.insights) {
            addResult('analytics', 'Pages per Session', 'pass', ga.insights.pagesPerSession);
            addResult('analytics', 'New vs Returning', 'pass', ga.insights.newVsReturning);
          }

          // Top pages
          if (ga.topPages?.length) {
            addResult('analytics', 'Top Pages', 'pass', ga.topPages.length + ' pages tracked');
            for (const p of ga.topPages.slice(0, 5)) {
              addResult('analytics', '  ↳ ' + (p.path || '/').substring(0, 50), 'pass', (p.pageViews || 0) + ' views, ' + (p.sessions || 0) + ' sessions');
            }
          }

          // Top sources
          if (ga.topSources?.length) {
            addResult('analytics', 'Traffic Sources', 'pass', ga.topSources.length + ' sources');
            for (const s of ga.topSources.slice(0, 5)) {
              addResult('analytics', '  ↳ ' + (s.source || 'unknown'), 'pass', (s.sessions || 0) + ' sessions, ' + (s.users || 0) + ' users');
            }
          }

          // Alerts
          if (ga.alerts?.length) {
            for (const alert of ga.alerts) {
              addResult('analytics', 'Alert', 'warn', alert);
            }
          } else {
            addResult('analytics', 'Alerts', 'pass', 'No issues detected');
          }
        }

        // GSC Data
        if (gsc.status === 'success') {
          addResult('analytics', 'GSC Queries (30d)', 'pass', (gsc.queriesCount || 0) + ' search queries tracked');
          if (gsc.topQueries?.length) {
            for (const q of gsc.topQueries.slice(0, 5)) {
              addResult('analytics', '  ↳ "' + q.query + '"', 'pass',
                q.clicks + ' clicks, ' + q.impressions + ' impressions, CTR ' + q.ctr + '%, pos ' + q.position);
            }
          }
        } else if (gsc.status === 'not_configured') {
          addResult('analytics', 'GSC Status', 'warn', 'Not configured — set GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL + PRIVATE_KEY',
            'Google Search Console provides search query data (what people search to find your site). Requires a service account with "Full" access to the GSC property.');
        } else {
          addResult('analytics', 'GSC Status', 'warn', gsc.message || 'No data available');
        }

        // Snapshot
        if (snap.status === 'created') addResult('analytics', 'Data Snapshot', 'pass', 'Saved to AnalyticsSnapshot table in DB');

        addResult('analytics', 'Duration', 'pass', (j.durationMs || '?') + 'ms');
        addJsonBlock('analytics', j);
      } else if (analyticsResp.status === 401) {
        addResult('analytics', 'Analytics Cron', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('analytics', 'Analytics Cron', 'warn', 'HTTP ' + analyticsResp.status + ' — ' + (analyticsResp.json?.error || analyticsResp.text?.substring(0,100) || ''),
          analyticsResp.status === 500 ? 'Analytics sync crashed. Check: (1) <code>GA4_PROPERTY_ID</code> is set, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> + <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> are configured, (3) Service account has "Viewer" role on the GA4 property.' :
          'Check Vercel Function Logs for <code>/api/cron/analytics</code>.');
        if (analyticsResp.json) addJsonBlock('analytics', analyticsResp.json);
      }
    } catch (e) { log('  ERROR in section 11: ' + e.message); addResult('analytics', 'Analytics Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 12. SEO Agent ──
    log('  Testing SEO agent...');
    addSection('seoagent', '12. SEO Agent');
    try {
      const seoResp = await testFetch('/api/cron/seo-agent?healthcheck=true', { headers: cronHeaders });
      if (seoResp.ok && seoResp.json) {
        const j = seoResp.json;
        addResult('seoagent', 'SEO Agent', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('seoagent', 'Last Run', 'pass', j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        addJsonBlock('seoagent', j);
      } else if (seoResp.status === 401) {
        addResult('seoagent', 'SEO Agent', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('seoagent', 'SEO Agent', 'warn', 'HTTP ' + seoResp.status + ' — ' + (seoResp.json?.error || seoResp.text?.substring(0,100) || ''),
          seoResp.status === 500 ? 'SEO Agent crashed. This is the core 13-step agent. Check Vercel logs for <code>/api/cron/seo-agent</code>. Common causes: DB unreachable, missing GSC credentials, or the <code>SeoReport</code> / <code>BlogPost</code> tables have schema mismatches after a migration.' :
          'Check Vercel Function Logs for details.');
        if (seoResp.json) addJsonBlock('seoagent', seoResp.json);
      }
    } catch (e) { log('  ERROR in section 12: ' + e.message); addResult('seoagent', 'SEO Agent', 'fail', 'JS Error: ' + e.message); }

    // ── 13. SEO Daily Cron ──
    log('  Testing SEO daily cron...');
    try {
      const seoCronResp = await testFetch('/api/seo/cron?task=daily&healthcheck=true', { headers: cronHeaders });
      if (seoCronResp.ok && seoCronResp.json) {
        addResult('seoagent', 'SEO Daily Cron', 'pass', seoCronResp.json.message || 'OK');
      } else if (seoCronResp.status === 401) {
        addResult('seoagent', 'SEO Daily Cron', 'fail', 'HTTP 401');
      } else {
        addResult('seoagent', 'SEO Daily Cron', 'warn', 'HTTP ' + seoCronResp.status);
      }
    } catch (e) { log('  ERROR in section 13: ' + e.message); addResult('seoagent', 'SEO Daily Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 14. SEO Orchestrator ──
    log('  Testing SEO orchestrator...');
    addSection('orchestrator', '14. SEO Orchestrator');
    try {
      const orchResp = await testFetch('/api/cron/seo-orchestrator?healthcheck=true', { headers: cronHeaders });
      if (orchResp.ok && orchResp.json) {
        const j = orchResp.json;
        addResult('orchestrator', 'Orchestrator Status', 'pass', j.status === 'healthy' ? 'Healthy' : (j.status || 'OK'));
        if (j.lastRun) {
          addResult('orchestrator', 'Last Run', j.lastRun.status === 'error' ? 'fail' : 'pass',
            (j.lastRun.status || 'unknown') + (j.lastRun.at ? ' — ' + new Date(j.lastRun.at).toLocaleString() : ''));
          if (j.lastRun.healthScore !== undefined) addResult('orchestrator', 'Health Score', j.lastRun.healthScore >= 60 ? 'pass' : 'warn', j.lastRun.healthScore + '/100');
          if (j.lastRun.issuesFound !== undefined) addResult('orchestrator', 'Issues Found', j.lastRun.issuesFound > 10 ? 'warn' : 'pass', j.lastRun.issuesFound + ' issues');
          if (j.lastRun.fixesApplied !== undefined) addResult('orchestrator', 'Fixes Applied', 'pass', j.lastRun.fixesApplied + ' auto-fixes');
        }
        if (j.sites !== undefined) addResult('orchestrator', 'Sites Monitored', 'pass', j.sites + ' sites');
        addJsonBlock('orchestrator', j);
      } else if (orchResp.status === 401) {
        addResult('orchestrator', 'Orchestrator', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('orchestrator', 'Orchestrator', 'warn', 'HTTP ' + orchResp.status + ' — ' + (orchResp.json?.error || orchResp.text?.substring(0,150) || ''),
          orchResp.status === 500 ? 'Orchestrator crashed. This runs the 5-module system (live auditor, business goals, agent monitor, metrics collection, report storage). Check Vercel logs for <code>/api/cron/seo-orchestrator</code>. Most common cause: DB connection failure or missing <code>SiteHealthCheck</code> table.' :
          orchResp.status === 504 ? 'Timeout — the orchestrator audits all 5 sites sequentially and may exceed the function timeout. Check <code>maxDuration</code> in vercel.json (should be 120 for cron routes).' :
          'Check Vercel Function Logs for the full error.');
        if (orchResp.json) addJsonBlock('orchestrator', orchResp.json);
      }
    } catch (e) { log('  ERROR in section 14: ' + e.message); addResult('orchestrator', 'Orchestrator', 'fail', 'JS Error: ' + e.message); }

    // ── 15. Health Monitor (Cron Execution Proof) ──
    log('  Testing health monitor (cron log proof)...');
    addSection('healthmon', '15. Health Monitor — Cron Execution Proof');
    try {
      const hmResp = await testFetch('/api/admin/health-monitor', { headers: cronHeaders });
      if (hmResp.ok && hmResp.json) {
        const j = hmResp.json;
        // Database
        if (j.database) {
          addResult('healthmon', 'Database Connection', j.database.connected ? 'pass' : 'fail',
            j.database.connected ? 'Connected — ' + (j.database.latencyMs || '?') + 'ms latency' : (j.database.error || 'Disconnected'));
        }
        // Cron job status
        if (j.cronJobs && j.cronJobs.length > 0) {
          addResult('healthmon', 'Cron Jobs Tracked', 'pass', j.cronJobs.length + ' jobs in CronJobLog');
          const now = Date.now();
          for (const cron of j.cronJobs) {
            const ago = cron.lastRun ? Math.round((now - new Date(cron.lastRun).getTime()) / 3600000) : null;
            const agoStr = ago !== null ? ago + 'h ago' : 'never';
            const cronStatus = cron.status === 'completed' ? 'pass' : cron.status === 'failed' ? 'fail' : 'warn';
            addResult('healthmon', 'Cron: ' + cron.jobName, cronStatus,
              cron.status + ' — last: ' + agoStr + (cron.durationMs ? ' (' + cron.durationMs + 'ms)' : ''));
          }
        } else {
          addResult('healthmon', 'Cron Jobs', 'fail', 'No CronJobLog entries found — crons may not be executing',
            'The <code>cron_job_logs</code> table has zero entries. This means either: (1) No Vercel cron has fired yet — check Vercel Dashboard → project → Settings → Crons to see if they\'re scheduled, (2) The <code>CronJobLog</code> table doesn\'t exist — run <code>npx prisma db push</code> to sync the schema, or (3) The cron jobs are running but not using <code>logCronExecution()</code>.');
        }
        // Site health
        if (j.sites && j.sites.length > 0) {
          for (const site of j.sites) {
            const siteStatus = site.status === 'healthy' ? 'pass' : 'warn';
            addResult('healthmon', 'Site: ' + site.siteName, siteStatus,
              site.status + (site.healthScore !== null ? ' — score: ' + site.healthScore + '/100' : '') + ' (' + site.domain + ')',
              site.status === 'unknown' ? 'No health check data yet — the <code>site-health-check</code> cron has never run for this site. Once Vercel crons start executing, health scores will be populated automatically.' : undefined);
          }
        }
        // Indexing
        if (j.indexing) {
          const ix = j.indexing;
          addResult('healthmon', 'Indexing Status', ix.indexed > 0 ? 'pass' : 'warn',
            ix.indexed + '/' + ix.totalUrls + ' indexed (' + (ix.indexRate || 0) + '%) — ' + ix.submitted + ' submitted, ' + ix.errors + ' errors');
        }
        // Recent errors
        if (j.recentErrors && j.recentErrors.length > 0) {
          addResult('healthmon', 'Recent Errors (24h)', 'warn', j.recentErrors.length + ' errors');
          for (const err of j.recentErrors.slice(0, 5)) {
            addResult('healthmon', '  Error: ' + err.jobName, 'warn', err.error.substring(0, 120) + ' — ' + new Date(err.timestamp).toLocaleString());
          }
        } else if (j.recentErrors) {
          addResult('healthmon', 'Recent Errors (24h)', 'pass', 'None');
        }
        // Summary
        if (j.summary) {
          addResult('healthmon', 'Overall Summary', j.summary.failedCronJobs === 0 ? 'pass' : 'warn',
            j.summary.healthySites + '/' + j.summary.totalSites + ' healthy, ' +
            j.summary.failedCronJobs + ' failed crons, ' + j.summary.errorsLast24h + ' errors 24h');
        }
        addJsonBlock('healthmon', j);
      } else if (hmResp.status === 401 || hmResp.status === 403) {
        addResult('healthmon', 'Health Monitor', 'warn', 'Auth required — endpoint needs admin session cookie, not CRON_SECRET',
          'The <code>/api/admin/health-monitor</code> endpoint uses <code>withAdminAuth</code> which checks your NextAuth session cookie, not CRON_SECRET. Log into the admin dashboard first, then re-run this test in the same browser. Alternatively, access it directly while logged in: <code>/api/admin/health-monitor</code>.');
      } else {
        addResult('healthmon', 'Health Monitor', 'warn', 'HTTP ' + hmResp.status + ' — ' + (hmResp.json?.error || hmResp.text?.substring(0,100) || ''),
          hmResp.status === 500 ? 'Health monitor crashed. Check if the DB is reachable and the <code>CronJobLog</code>, <code>SiteHealthCheck</code>, and <code>URLIndexingStatus</code> tables exist.' :
          'Check Vercel Function Logs for <code>/api/admin/health-monitor</code>.');
        if (hmResp.json) addJsonBlock('healthmon', hmResp.json);
      }
    } catch (e) { log('  ERROR in section 15: ' + e.message); addResult('healthmon', 'Health Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 16. SEO Indexing Status ──
    log('  Testing SEO indexing status...');
    addSection('indexing', '16. SEO Indexing & Search Console');
    try {
      const idxResp = await testFetch('/api/admin/seo/indexing?type=stats', { headers: cronHeaders });
      if (idxResp.ok && idxResp.json) {
        const j = idxResp.json;
        const s = j.stats || {};
        addResult('indexing', 'Indexing Reports', j.success ? 'pass' : 'warn',
          s.totalReports + ' reports (' + s.totalSubmissions + ' submissions, ' + s.totalAudits + ' audits)');
        if (s.totalGoogleSubmitted !== undefined) addResult('indexing', 'Google API Submissions', s.totalGoogleSubmitted > 0 ? 'pass' : 'warn', s.totalGoogleSubmitted + ' URLs submitted');
        if (s.totalIndexNowSubmitted !== undefined) addResult('indexing', 'IndexNow Submissions', s.totalIndexNowSubmitted > 0 ? 'pass' : 'warn', s.totalIndexNowSubmitted + ' URLs submitted');
        if (s.lastSubmission) addResult('indexing', 'Last Submission', 'pass', new Date(s.lastSubmission).toLocaleString());
        if (s.latestSnapshot) {
          addResult('indexing', 'Indexed Pages', s.latestSnapshot.indexed > 0 ? 'pass' : 'warn',
            s.latestSnapshot.indexed + '/' + s.latestSnapshot.totalPages + ' indexed (' + s.latestSnapshot.notIndexed + ' not indexed)');
        }
        if (s.timeline && s.timeline.length > 0) {
          addResult('indexing', 'Recent Activity', 'pass', s.timeline.length + ' submissions in timeline');
        }
        addJsonBlock('indexing', j);
      } else if (idxResp.status === 401 || idxResp.status === 403) {
        addResult('indexing', 'Indexing API', 'warn', 'Needs admin auth');
      } else {
        addResult('indexing', 'Indexing API', 'warn', 'HTTP ' + idxResp.status);
        if (idxResp.json) addJsonBlock('indexing', idxResp.json);
      }

      // Also query the google-indexing cron healthcheck for per-URL status details
      log('  Querying google-indexing cron for per-URL status...');
      try {
        const idxCronResp = await testFetch('/api/cron/google-indexing?healthcheck=true', { headers: cronHeaders });
        if (idxCronResp.ok && idxCronResp.json) {
          const ic = idxCronResp.json;
          addResult('indexing', 'IndexNow Key', ic.hasIndexNowKey ? 'pass' : 'fail',
            ic.hasIndexNowKey ? 'INDEXNOW_KEY is configured' : 'INDEXNOW_KEY not set — Bing/Yandex submissions disabled',
            !ic.hasIndexNowKey ? 'Set <code>INDEXNOW_KEY</code> in Vercel env vars. Also create <code>public/{key}.txt</code> with the key as content for ownership verification.' : undefined);
          addResult('indexing', 'GSC Credentials', ic.hasGscCredentials ? 'pass' : 'warn',
            ic.hasGscCredentials ? 'Google Search Console credentials configured' : 'GSC credentials missing — sitemap pings disabled',
            !ic.hasGscCredentials ? 'Set <code>GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL</code> and <code>GOOGLE_SEARCH_CONSOLE_PRIVATE_KEY</code> in Vercel env vars. The service account needs "Full" access to the GSC property.' : undefined);
        }
      } catch (e2) { log('  (google-indexing healthcheck skipped: ' + e2.message + ')'); }

    } catch (e) { log('  ERROR in section 16: ' + e.message); addResult('indexing', 'Indexing', 'fail', 'JS Error: ' + e.message); }

    // ── 17. GA4 Server-Side Data (real proof of analytics) ──
    log('  Testing GA4 server-side data...');
    addSection('ga4server', '17. GA4 Server-Side Data API');
    try {
      const gaResp = await testFetch('/api/admin/analytics/ga4', { headers: cronHeaders });
      if (gaResp.ok && gaResp.json) {
        const j = gaResp.json;
        if (j.configured !== undefined) addResult('ga4server', 'GA4 Configured', j.configured ? 'pass' : 'fail', j.configured ? 'Credentials present' : 'Missing GA4_PROPERTY_ID or service account',
          !j.configured ? 'GA4 server-side data requires 3 env vars in Vercel: (1) <code>GA4_PROPERTY_ID</code> — your numeric GA4 property ID, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> — service account email, (3) <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> — the full private key (with <code>\\n</code> newlines). The service account must have "Viewer" role on the GA4 property in Google Analytics Admin → Property Access Management.' : undefined);
        if (j.metrics) {
          const m = j.metrics;
          addResult('ga4server', 'Sessions (30d)', m.sessions > 0 ? 'pass' : 'warn', m.sessions.toLocaleString());
          addResult('ga4server', 'Page Views (30d)', m.pageViews > 0 ? 'pass' : 'warn', m.pageViews.toLocaleString());
          addResult('ga4server', 'Users (30d)', m.totalUsers > 0 ? 'pass' : 'warn', m.totalUsers.toLocaleString());
          addResult('ga4server', 'Bounce Rate', m.bounceRate < 70 ? 'pass' : 'warn', m.bounceRate.toFixed(1) + '%');
          addResult('ga4server', 'Engagement Rate', m.engagementRate > 30 ? 'pass' : 'warn', m.engagementRate.toFixed(1) + '%');
        }
        if (j.topPages && j.topPages.length > 0) {
          addResult('ga4server', 'Top Pages', 'pass', j.topPages.slice(0,5).map(p => p.path + ' (' + p.pageViews + ' views)').join(', '));
        }
        if (j.topSources && j.topSources.length > 0) {
          addResult('ga4server', 'Top Traffic Sources', 'pass', j.topSources.slice(0,5).map(s => s.source + ' (' + s.sessions + ')').join(', '));
        }
        addJsonBlock('ga4server', j);
      } else if (gaResp.status === 401 || gaResp.status === 403) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Needs admin auth',
          'This endpoint uses admin auth. Log into the admin dashboard first, then revisit. The GA4 data is still fetched by crons even if this admin endpoint needs auth.');
      } else if (gaResp.status === 404) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Endpoint not found — /api/admin/analytics/ga4 may not exist',
          'No dedicated GA4 admin endpoint exists. GA4 data is fetched internally by the SEO agent and analytics cron via <code>lib/seo/ga4-data-api.ts</code>. You can verify it works by checking the SEO Agent report (section 12) which includes <code>trafficAnalysis</code> data from GA4.');
      } else {
        addResult('ga4server', 'GA4 Data API', 'warn', 'HTTP ' + gaResp.status,
          gaResp.status === 500 ? 'GA4 API call failed. Check: (1) <code>GA4_PROPERTY_ID</code> is correct, (2) service account private key doesn\'t have encoding issues (\\n vs actual newlines), (3) service account email has GA4 property access.' :
          'Check Vercel Function Logs.');
        if (gaResp.json) addJsonBlock('ga4server', gaResp.json);
      }
    } catch (e) { log('  ERROR in section 17: ' + e.message); addResult('ga4server', 'GA4 Data API', 'fail', 'JS Error: ' + e.message); }

    // ── 18. Blog Content Audit (proof content generator works) ──
    log('  Testing blog content audit...');
    addSection('blogaudit', '18. Blog Content Audit — Auto-Generated Proof');
    try {
      const blogResp = await testFetch('/api/blog?limit=20&sort=created_at:desc');
      if (blogResp.ok && blogResp.json) {
        const posts = blogResp.json.posts || blogResp.json.data || (Array.isArray(blogResp.json) ? blogResp.json : []);
        const total = blogResp.json.total || blogResp.json.count || posts.length;
        addResult('blogaudit', 'Total Posts', total > 0 ? 'pass' : 'warn', total + ' published blog posts in database',
          total === 0 ? 'Zero published blog posts in the database. Click <strong>"Seed Static Articles → DB"</strong> to import the 23 static articles into the database. Once seeded, the SEO agent, indexing pipeline, and CMS will manage them automatically.' : undefined);

        let autoGen = 0, withMeta = 0, withAr = 0, withSchema = 0, recentCount = 0;
        const now = Date.now();
        const sevenDays = 7 * 24 * 60 * 60 * 1000;

        for (const p of posts) {
          if (p.tags && Array.isArray(p.tags) && p.tags.includes('auto-generated')) autoGen++;
          if (p.meta_title_en || p.meta_description_en) withMeta++;
          if (p.content_ar && p.content_ar !== null && !p.content_ar.startsWith('[0 ')) withAr++;
          if (p.authority_links_json || p.keywords_json) withSchema++;
          if (p.created_at && (now - new Date(p.created_at).getTime()) < sevenDays) recentCount++;
        }

        addResult('blogaudit', 'Auto-Generated Posts', autoGen > 0 ? 'pass' : 'warn',
          autoGen + '/' + posts.length + ' posts have "auto-generated" tag (content pipeline proof)',
          autoGen === 0 ? 'No posts have the <code>auto-generated</code> tag. This means the daily content generation cron (<code>/api/cron/daily-content-generate</code>) hasn\'t successfully created any posts. Check: (1) Vercel cron schedule is active, (2) AI API key is set, (3) The cron healthcheck (section 7) shows a recent successful run.' : undefined);
        addResult('blogaudit', 'Posts with Meta Tags', withMeta > 0 ? 'pass' : 'warn',
          withMeta + '/' + posts.length + ' have SEO meta titles/descriptions');
        addResult('blogaudit', 'Arabic Content', withAr > 0 ? 'pass' : 'warn',
          withAr + '/' + posts.length + ' have Arabic content (>100 chars)');
        addResult('blogaudit', 'SEO Data (keywords/schema)', withSchema > 0 ? 'pass' : 'warn',
          withSchema + '/' + posts.length + ' have keywords or schema data');
        addResult('blogaudit', 'Recent Posts (7d)', recentCount > 0 ? 'pass' : 'warn',
          recentCount + ' posts created in last 7 days',
          recentCount === 0 ? 'No posts in the last 7 days. The daily content cron should create 2 posts per site per day (10 total). Check Vercel → Settings → Crons to confirm <code>/api/cron/daily-content-generate</code> is scheduled at 5:00 UTC daily and has recent executions.' : undefined);

        // Show latest 3 posts
        for (const p of posts.slice(0, 3)) {
          const age = p.created_at ? Math.round((now - new Date(p.created_at).getTime()) / 3600000) + 'h ago' : '?';
          const tags = (p.tags || []).join(', ');
          addResult('blogaudit', 'Post: ' + (p.title_en || p.slug || '').substring(0, 50), 'pass',
            age + ' | seo:' + (p.seo_score || '?') + ' | tags: ' + tags.substring(0, 80));
        }
        addJsonBlock('blogaudit', { total, sample: posts.slice(0, 3) });
      } else if (blogResp.status === 404) {
        addResult('blogaudit', 'Blog API', 'warn', 'No public /api/blog endpoint — test via admin');
      } else {
        addResult('blogaudit', 'Blog API', 'warn', 'HTTP ' + blogResp.status);
      }
    } catch (e) { log('  ERROR in section 18: ' + e.message); addResult('blogaudit', 'Blog Audit', 'fail', 'JS Error: ' + e.message); }

    // ── 19. SEO Reports (proof orchestrator writes to DB) ──
    log('  Testing SEO reports...');
    addSection('seoreports', '19. SEO Reports — Orchestrator Output Proof');
    try {
      const reportResp = await testFetch('/api/admin/seo/reports?limit=5', { headers: cronHeaders });
      if (reportResp.ok && reportResp.json) {
        const reports = reportResp.json.reports || reportResp.json.data || (Array.isArray(reportResp.json) ? reportResp.json : []);
        addResult('seoreports', 'SEO Reports in DB', reports.length > 0 ? 'pass' : 'warn', reports.length + ' reports found');
        for (const r of reports.slice(0, 5)) {
          const age = r.generatedAt ? Math.round((Date.now() - new Date(r.generatedAt).getTime()) / 3600000) + 'h ago' : '?';
          const score = r.data?.health_score || r.data?.healthScore || '?';
          addResult('seoreports', r.reportType + ' report', 'pass',
            age + ' | score: ' + score + ' | site: ' + (r.site_id || 'all'));
        }
        if (reports.length > 0) addJsonBlock('seoreports', reports[0]);
      } else if (reportResp.status === 401 || reportResp.status === 403) {
        addResult('seoreports', 'SEO Reports', 'warn', 'Needs admin auth — try admin session');
      } else if (reportResp.status === 404) {
        addResult('seoreports', 'SEO Reports', 'warn', 'No /api/admin/seo/reports endpoint');
      } else {
        addResult('seoreports', 'SEO Reports', 'warn', 'HTTP ' + reportResp.status);
        if (reportResp.json) addJsonBlock('seoreports', reportResp.json);
      }
    } catch (e) { log('  ERROR in section 19: ' + e.message); addResult('seoreports', 'SEO Reports', 'fail', 'JS Error: ' + e.message); }

    // ── 20. Yalla London Site Health Check ──
    log('  Testing Yalla London site health...');
    addSection('multisite', '20. Yalla London Site Health');
    try {
      const siteResp = await testFetch('/api/admin/sites/yalla-london/health', { headers: cronHeaders });
      if (siteResp.ok && siteResp.json) {
        const j = siteResp.json;
        const score = j.healthScore ?? '?';
        const statusCls = j.status === 'healthy' ? 'pass' : j.status === 'degraded' ? 'warn' : j.status === 'down' ? 'fail' : 'warn';
        addResult('multisite', j.siteName || 'Yalla London', statusCls,
          j.status + ' — score: ' + score + '/100' +
          (j.indexing ? ' | indexed: ' + j.indexing.indexed + '/' + j.indexing.totalUrls : '') +
          (j.content ? ' | posts: ' + j.content.publishedPosts + '/' + j.content.totalPosts : '') +
          ' (' + (j.domain || 'yalla-london.com') + ')');
        if (j.crons7d) {
          addResult('multisite', 'Crons (7d)', j.crons7d.failed === 0 ? 'pass' : 'warn',
            j.crons7d.completed + ' completed, ' + j.crons7d.failed + ' failed, ' + j.crons7d.timedOut + ' timed out');
        }
        if (j.seo) {
          addResult('multisite', 'SEO Indexing', j.seo.indexed_pages > 0 ? 'pass' : 'warn',
            j.seo.indexed_pages + '/' + j.seo.total_pages + ' pages indexed (' + (j.seo.indexing_rate || 0) + '%)');
        }
        addJsonBlock('multisite', j);
      } else if (siteResp.status === 401 || siteResp.status === 403) {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP ' + siteResp.status + ' — authentication required',
          'The <code>/api/admin/sites/yalla-london/health</code> endpoint requires admin session or CRON_SECRET. Verify your CRON_SECRET is correct. This endpoint uses <code>requireAdminOrCron</code>.');
      } else if (siteResp.status === 404) {
        const errBody = siteResp.json?.error || '';
        addResult('multisite', 'Yalla London', 'warn', 'HTTP 404 — ' + (errBody || 'site health endpoint not found'),
          errBody.includes('Unknown site')
            ? 'The site ID "yalla-london" was not found in config. Check <code>config/sites.ts</code>.'
            : 'The <code>/api/admin/sites/yalla-london/health</code> route returned 404. Ensure the route is deployed. It exists at <code>app/api/admin/sites/[siteId]/health/route.ts</code>.');
      } else {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP ' + siteResp.status + ' — ' + (siteResp.json?.error || siteResp.errorDetail || ''));
      }
    } catch (e) { log('  ERROR in section 20: ' + e.message); addResult('multisite', 'Site Health', 'fail', 'JS Error: ' + e.message); }

    // ── 21. Content & Indexing Deep Audit ──
    log('  Running content & indexing deep audit...');
    addSection('contentaudit', '21. Content & Indexing Deep Audit');
    try {
      const auditResp = await testFetch('/api/admin/content-audit', { headers: cronHeaders });
      if (auditResp.ok && auditResp.json) {
        const j = auditResp.json;
        const s = j.summary;

        // Global totals
        addResult('contentaudit', 'Total Articles/Posts', s.totalPosts > 0 ? 'pass' : 'warn',
          s.totalPosts + ' total (' + s.totalPublished + ' published, ' + s.totalDrafts + ' drafts)',
          s.totalPosts === 0 ? 'No blog posts yet. The content generation cron needs to run successfully to create posts. This is normal for a fresh deployment.' : undefined);

        addResult('contentaudit', 'URLs Tracked for Indexing', s.totalTrackedUrls > 0 ? 'pass' : 'warn',
          s.totalTrackedUrls + ' URLs in URLIndexingStatus table',
          s.totalTrackedUrls === 0 ? 'No URLs being tracked for indexing. The SEO agent should create URL tracking entries when it runs. Check section 12 (SEO Agent) for status.' : undefined);

        addResult('contentaudit', 'Indexing Requested (Submitted)', s.totalSubmittedPending > 0 || s.totalIndexed > 0 ? 'pass' : 'warn',
          (s.totalSubmittedPending + s.totalIndexed) + ' URLs submitted to Google/IndexNow (' + s.totalSubmittedPending + ' pending, ' + s.totalIndexed + ' confirmed indexed)',
          s.totalSubmittedPending === 0 && s.totalIndexed === 0 ? 'No URLs have been submitted for indexing. Check that <code>INDEXNOW_KEY</code> is set and the SEO agent is running. The agent submits URLs via IndexNow and Google Indexing API.' : undefined);

        addResult('contentaudit', 'Confirmed Indexed in Google', s.totalIndexed > 0 ? 'pass' : 'warn',
          s.totalIndexed + ' pages confirmed indexed (' + s.indexRate + '% index rate)',
          s.totalIndexed === 0 ? 'Zero pages confirmed indexed. This is normal for new sites — Google can take days to weeks to index pages. The SEO agent checks via GSC URL Inspection API. Ensure GSC service account credentials are configured.' : undefined);

        addResult('contentaudit', 'Indexing Errors', s.totalErrors === 0 ? 'pass' : 'warn',
          s.totalErrors + ' URLs with indexing errors',
          s.totalErrors > 0 ? 'Some URLs failed indexing submission. See the error details below for specific causes.' : undefined);

        addResult('contentaudit', 'Untracked Published Posts', s.totalUntracked === 0 ? 'pass' : 'warn',
          s.totalUntracked + ' published posts not yet tracked in URLIndexingStatus',
          s.totalUntracked > 0 ? 'These published posts have no entry in the URL tracking table. The SEO agent should pick them up on its next run and create tracking entries + submit them for indexing.' : undefined);

        // Per-site breakdown
        if (j.perSite && j.perSite.length > 0) {
          for (const site of j.perSite) {
            const ix = site.indexing || {};
            addResult('contentaudit', site.siteName + ' (' + site.domain + ')',
              ix.indexed > 0 ? 'pass' : site.published > 0 ? 'warn' : 'warn',
              site.published + ' published, ' + site.drafts + ' drafts | indexed: ' + ix.indexed + '/' + ix.total + ' (' + ix.indexRate + '%) | submitted: ' + ix.submitted + ' | errors: ' + ix.error);

            // Show not-indexed reasons for this site
            if (site.notIndexedReasons && site.notIndexedReasons.length > 0) {
              for (const r of site.notIndexedReasons) {
                addResult('contentaudit', '  ↳ Not indexed: ' + r.reason, 'warn', r.count + ' URLs',
                  r.reason.includes('not indexed') ? 'Google crawled the page but decided not to index it. Common reasons: thin content (<300 words), duplicate content, low-quality content, or noindex tag. Check Google Search Console → Pages for details.' :
                  r.reason.includes('discovered') ? 'Google knows the page exists but hasn\'t crawled it yet. This is normal for new pages — give it time or request indexing via GSC.' :
                  r.reason.includes('redirect') ? 'Page redirects to another URL. Check for broken redirect chains.' :
                  r.reason.includes('blocked') ? 'Page is blocked by robots.txt or a noindex meta tag. Check the page\'s robots directives.' :
                  'GSC coverage state: ' + r.reason + '. Check Google Search Console → Pages → this specific status for detailed information.');
              }
            }
          }
        }

        // Stuck pages (submitted >7 days ago, still not indexed)
        if (j.stuckPages && j.stuckPages.length > 0) {
          addResult('contentaudit', 'Stuck Pages (submitted >7d ago, not indexed)', 'warn', j.stuckPages.length + ' pages');
          for (const p of j.stuckPages.slice(0, 10)) {
            const daysAgo = Math.round((Date.now() - new Date(p.submittedAt).getTime()) / 86400000);
            addResult('contentaudit', '  ↳ ' + (p.slug || p.url).substring(0, 50), 'warn',
              daysAgo + 'd since submission | attempts: ' + p.attempts + ' | GSC: ' + (p.coverageState || 'unknown'),
              'This page was submitted ' + daysAgo + ' days ago but still isn\'t indexed. Try: (1) Resubmit via GSC "Request Indexing", (2) Check if page returns 200 status, (3) Ensure content is high-quality (>1200 words), (4) Add internal links to this page from indexed pages.');
          }
        } else if (j.stuckPages) {
          addResult('contentaudit', 'Stuck Pages', 'pass', 'None — all submitted pages are progressing');
        }

        // URL errors
        if (j.urlErrors && j.urlErrors.length > 0) {
          addResult('contentaudit', 'URLs with Errors', 'warn', j.urlErrors.length + ' errors');
          for (const e of j.urlErrors.slice(0, 10)) {
            addResult('contentaudit', '  ↳ ' + (e.slug || e.url).substring(0, 50), 'fail',
              'Error: ' + (e.error || 'unknown').substring(0, 100) + ' | attempts: ' + e.attempts,
              'This URL failed indexing. Error: <code>' + escapeHtml((e.error || '').substring(0, 150)) + '</code>. Check if the URL returns HTTP 200 and has proper content.');
          }
        } else if (j.urlErrors) {
          addResult('contentaudit', 'URL Errors', 'pass', 'None');
        }

        // Untracked posts
        if (j.untrackedPosts && j.untrackedPosts.length > 0) {
          addResult('contentaudit', 'Untracked Published Posts', 'warn', j.untrackedPosts.length + ' posts not in URL tracker');
          for (const p of j.untrackedPosts.slice(0, 5)) {
            addResult('contentaudit', '  ↳ ' + (p.title || p.slug).substring(0, 50), 'warn',
              p.siteId + ' — created: ' + new Date(p.createdAt).toLocaleDateString(),
              'This published post has no URL tracking entry. The SEO agent will pick it up on its next run. To force immediate tracking, trigger the SEO agent manually.');
          }
        }

        addJsonBlock('contentaudit', { summary: j.summary, perSite: j.perSite });
      } else if (auditResp.status === 401 || auditResp.status === 403) {
        addResult('contentaudit', 'Content Audit', 'fail', 'HTTP ' + auditResp.status + ' — auth failed');
      } else {
        addResult('contentaudit', 'Content Audit', 'warn', 'HTTP ' + auditResp.status + ' — ' + (auditResp.json?.error || auditResp.text?.substring(0,150) || ''));
        if (auditResp.json) addJsonBlock('contentaudit', auditResp.json);
      }
    } catch (e) { log('  ERROR in section 21: ' + e.message); addResult('contentaudit', 'Content Audit', 'fail', 'JS Error: ' + e.message); }

    // ── 21b. X/Twitter API & Social Integration ──
    log('  Testing X/Twitter API & social integration...');
    addSection('xapi', '21b. X/Twitter API & Social Integration');
    try {
      // Check social cron healthcheck for pending posts
      const socialResp = await testFetch('/api/cron/social?healthcheck=true', { headers: cronHeaders });
      if (socialResp.ok && socialResp.json) {
        const sj = socialResp.json;
        addResult('xapi', 'Social Cron Status', sj.status === 'healthy' ? 'pass' : 'warn',
          sj.status === 'healthy' ? 'Social cron endpoint operational' : 'Social cron unhealthy',
          sj.status !== 'healthy' ? 'The social cron endpoint is not responding correctly. Check that the <code>ScheduledContent</code> and <code>ModelProvider</code> tables exist in the database.' : undefined);
        addResult('xapi', 'Pending Social Posts', sj.pendingPosts > 0 ? 'pass' : 'warn',
          sj.pendingPosts + ' posts queued for social publishing',
          sj.pendingPosts === 0 ? 'No pending social posts. Posts are created by the content pipeline and scheduled for social distribution. Currently the social cron marks posts as "published" in the DB but does NOT actually post to Twitter/X/Instagram/LinkedIn.' : undefined);
      } else if (socialResp.status === 401) {
        addResult('xapi', 'Social Cron', 'warn', 'HTTP 401 — CRON_SECRET mismatch');
      } else if (socialResp.status === 503) {
        addResult('xapi', 'Social Cron', 'warn', 'Unhealthy — DB tables may be missing',
          'The social cron returned 503 (unhealthy). This usually means the <code>ScheduledContent</code> or <code>ModelProvider</code> tables do not exist. Run the DB migration (section 22) or click "Fix Missing Tables & Columns" to resolve.');
      } else {
        addResult('xapi', 'Social Cron', 'warn', 'HTTP ' + socialResp.status);
        if (socialResp.json) addJsonBlock('xapi', socialResp.json);
      }

      // Check for Twitter/X API env vars via a lightweight probe
      // We test by looking at what the social cron returns when it actually tries to process
      const socialRunResp = await testFetch('/api/cron/social', { headers: cronHeaders, method: 'POST' });
      if (socialRunResp.ok && socialRunResp.json) {
        const sr = socialRunResp.json;
        addResult('xapi', 'Social Run Result', 'pass', sr.postsProcessed + ' posts processed: ' + sr.published + ' published, ' + sr.failed + ' failed');

        // Check individual post results for API connection details
        if (sr.results && sr.results.length > 0) {
          for (const r of sr.results.slice(0, 5)) {
            const isMock = r.note && r.note.includes('Mock');
            const noAccount = r.reason && r.reason.includes('not connected');
            addResult('xapi', '  ↳ ' + (r.platform || 'unknown') + ' #' + (r.postId || '?').toString().substring(0, 8),
              r.status === 'published' ? (isMock ? 'warn' : 'pass') : 'fail',
              r.status + (isMock ? ' (MOCK — not actually posted)' : '') + (noAccount ? ' — ' + r.reason : ''),
              isMock ? 'This post was marked as published in the DB but was NOT actually sent to ' + r.platform + '. To enable real posting, integrate the Twitter/X API by setting <code>TWITTER_API_KEY</code>, <code>TWITTER_API_SECRET</code>, <code>TWITTER_ACCESS_TOKEN</code>, and <code>TWITTER_ACCESS_TOKEN_SECRET</code> env vars, then implement the API call in <code>app/api/cron/social/route.ts</code>.' :
              noAccount ? 'No <code>ModelProvider</code> record found for platform "' + r.platform + '". Create one in the admin dashboard or seed one with <code>provider_type: "social"</code> and the encrypted API key.' : undefined);
          }
        } else {
          addResult('xapi', 'Social Queue', 'warn', 'No posts in queue to process — social pipeline is idle',
            'No posts were due for social publishing. The content pipeline creates <code>ScheduledContent</code> records with <code>platform: "twitter"</code> (or other platforms). These are processed by the social cron when their <code>scheduled_time</code> arrives.');
        }

        addJsonBlock('xapi', sr);
      } else if (socialRunResp.status === 401) {
        addResult('xapi', 'Social Run', 'warn', 'HTTP 401 — check CRON_SECRET');
      } else {
        addResult('xapi', 'Social Run', 'warn', 'HTTP ' + socialRunResp.status + ' — ' + (socialRunResp.json?.error || ''));
        if (socialRunResp.json) addJsonBlock('xapi', socialRunResp.json);
      }

      // Summary of what's needed for real X/Twitter integration
      addResult('xapi', 'Integration Status', 'warn', 'Social posting is currently MOCK — real API integration required',
        'To enable real Twitter/X posting:<br>' +
        '1. Set env vars: <code>TWITTER_API_KEY</code>, <code>TWITTER_API_SECRET</code>, <code>TWITTER_ACCESS_TOKEN</code>, <code>TWITTER_ACCESS_TOKEN_SECRET</code><br>' +
        '2. Create a <code>ModelProvider</code> record with <code>provider_type: "social"</code>, <code>name: "twitter"</code><br>' +
        '3. Implement the Twitter API v2 call in <code>app/api/cron/social/route.ts</code> (replace the MOCK section)<br>' +
        '4. Similarly for Instagram (Meta Graph API), LinkedIn (LinkedIn API), etc.');
    } catch (e) { log('  ERROR in section 21b: ' + e.message); addResult('xapi', 'X/Twitter API', 'fail', 'JS Error: ' + e.message); }

    // ── 23. Yacht Platform — Admin APIs ──
    log('Testing Yacht Platform admin APIs...');
    addSection('yachts-admin', '23. Yacht Platform — Admin APIs (Auth Required)');
    try {
      // GET /api/admin/yachts — Admin fleet list
      log('  Testing admin fleet list...');
      const fleetResp = await testFetch('/api/admin/yachts', { headers: cronHeaders });
      if (fleetResp.ok && fleetResp.json) {
        const j = fleetResp.json;
        const count = j.total ?? j.yachts?.length ?? j.length ?? '?';
        addResult('yachts-admin', 'Fleet Inventory (Admin)', 'pass', 'Connected — ' + count + ' yacht(s) in fleet');
        if (j.yachts && j.yachts.length > 0) {
          addJsonBlock('yachts-admin', { sampleYacht: { name: j.yachts[0].name, type: j.yachts[0].type, status: j.yachts[0].status, builder: j.yachts[0].builder } });
        }
      } else if (fleetResp.status === 401 || fleetResp.status === 403) {
        addResult('yachts-admin', 'Fleet Inventory (Admin)', 'warn', 'HTTP ' + fleetResp.status + ' — Auth rejected. Admin endpoint may require session auth instead of CRON_SECRET',
          'The <code>/api/admin/yachts</code> endpoint uses <code>withAdminAuth</code> which may require a browser session cookie rather than a Bearer token. Try accessing this route from the admin dashboard.');
      } else if (fleetResp.status === 404) {
        addResult('yachts-admin', 'Fleet Inventory (Admin)', 'warn', 'HTTP 404 — endpoint not deployed yet',
          'The <code>/api/admin/yachts</code> route is not deployed. Ensure <code>app/api/admin/yachts/route.ts</code> exists.');
      } else {
        addResult('yachts-admin', 'Fleet Inventory (Admin)', fleetResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + fleetResp.status + ' — ' + (fleetResp.errorDetail || ''),
          fleetResp.status === 500 ? 'The <code>Yacht</code> table may not exist. Run DB migration to create yacht tables.' : '');
      }

      // GET /api/admin/yachts/inquiries — Admin inquiries
      log('  Testing admin inquiries...');
      const inqResp = await testFetch('/api/admin/yachts/inquiries', { headers: cronHeaders });
      if (inqResp.ok && inqResp.json) {
        const j = inqResp.json;
        const count = j.total ?? j.inquiries?.length ?? j.length ?? '?';
        const newCount = j.inquiries ? j.inquiries.filter(i => i.status === 'NEW').length : (j.newCount ?? '?');
        addResult('yachts-admin', 'Charter Inquiries (Admin)', 'pass', 'Connected — ' + count + ' inquiry/ies (' + newCount + ' NEW)');
        if (j.inquiries && j.inquiries.length > 0) {
          addJsonBlock('yachts-admin', { recentInquiry: { ref: j.inquiries[0].referenceNumber, status: j.inquiries[0].status, destination: j.inquiries[0].destination, createdAt: j.inquiries[0].createdAt } });
        }
      } else if (inqResp.status === 401 || inqResp.status === 403) {
        addResult('yachts-admin', 'Charter Inquiries (Admin)', 'warn', 'HTTP ' + inqResp.status + ' — Auth rejected (may require session auth)',
          'The <code>/api/admin/yachts/inquiries</code> endpoint may require a browser session. Test from the admin dashboard.');
      } else if (inqResp.status === 404) {
        addResult('yachts-admin', 'Charter Inquiries (Admin)', 'warn', 'HTTP 404 — endpoint not deployed yet',
          'The <code>/api/admin/yachts/inquiries</code> route is not deployed.');
      } else {
        addResult('yachts-admin', 'Charter Inquiries (Admin)', inqResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + inqResp.status + ' — ' + (inqResp.errorDetail || ''),
          inqResp.status === 500 ? 'The <code>CharterInquiry</code> table may not exist. Run <code>npx prisma db push</code> to create it.' : '');
      }

      // GET /api/admin/yachts/analytics — Admin analytics
      log('  Testing admin yacht analytics...');
      const analyticsResp = await testFetch('/api/admin/yachts/analytics', { headers: cronHeaders });
      if (analyticsResp.ok && analyticsResp.json) {
        const j = analyticsResp.json;
        addResult('yachts-admin', 'Yacht Analytics (Admin)', 'pass', 'Connected — analytics data available');
        addJsonBlock('yachts-admin', {
          fleetSize: j.fleetSize ?? j.totalYachts ?? '?',
          totalInquiries: j.totalInquiries ?? '?',
          conversionRate: j.conversionRate ?? '?',
          topDestination: j.topDestination ?? j.topDestinations?.[0]?.name ?? '?',
        });
      } else if (analyticsResp.status === 401 || analyticsResp.status === 403) {
        addResult('yachts-admin', 'Yacht Analytics (Admin)', 'warn', 'HTTP ' + analyticsResp.status + ' — Auth rejected (may require session auth)',
          'The <code>/api/admin/yachts/analytics</code> endpoint may require a browser session. Test from the admin dashboard.');
      } else if (analyticsResp.status === 404) {
        addResult('yachts-admin', 'Yacht Analytics (Admin)', 'warn', 'HTTP 404 — endpoint not deployed yet',
          'The <code>/api/admin/yachts/analytics</code> route is not deployed.');
      } else {
        addResult('yachts-admin', 'Yacht Analytics (Admin)', analyticsResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + analyticsResp.status + ' — ' + (analyticsResp.errorDetail || ''),
          analyticsResp.status === 500 ? 'Yacht analytics tables may not exist. Ensure all yacht-related Prisma models are migrated.' : '');
      }
      // GET /api/admin/yachts/destinations — Admin destinations
      log('  Testing admin yacht destinations...');
      const destResp = await testFetch('/api/admin/yachts/destinations', { headers: cronHeaders });
      if (destResp.ok && destResp.json) {
        addResult('yachts-admin', 'Yacht Destinations (Admin)', 'pass', 'Connected — ' + (destResp.json.destinations?.length ?? 0) + ' destinations');
      } else if (destResp.status === 401 || destResp.status === 403) {
        addResult('yachts-admin', 'Yacht Destinations (Admin)', 'warn', 'HTTP ' + destResp.status + ' — Auth rejected (may require session auth)');
      } else {
        addResult('yachts-admin', 'Yacht Destinations (Admin)', destResp.status === 404 ? 'warn' : 'fail', 'HTTP ' + destResp.status);
      }

      // GET /api/admin/yachts/itineraries — Admin itineraries
      log('  Testing admin yacht itineraries...');
      const itinResp = await testFetch('/api/admin/yachts/itineraries', { headers: cronHeaders });
      if (itinResp.ok && itinResp.json) {
        addResult('yachts-admin', 'Yacht Itineraries (Admin)', 'pass', 'Connected — ' + (itinResp.json.itineraries?.length ?? 0) + ' itineraries');
      } else if (itinResp.status === 401 || itinResp.status === 403) {
        addResult('yachts-admin', 'Yacht Itineraries (Admin)', 'warn', 'HTTP ' + itinResp.status + ' — Auth rejected (may require session auth)');
      } else {
        addResult('yachts-admin', 'Yacht Itineraries (Admin)', itinResp.status === 404 ? 'warn' : 'fail', 'HTTP ' + itinResp.status);
      }

      // GET /api/admin/yachts/brokers — Admin brokers
      log('  Testing admin yacht brokers...');
      const brokerResp = await testFetch('/api/admin/yachts/brokers', { headers: cronHeaders });
      if (brokerResp.ok && brokerResp.json) {
        addResult('yachts-admin', 'Yacht Brokers (Admin)', 'pass', 'Connected — ' + (brokerResp.json.brokers?.length ?? 0) + ' broker partners');
      } else if (brokerResp.status === 401 || brokerResp.status === 403) {
        addResult('yachts-admin', 'Yacht Brokers (Admin)', 'warn', 'HTTP ' + brokerResp.status + ' — Auth rejected (may require session auth)');
      } else {
        addResult('yachts-admin', 'Yacht Brokers (Admin)', brokerResp.status === 404 ? 'warn' : 'fail', 'HTTP ' + brokerResp.status);
      }

    } catch (e) { log('  ERROR in section 23: ' + e.message); addResult('yachts-admin', 'Yacht Admin APIs', 'fail', 'JS Error: ' + e.message); }

  } else if (testMode === 'full' && !cronSecret) {
    addSection('pipeline', '7. Content Generation Pipeline');
    addResult('pipeline', 'Pipeline Tests', 'fail', 'Enter CRON_SECRET above and re-run');
  }

  // ── Auto-scan for missing tables (after all tests) ──
  if (testMode === 'full' && cronSecret) {
    // Wait 3s to let DB connection pool drain from previous tests
    log('  Waiting 3s for connection pool to drain...');
    await new Promise(r => setTimeout(r, 3000));
    log('  Auto-scanning database schema for missing tables/columns...');
    addSection('dbcheck', '22. Database Schema Health');
    try {
      const dbScanResp = await testFetch('/api/admin/db-migrate', {
        headers: { 'Authorization': 'Bearer ' + cronSecret },
      });
      if (dbScanResp.ok && dbScanResp.json) {
        const j = dbScanResp.json;
        const s = j.summary || {};
        if (s.needsMigration) {
          addResult('dbcheck', 'Schema Sync', 'fail',
            s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
            'Database schema is out of sync with the Prisma models. This causes runtime errors like <strong>P2022 (column does not exist)</strong> or <strong>P2021 (table does not exist)</strong>. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page to resolve, or run <code>npx prisma db push</code> on the server.');
          if (j.missingTables) {
            for (const t of j.missingTables) {
              addResult('dbcheck', 'Missing: ' + t.table, 'fail', 'Model: ' + t.model + ' — table needs to be created',
                'Table <code>' + escapeHtml(t.table) + '</code> does not exist. Any API route that queries <code>prisma.' + escapeHtml(t.model.charAt(0).toLowerCase() + t.model.slice(1)) + '</code> will throw <strong>P2021: The table does not exist in the current database</strong>. Routes affected include any cron job, page, or API route that imports this model.');
            }
          }
          if (j.missingColumns) {
            for (const c of j.missingColumns) {
              addResult('dbcheck', 'Missing: ' + c.table + '.' + c.column, 'fail', c.type + ' — column needs to be added',
                'Column <code>' + escapeHtml(c.column) + '</code> is missing from table <code>' + escapeHtml(c.table) + '</code>. Any query that filters by, selects, or sorts on this column will throw <strong>P2022: The column does not exist</strong>. This is the root cause of many HTTP 500 errors in cron jobs and API routes.');
            }
          }
        } else {
          addResult('dbcheck', 'Schema Sync', 'pass', 'All ' + j.existingTables.length + ' tables and checked columns are in sync');
        }
        addJsonBlock('dbcheck', { summary: s, existingTables: j.existingTables?.length, missingTables: j.missingTables, missingColumns: j.missingColumns });
      } else if (dbScanResp.status === 401) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Auth failed — CRON_SECRET may be wrong');
      } else if (dbScanResp.status === 404) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Endpoint /api/admin/db-migrate not deployed yet — redeploy to enable',
          'The database schema scan endpoint has not been deployed yet. Push the latest code and redeploy on Vercel to enable this feature.');
      } else {
        addResult('dbcheck', 'Schema Scan', 'warn', 'HTTP ' + dbScanResp.status + ' — ' + (dbScanResp.json?.error || dbScanResp.text?.substring(0, 150) || ''));
        if (dbScanResp.json) addJsonBlock('dbcheck', dbScanResp.json);
      }
    } catch (e) { log('  ERROR in section 22: ' + e.message); addResult('dbcheck', 'Schema Scan', 'warn', 'JS Error: ' + e.message); }
  }

  // ── Final Status ──
  log('All tests complete: ' + pass + ' passed, ' + warn + ' warnings, ' + fail + ' failed');

  const banner = document.getElementById('statusBanner');
  if (fail === 0 && warn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL SYSTEMS GO</div>';
  } else if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-warn">OPERATIONAL — ' + warn + ' warning(s)</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' ISSUE(S) NEED ATTENTION</div>';
  }

  // ── Generate Copiable JSON Test Result ──
  renderJsonResult();

  document.getElementById('runBtn').disabled = false;
  document.getElementById('runBtn').textContent = 'Run All Tests Again';
}

function renderJsonResult() {
  // Categorize results by section
  const sections = {};
  for (const r of allResults) {
    const sec = r.section || 'uncategorized';
    if (!sections[sec]) sections[sec] = [];
    sections[sec].push({ name: r.name, status: r.status, detail: r.detail });
  }

  // Identify failures and warnings for recommendations
  const failures = allResults.filter(r => r.status === 'fail');
  const warnings = allResults.filter(r => r.status === 'warn');
  const recommendations = [];

  // Auto-generate recommendations from failures
  for (const f of failures.slice(0, 10)) {
    if (f.detail && f.detail.includes('CRON_SECRET')) recommendations.push('Verify CRON_SECRET is set correctly in Vercel env vars');
    else if (f.detail && f.detail.includes('GA4')) recommendations.push('Configure GA4_PROPERTY_ID + GOOGLE_ANALYTICS_CLIENT_EMAIL + PRIVATE_KEY');
    else if (f.detail && f.detail.includes('GSC')) recommendations.push('Configure GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL + PRIVATE_KEY');
    else if (f.detail && f.detail.includes('INDEXNOW')) recommendations.push('Set INDEXNOW_KEY env var for Bing/Yandex indexing');
    else if (f.detail && f.detail.includes('table')) recommendations.push('Run DB migration to create missing tables — click "Fix Missing Tables & Columns"');
    else if (f.name) recommendations.push('Fix: ' + f.name + ' — ' + (f.detail || '').substring(0, 80));
  }
  // Deduplicate
  const uniqueRecs = [...new Set(recommendations)];

  // Env vars detected status
  const envVars = {
    confirmed: [],
    missing: [],
    unknown: [],
  };
  for (const r of allResults) {
    const d = (r.detail || '').toLowerCase();
    if (d.includes('configured') || d.includes('credentials present') || d.includes('key is configured')) {
      if (d.includes('ga4') || r.name?.includes('GA4')) envVars.confirmed.push('GA4_PROPERTY_ID');
      if (d.includes('gsc') || d.includes('search console')) envVars.confirmed.push('GSC_CREDENTIALS');
      if (d.includes('indexnow')) envVars.confirmed.push('INDEXNOW_KEY');
    }
    if (d.includes('not configured') || d.includes('not set') || d.includes('missing')) {
      if (d.includes('ga4')) envVars.missing.push('GA4_PROPERTY_ID');
      if (d.includes('gsc') || d.includes('search console')) envVars.missing.push('GSC_CREDENTIALS');
      if (d.includes('indexnow')) envVars.missing.push('INDEXNOW_KEY');
    }
  }
  envVars.confirmed = [...new Set(envVars.confirmed)];
  envVars.missing = [...new Set(envVars.missing)];

  const jsonResult = {
    _generator: 'Yalla London System Validator',
    timestamp: new Date().toISOString(),
    mode: testMode,
    platform: {
      url: window.location.origin,
      activeSites: ['yalla-london'],
      allSites: ['yalla-london', 'arabaldives', 'french-riviera', 'istanbul', 'thailand', 'zenitha-yachts-med'],
    },
    summary: {
      passed: pass,
      warnings: warn,
      failed: fail,
      total: pass + warn + fail,
      healthScore: pass + warn + fail > 0 ? Math.round((pass / (pass + warn + fail)) * 100) : 0,
      verdict: fail === 0 && warn === 0 ? 'ALL_SYSTEMS_GO' : fail === 0 ? 'OPERATIONAL_WITH_WARNINGS' : 'NEEDS_ATTENTION',
    },
    environmentVariables: envVars,
    recommendations: uniqueRecs,
    cronSchedule: {
      '03:00': 'Analytics sync (GA4 + GSC)',
      '04:00 Mon': 'Weekly topic research',
      '05:00': 'Daily content generation',
      '05:00 Sun': 'SEO orchestrator (weekly)',
      '06:00': 'Trends monitor + SEO orchestrator (daily)',
      '07:00': 'SEO agent run 1',
      '07:30': 'SEO cron (daily)',
      '08:00 Sun': 'SEO cron (weekly)',
      '09:00': 'Scheduled publish (morning)',
      '10:00': 'Google indexing (IndexNow + GSC)',
      '13:00': 'SEO agent run 2',
      '16:00': 'Scheduled publish (afternoon)',
      '20:00': 'SEO agent run 3',
    },
    knownIssues: [
      'Social posting is MOCK — marks as published in DB but does NOT post to Twitter/X/Instagram/LinkedIn',
      'Trends monitor may timeout (55s client-side) if external APIs are slow',
      'GA4 Data API requires service account with Viewer role on the GA4 property',
      'PgBouncer session mode limits concurrent DB connections to 1 per function',
    ],
    sectionResults: sections,
    results: allResults,
  };
  const jsonStr = JSON.stringify(jsonResult, null, 2);

  // Remove any existing JSON export section
  const existing = document.getElementById('section-jsonexport');
  if (existing) existing.remove();

  const html = `<div class="section" id="section-jsonexport">
    <h2>Test Results — Comprehensive JSON Export</h2>
    <p style="color:#888;font-size:0.8rem;margin-bottom:8px;">Full test report with environment status, recommendations, cron schedule, and detailed results. Click Copy to share.</p>
    <div style="display:flex;gap:8px;margin-bottom:12px;">
      <button onclick="copyJsonResult(event)" style="margin:0;padding:8px 20px;font-size:0.85rem;background:#7c3aed;">Copy JSON to Clipboard</button>
      <span style="color:#888;font-size:0.8rem;line-height:36px;">${jsonStr.length.toLocaleString()} chars | ${allResults.length} test results | Health: ${pass + warn + fail > 0 ? Math.round((pass / (pass + warn + fail)) * 100) : 0}%</span>
    </div>
    <textarea id="jsonResultArea" readonly style="width:100%;height:400px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.75rem;resize:vertical;">${escapeHtml(jsonStr)}</textarea>
  </div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function copyJsonResult(evt) {
  const area = document.getElementById('jsonResultArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = evt?.target || document.querySelector('[onclick*="copyJsonResult"]');
    if (btn) {
      btn.textContent = 'Copied!';
      btn.style.background = '#16a34a';
      setTimeout(() => { btn.textContent = 'Copy JSON to Clipboard'; btn.style.background = '#7c3aed'; }, 2000);
    }
  }).catch(() => {
    document.execCommand('copy');
  });
}

// ═══════════════════════════════════════════════════════════════════════════
// MASTER SEO AUDIT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

let auditRunning = false;

// Keep both secret inputs in sync
function syncSecrets(value) {
  const main = document.getElementById('cronSecret');
  const audit = document.getElementById('auditSecret');
  if (main && main.value !== value) main.value = value;
  if (audit && audit.value !== value) audit.value = value;
}

function getAuditSecret() {
  return document.getElementById('auditSecret')?.value
    || document.getElementById('cronSecret')?.value
    || '';
}

function getAuthHeaders() {
  const secret = getAuditSecret();
  const headers = { 'Content-Type': 'application/json' };
  if (secret) headers['Authorization'] = 'Bearer ' + secret;
  return headers;
}

function setAuditStatus(msg) {
  document.getElementById('auditStatus').textContent = msg;
}

function setAuditProgress(pct) {
  const bar = document.getElementById('auditProgressBar');
  const wrap = document.getElementById('auditProgress');
  wrap.style.display = 'block';
  bar.style.width = pct + '%';
  bar.style.background = pct >= 100 ? '#4ade80' : '#d97706';
}

async function runMasterAudit(mode) {
  if (auditRunning) return;

  const secret = getAuditSecret();
  if (!secret) {
    document.getElementById('auditResults').innerHTML = `
      <div class="section" style="border-color:#92400e;">
        <h2 style="color:#fbbf24;">Authentication Required</h2>
        <p style="color:#fde68a;font-size:0.85rem;">Enter your <code>CRON_SECRET</code> in the field above to authenticate.</p>
        <div class="diag diag-warn" style="margin-top:8px;">
          <strong>Where to find it:</strong> Vercel Dashboard → Settings → Environment Variables → <code>CRON_SECRET</code>.
          This is the same secret used for cron jobs.
        </div>
      </div>`;
    document.getElementById('auditSecret').focus();
    return;
  }

  auditRunning = true;

  const quickBtn = document.getElementById('auditQuickBtn');
  const fullBtn = document.getElementById('auditFullBtn');
  quickBtn.disabled = true;
  fullBtn.disabled = true;
  quickBtn.textContent = mode === 'quick' ? 'Running...' : 'Run Quick Audit (static pages)';
  fullBtn.textContent = mode === 'full' ? 'Running...' : 'Run Full Audit (all pages)';

  document.getElementById('auditResults').innerHTML = '';
  setAuditStatus('Crawling site and running 8 validators...');
  setAuditProgress(15);

  try {
    const body = { mode };
    setAuditProgress(30);

    const resp = await fetch('/api/admin/master-audit', {
      method: 'POST',
      headers: getAuthHeaders(),
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(125000),  // 125s — server has 120s maxDuration
    });

    setAuditProgress(90);

    if (!resp.ok) {
      const errBody = await resp.text().catch(() => '');
      let errMsg = 'HTTP ' + resp.status;
      try { const j = JSON.parse(errBody); errMsg = j.error || errMsg; } catch {}
      if (resp.status === 401) errMsg = 'Authentication failed — check your CRON_SECRET';
      if (resp.status === 403) errMsg = 'Access denied — CRON_SECRET is incorrect';
      if (resp.status === 404) errMsg = 'Endpoint not found — redeploy to enable /api/admin/master-audit';
      throw new Error(errMsg);
    }

    const data = await resp.json();
    setAuditProgress(100);
    setAuditStatus('');
    renderAuditResults(data);
  } catch (e) {
    setAuditProgress(0);
    document.getElementById('auditProgress').style.display = 'none';
    setAuditStatus('');
    document.getElementById('auditResults').innerHTML = `
      <div class="section" style="border-color:#991b1b;">
        <h2 style="color:#f87171;">Audit Failed</h2>
        <p style="color:#fca5a5;font-size:0.85rem;">${escapeHtml(e.message)}</p>
        <div class="diag" style="margin-top:8px;">
          <strong>Troubleshooting:</strong> Check that the deployment includes <code>/api/admin/master-audit</code>.
          If using CRON_SECRET auth, switch to "Full Pipeline Test" tab first and enter it there.
          The audit needs ~20-50 seconds — Vercel Pro 60s limit applies.
        </div>
      </div>`;
  } finally {
    auditRunning = false;
    quickBtn.disabled = false;
    fullBtn.disabled = false;
    quickBtn.textContent = 'Run Quick Audit (static pages)';
    fullBtn.textContent = 'Run Full Audit (all pages)';
  }
}

function renderAuditResults(data) {
  const el = document.getElementById('auditResults');
  let html = '';

  // ── Summary cards ──
  html += '<div class="audit-cards">';
  html += auditCard('Pages Scanned', data.totalUrls, 'blue');
  html += auditCard('Pages OK', data.crawledOk, 'green');
  html += auditCard('Total Issues', data.issues?.total ?? 0, (data.issues?.total > 0) ? 'amber' : 'green');
  html += auditCard('P0 Critical', data.issues?.p0 ?? 0, (data.issues?.p0 > 0) ? 'red' : 'green');
  html += auditCard('P1 Warning', data.issues?.p1 ?? 0, (data.issues?.p1 > 0) ? 'amber' : 'green');
  html += auditCard('P2 Info', data.issues?.p2 ?? 0, 'gray');
  html += auditCard('Duration', ((data.durationMs || 0) / 1000).toFixed(1) + 's', 'gray');
  html += auditCard('Verdict', data.allPassed ? 'ALL PASS' : 'FAILED', data.allPassed ? 'green' : 'red');
  html += '</div>';

  // ── Partial warning ──
  if (data.partial) {
    html += `<div class="section" style="border-color:#92400e;margin-bottom:12px;">
      <p style="color:#fbbf24;font-size:0.85rem;">⚠ Partial results — ${escapeHtml(data.reason || 'budget exhausted')}. Run the CLI <code>npm run audit:master</code> for complete results.</p>
    </div>`;
  }

  // ── Website Parameters ──
  if (data.siteParameters) {
    const sp = data.siteParameters;
    html += '<div class="section"><h2>Website Parameters</h2>';
    html += '<div class="audit-cards">';
    html += auditCard('Static Pages', sp.totalStaticPages, 'blue');
    html += auditCard('Published Articles', sp.totalPublishedArticles, 'blue');
    html += auditCard('Total Audited', sp.totalUrlsAudited, 'blue');
    html += auditCard('Avg Response', sp.averageResponseMs + 'ms', sp.averageResponseMs < 500 ? 'green' : sp.averageResponseMs < 1500 ? 'amber' : 'red');
    html += auditCard('Slowest Page', sp.slowestPageMs + 'ms', sp.slowestPageMs < 1000 ? 'green' : 'amber');
    html += auditCard('Avg Words', sp.averageWordCount, sp.averageWordCount >= 1000 ? 'green' : 'amber');
    html += auditCard('Has Canonical', sp.pagesWithCanonical + '/' + sp.totalUrlsAudited, 'blue');
    html += auditCard('Has Schema', sp.pagesWithJsonLd + '/' + sp.totalUrlsAudited, 'blue');
    html += '</div>';
    if (sp.slowestPageUrl) {
      html += `<p style="color:#666;font-size:0.75rem;margin-top:6px;">Slowest: ${escapeHtml(sp.slowestPageUrl)}</p>`;
    }
    html += '</div>';
  }

  // ── Google Search Console ──
  if (data.gsc) {
    html += '<div class="section"><h2>Google Search Console (30 days)</h2>';
    if (!data.gsc.configured) {
      html += `<p style="color:#fbbf24;font-size:0.85rem;">GSC not configured — ${escapeHtml(data.gsc.reason || 'missing credentials')}. Set GSC_CLIENT_EMAIL + GSC_PRIVATE_KEY + GSC_SITE_URL in Vercel.</p>`;
    } else {
      html += '<div class="audit-cards">';
      html += auditCard('Clicks', data.gsc.totalClicks?.toLocaleString() ?? 0, data.gsc.totalClicks > 0 ? 'green' : 'amber');
      html += auditCard('Impressions', data.gsc.totalImpressions?.toLocaleString() ?? 0, 'blue');
      html += auditCard('CTR', (data.gsc.averageCtr ?? 0) + '%', data.gsc.averageCtr >= 3 ? 'green' : 'amber');
      html += auditCard('Avg Position', data.gsc.averagePosition ?? 'N/A', data.gsc.averagePosition <= 20 ? 'green' : 'amber');
      html += '</div>';
      if (data.gsc.topKeywords && data.gsc.topKeywords.length > 0) {
        html += '<h3 style="color:#c9d1d9;font-size:0.85rem;margin:12px 0 6px;">Top Keywords</h3>';
        html += '<div style="overflow-x:auto;"><table style="width:100%;font-size:0.75rem;border-collapse:collapse;">';
        html += '<tr style="color:#8b949e;border-bottom:1px solid #30363d;"><th style="text-align:left;padding:4px;">Keyword</th><th>Clicks</th><th>Impressions</th><th>CTR</th><th>Pos</th></tr>';
        for (const kw of data.gsc.topKeywords) {
          html += `<tr style="border-bottom:1px solid #21262d;"><td style="padding:4px;color:#c9d1d9;">${escapeHtml(kw.keyword)}</td><td style="text-align:center;">${kw.clicks}</td><td style="text-align:center;">${kw.impressions}</td><td style="text-align:center;">${kw.ctr}%</td><td style="text-align:center;">${kw.position}</td></tr>`;
        }
        html += '</table></div>';
      }
      if (data.gsc.topPages && data.gsc.topPages.length > 0) {
        html += '<h3 style="color:#c9d1d9;font-size:0.85rem;margin:12px 0 6px;">Top Pages by Clicks</h3>';
        html += '<div style="overflow-x:auto;"><table style="width:100%;font-size:0.75rem;border-collapse:collapse;">';
        html += '<tr style="color:#8b949e;border-bottom:1px solid #30363d;"><th style="text-align:left;padding:4px;">Page</th><th>Clicks</th><th>Impressions</th><th>CTR</th><th>Pos</th></tr>';
        for (const pg of data.gsc.topPages) {
          const shortUrl = pg.page.length > 60 ? '...' + pg.page.slice(-57) : pg.page;
          html += `<tr style="border-bottom:1px solid #21262d;"><td style="padding:4px;color:#c9d1d9;max-width:250px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(pg.page)}">${escapeHtml(shortUrl)}</td><td style="text-align:center;">${pg.clicks}</td><td style="text-align:center;">${pg.impressions}</td><td style="text-align:center;">${pg.ctr}%</td><td style="text-align:center;">${pg.position}</td></tr>`;
        }
        html += '</table></div>';
      }
    }
    html += '</div>';
  }

  // ── Google Analytics ──
  if (data.ga4) {
    html += '<div class="section"><h2>Google Analytics (30 days)</h2>';
    if (!data.ga4.configured) {
      html += `<p style="color:#fbbf24;font-size:0.85rem;">GA4 not configured — ${escapeHtml(data.ga4.reason || 'missing credentials')}. Set GA4_PROPERTY_ID + service account credentials in Vercel.</p>`;
    } else {
      const m = data.ga4.metrics || {};
      html += '<div class="audit-cards">';
      html += auditCard('Sessions', (m.sessions || 0).toLocaleString(), m.sessions > 0 ? 'green' : 'amber');
      html += auditCard('Users', (m.totalUsers || 0).toLocaleString(), 'blue');
      html += auditCard('Page Views', (m.pageViews || 0).toLocaleString(), 'blue');
      html += auditCard('Bounce Rate', (m.bounceRate || 0) + '%', m.bounceRate < 50 ? 'green' : 'amber');
      html += auditCard('Engagement', (m.engagementRate || 0) + '%', m.engagementRate > 50 ? 'green' : 'amber');
      html += auditCard('Avg Duration', (m.avgSessionDuration || 0) + 's', 'gray');
      html += '</div>';
      if (data.ga4.topPages && data.ga4.topPages.length > 0) {
        html += '<h3 style="color:#c9d1d9;font-size:0.85rem;margin:12px 0 6px;">Top Pages by Views</h3>';
        for (const pg of data.ga4.topPages.slice(0, 5)) {
          html += `<div style="display:flex;justify-content:space-between;font-size:0.78rem;padding:3px 0;border-bottom:1px solid #21262d;"><span style="color:#c9d1d9;">${escapeHtml(pg.path)}</span><span style="color:#8b949e;">${pg.pageViews} views</span></div>`;
        }
      }
    }
    html += '</div>';
  }

  // ── Indexing Status ──
  if (data.indexing) {
    const ix = data.indexing;
    html += '<div class="section"><h2>Indexing Status</h2>';
    html += '<div class="audit-cards">';
    html += auditCard('Total Tracked', ix.totalTracked, 'blue');
    html += auditCard('Indexed', ix.indexed, ix.indexed > 0 ? 'green' : 'amber');
    html += auditCard('Submitted', ix.submitted, 'blue');
    html += auditCard('Discovered', ix.discovered, 'gray');
    html += auditCard('Not Indexed', ix.notIndexed, ix.notIndexed > 0 ? 'red' : 'green');
    html += auditCard('Errors', ix.errors, ix.errors > 0 ? 'red' : 'green');
    html += '</div>';
    if (ix.submissionMethods) {
      html += `<div style="font-size:0.78rem;color:#8b949e;margin-top:6px;">Submissions: IndexNow <b>${ix.submissionMethods.indexNow}</b> | Google API <b>${ix.submissionMethods.googleApi}</b> | Sitemap <b>${ix.submissionMethods.sitemap}</b></div>`;
    }
    // Cleanup button for non-www duplicates
    html += '<div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;">';
    html += '<button onclick="previewIndexingCleanup()" id="previewCleanupBtn" style="margin:0;padding:8px 16px;font-size:0.82rem;background:#7c3aed;">Preview Cleanup</button>';
    html += '<button onclick="applyIndexingCleanup()" id="applyCleanupBtn" style="margin:0;padding:8px 16px;font-size:0.82rem;background:#dc2626;">Clean Up Duplicates</button>';
    html += '</div>';
    html += '<div id="cleanupStatus" style="font-size:0.8rem;margin-top:6px;"></div>';
    html += '</div>';
  }

  // ── SEO Metrics (DB) ──
  if (data.seoMetrics) {
    const sm = data.seoMetrics;
    html += '<div class="section"><h2>SEO Content Metrics</h2>';
    html += '<div class="audit-cards">';
    html += auditCard('Published', sm.totalPublished, 'green');
    html += auditCard('Drafts', sm.totalDrafts, 'gray');
    html += auditCard('Avg SEO Score', sm.averageSeoScore, sm.averageSeoScore >= 70 ? 'green' : sm.averageSeoScore >= 50 ? 'amber' : 'red');
    html += auditCard('Below 70', sm.articlesBelow70, sm.articlesBelow70 > 0 ? 'amber' : 'green');
    html += auditCard('Above 80', sm.articlesAbove80, 'green');
    html += '</div>';
    if (sm.pageTypeBreakdown && Object.keys(sm.pageTypeBreakdown).length > 0) {
      html += '<div style="font-size:0.78rem;color:#8b949e;margin-top:6px;">Content types: ';
      html += Object.entries(sm.pageTypeBreakdown).map(function(e) { return e[0] + ' <b>' + e[1] + '</b>'; }).join(' | ');
      html += '</div>';
    }
    html += '</div>';
  }

  // ── Blog Metadata Issues (from DB — all articles, not just crawled) ──
  if (data.blogMetadataIssues && data.blogMetadataIssues.length > 0) {
    html += '<div class="section"><h2>Blog Metadata Issues (from DB — ' + data.blogMetadataIssues.length + ' articles)</h2>';
    html += '<div style="font-size:0.75rem;color:#8b949e;margin-bottom:8px;">These are title/description length issues detected from the database across all ' + (data.siteParameters?.totalPublishedArticles || '?') + ' published articles — no crawling needed.</div>';
    // Auto-fix buttons
    html += '<div style="display:flex;gap:10px;margin-bottom:12px;flex-wrap:wrap;">';
    html += '<button onclick="previewMetadataFixes()" id="previewFixBtn" style="margin:0;padding:8px 16px;font-size:0.82rem;background:#7c3aed;">Preview Fixes</button>';
    html += '<button onclick="applyMetadataFixes()" id="applyFixBtn" style="margin:0;padding:8px 16px;font-size:0.82rem;background:#dc2626;">Auto-Fix All (' + data.blogMetadataIssues.length + ' articles)</button>';
    html += '</div>';
    html += '<div id="metadataFixStatus" style="font-size:0.8rem;margin-bottom:8px;"></div>';
    html += '<div id="metadataFixPreview"></div>';
    for (const item of data.blogMetadataIssues) {
      html += '<div style="margin-bottom:6px;padding:6px 8px;background:#21262d;border-radius:4px;border-left:3px solid #fbbf24;">';
      html += '<div style="font-size:0.78rem;color:#c9d1d9;font-weight:600;">/blog/' + escapeHtml(item.slug) + '</div>';
      for (const iss of item.issues) {
        html += '<div style="font-size:0.72rem;color:#fbbf24;margin-top:2px;">⚠ ' + escapeHtml(iss) + '</div>';
      }
      html += '</div>';
    }
    html += '</div>';
  }

  // ── Issues by Category ──
  if (data.issuesByCategory && Object.keys(data.issuesByCategory).length > 0) {
    html += '<div class="section"><h2>Issues by Category</h2>';
    for (const [cat, info] of Object.entries(data.issuesByCategory)) {
      const ci = info;
      const barWidth = Math.min(100, Math.round((ci.count / Math.max(data.issues?.total || 1, 1)) * 100));
      const barColor = ci.p0 > 0 ? '#f87171' : ci.p1 > 0 ? '#fbbf24' : '#8b949e';
      html += `<div style="margin-bottom:8px;">
        <div style="display:flex;justify-content:space-between;font-size:0.8rem;margin-bottom:3px;">
          <span style="color:#c9d1d9;text-transform:capitalize;font-weight:600;">${escapeHtml(cat)}</span>
          <span style="color:#8b949e;">${ci.count} issues (P0:${ci.p0} P1:${ci.p1} P2:${ci.p2})</span>
        </div>
        <div style="background:#21262d;border-radius:4px;height:6px;overflow:hidden;">
          <div style="background:${barColor};width:${barWidth}%;height:100%;border-radius:4px;"></div>
        </div>`;
      if (ci.samples && ci.samples.length > 0) {
        html += '<div style="font-size:0.7rem;color:#6e7681;margin-top:2px;">' + ci.samples.map(function(s) { return escapeHtml(s); }).join(' | ') + '</div>';
      }
      html += '</div>';
    }
    html += '</div>';
  }

  // ── Hard Gates ──
  if (data.hardGates && data.hardGates.length > 0) {
    html += '<div class="section"><h2>Hard Gates' +
      (data.allPassed
        ? ' <span style="color:#4ade80;font-size:0.85rem;">— All Passed</span>'
        : ' <span style="color:#f87171;font-size:0.85rem;">— Failed</span>') +
      '</h2>';
    for (const gate of data.hardGates) {
      html += `<div class="gate-row">
        <div class="gate-icon">${gate.passed ? '✓' : '✗'}</div>
        <div class="gate-info">
          <div class="gate-name">${escapeHtml(gate.description || gate.name)}</div>
          <div class="gate-detail">${escapeHtml(gate.category)} — ${gate.totalCount} issue(s), ${gate.p0Count} critical</div>
        </div>
        <div class="gate-badge ${gate.passed ? 'gate-pass' : 'gate-fail'}">${gate.passed ? 'PASS' : 'FAIL'}</div>
      </div>`;
    }
    html += '</div>';
  }

  // ── Soft Gates / Warnings ──
  if (data.softGates && data.softGates.length > 0) {
    html += '<div class="section"><h2>Warnings</h2>';
    for (const gate of data.softGates) {
      html += `<div class="gate-row">
        <div class="gate-icon" style="color:#fbbf24;">⚠</div>
        <div class="gate-info">
          <div class="gate-name" style="color:#fbbf24;">${escapeHtml(gate.description)}</div>
        </div>
      </div>`;
    }
    html += '</div>';
  }

  // ── Per-Page Results ──
  if (data.pages && data.pages.length > 0) {
    html += '<div class="section"><h2>Page-by-Page Results (' + data.pages.length + ' pages)</h2>';
    for (let i = 0; i < data.pages.length; i++) {
      const pg = data.pages[i];
      const icon = pg.status === 200 ? '<span style="color:#4ade80;">✓</span>'
        : pg.status === 0 ? '<span style="color:#f87171;">✗</span>'
        : '<span style="color:#fbbf24;">⚠</span>';
      const issuesBadge = pg.issueCount > 0
        ? `<span class="severity-badge severity-p0">${pg.issueCount}</span>` : '';
      const sourceBadge = pg.source === 'blog'
        ? '<span style="font-size:0.65rem;background:#1f6feb;color:#fff;padding:1px 5px;border-radius:3px;">blog</span>' : '';
      const seoScoreBadge = pg.seoScore != null
        ? `<span style="font-size:0.65rem;background:${pg.seoScore >= 70 ? '#16a34a' : pg.seoScore >= 50 ? '#d97706' : '#dc2626'};color:#fff;padding:1px 5px;border-radius:3px;">SEO:${pg.seoScore}</span>` : '';

      html += `<div class="page-row" onclick="toggleAuditPage(${i})">
        <div class="page-header">
          ${icon}
          <span style="font-size:0.85rem;flex:1;">${escapeHtml(pg.url)}</span>
          ${sourceBadge} ${seoScoreBadge} ${issuesBadge}
          <span style="font-size:0.7rem;" class="${pg.hasCanonical ? 'signal-ok' : 'signal-bad'}">Canon</span>
          <span style="font-size:0.7rem;" class="${pg.hasJsonLd ? 'signal-ok' : 'signal-bad'}">Schema</span>
          <span style="font-size:0.7rem;" class="${pg.hasHreflang ? 'signal-ok' : 'signal-bad'}">Hreflang</span>
          <span style="color:#555;font-size:0.8rem;">▸</span>
        </div>
        <div class="page-detail" id="audit-page-${i}">
          <div class="page-signals">
            <span>HTTP: <b>${pg.status || 'N/A'}</b></span>
            <span>Response: <b>${pg.responseMs || 0}ms</b></span>
            <span>Words: <b>${pg.wordCount}</b></span>
            <span>Canonical: <b class="${pg.hasCanonical ? 'signal-ok' : 'signal-bad'}">${pg.hasCanonical ? 'Yes' : 'No'}</b></span>
            <span>JSON-LD: <b class="${pg.hasJsonLd ? 'signal-ok' : 'signal-bad'}">${pg.hasJsonLd ? 'Yes' : 'No'}</b></span>
            <span>Hreflang: <b class="${pg.hasHreflang ? 'signal-ok' : 'signal-bad'}">${pg.hasHreflang ? 'Yes' : 'No'}</b></span>
            ${pg.seoScore != null ? '<span>SEO Score: <b>' + pg.seoScore + '</b></span>' : ''}
            ${pg.indexingStatus ? '<span>Indexed: <b>' + escapeHtml(pg.indexingStatus) + '</b></span>' : ''}
          </div>
          <div style="font-size:0.75rem;color:#8b949e;margin-top:4px;">Title: ${pg.title ? escapeHtml(pg.title) : '<i>Missing</i>'}</div>
          ${pg.issues && pg.issues.length > 0 ? renderPageIssues(pg.issues) : '<div style="color:#4ade80;font-size:0.8rem;margin-top:6px;">No issues found</div>'}
        </div>
      </div>`;
    }
    html += '</div>';
  }

  // ── Raw JSON (collapsed) ──
  html += `<div class="section">
    <h2 style="cursor:pointer;" onclick="document.getElementById('auditRawJson').style.display=document.getElementById('auditRawJson').style.display==='none'?'block':'none'">
      Raw JSON Response ▸
    </h2>
    <div id="auditRawJson" style="display:none;">
      <div style="display:flex;gap:8px;margin-bottom:8px;">
        <button onclick="copyAuditJson(event)" style="margin:0;padding:6px 16px;font-size:0.8rem;background:#7c3aed;">Copy JSON</button>
      </div>
      <textarea id="auditJsonArea" readonly style="width:100%;height:300px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.7rem;resize:vertical;">${escapeHtml(JSON.stringify(data, null, 2))}</textarea>
    </div>
  </div>`;

  el.innerHTML = html;
}

function auditCard(label, value, color) {
  return `<div class="audit-card audit-card-${color}">
    <div class="audit-card-val">${value}</div>
    <div class="audit-card-label">${escapeHtml(label)}</div>
  </div>`;
}

function renderPageIssues(issues) {
  let html = '<div style="margin-top:6px;">';
  for (const issue of issues) {
    const sev = (issue.severity || 'P2').toUpperCase();
    const cls = sev === 'P0' ? 'severity-p0' : sev === 'P1' ? 'severity-p1' : 'severity-p2';
    html += `<div style="display:flex;gap:6px;align-items:start;margin-bottom:3px;font-size:0.78rem;">
      <span class="severity-badge ${cls}">${sev}</span>
      <span style="color:#aaa;">${escapeHtml(issue.message || '')}</span>
    </div>`;
  }
  html += '</div>';
  return html;
}

function toggleAuditPage(idx) {
  const el = document.getElementById('audit-page-' + idx);
  if (el) el.classList.toggle('open');
}

function copyAuditJson(evt) {
  const area = document.getElementById('auditJsonArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = evt?.target;
    if (btn) {
      btn.textContent = 'Copied!';
      btn.style.background = '#16a34a';
      setTimeout(() => { btn.textContent = 'Copy JSON'; btn.style.background = '#7c3aed'; }, 2000);
    }
  }).catch(() => { document.execCommand('copy'); });
}

// ─── Indexing Duplicate Cleanup ──────────────────────────────────────
async function previewIndexingCleanup() {
  const btn = document.getElementById('previewCleanupBtn');
  const statusEl = document.getElementById('cleanupStatus');
  if (!btn || !statusEl) return;

  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  statusEl.innerHTML = '<span style="color:#fbbf24;">Scanning for non-www duplicate URLs...</span>';

  try {
    const resp = await fetch('/api/admin/cleanup-indexing', {
      headers: getAuthHeaders(),
      signal: AbortSignal.timeout(60000),
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const data = await resp.json();

    if (data.totalToFix === 0) {
      statusEl.innerHTML = '<span style="color:#4ade80;">No duplicates found — all URLs use correct www format.</span>';
    } else {
      let h = '<span style="color:#fbbf24;font-weight:600;">Found ' + data.nonWwwEntries + ' non-www entries (' + data.duplicatePairs + ' duplicates + ' + data.orphansToConvert + ' orphans to convert)</span>';
      h += '<div style="max-height:200px;overflow-y:auto;margin-top:6px;">';
      if (data.duplicates) {
        for (const d of data.duplicates) {
          h += '<div style="font-size:0.7rem;padding:2px 0;border-bottom:1px solid #21262d;color:#fca5a5;">Delete: ' + escapeHtml(d.nonWwwUrl.replace('https://', '')) + ' (www version exists)</div>';
        }
      }
      if (data.orphans) {
        for (const o of data.orphans) {
          h += '<div style="font-size:0.7rem;padding:2px 0;border-bottom:1px solid #21262d;color:#fde68a;">Convert: ' + escapeHtml(o.url.replace('https://', '')) + ' → www</div>';
        }
      }
      h += '</div>';
      statusEl.innerHTML = h;
    }
  } catch (e) {
    statusEl.innerHTML = '<span style="color:#f87171;">Preview failed: ' + escapeHtml(e.message) + '</span>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Preview Cleanup';
  }
}

async function applyIndexingCleanup() {
  const btn = document.getElementById('applyCleanupBtn');
  const statusEl = document.getElementById('cleanupStatus');
  if (!btn || !statusEl) return;

  if (!confirm('This will delete duplicate non-www URL entries and convert orphans to www format. Continue?')) return;

  btn.disabled = true;
  btn.textContent = 'Cleaning...';
  statusEl.innerHTML = '<span style="color:#fbbf24;">Cleaning up indexing database...</span>';

  try {
    const resp = await fetch('/api/admin/cleanup-indexing', {
      method: 'POST',
      headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
      signal: AbortSignal.timeout(120000),
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const data = await resp.json();

    statusEl.innerHTML = '<span style="color:#4ade80;font-weight:600;">' + escapeHtml(data.message) + '</span>' +
      '<div style="font-size:0.78rem;color:#fbbf24;margin-top:4px;">Re-run the audit to see updated indexing numbers. The verify-indexing cron will re-check converted URLs within 6 hours.</div>';
  } catch (e) {
    statusEl.innerHTML = '<span style="color:#f87171;">Cleanup failed: ' + escapeHtml(e.message) + '</span>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Clean Up Duplicates';
  }
}

// ─── Metadata Auto-Fix ──────────────────────────────────────────────
async function previewMetadataFixes() {
  const btn = document.getElementById('previewFixBtn');
  const statusEl = document.getElementById('metadataFixStatus');
  const previewEl = document.getElementById('metadataFixPreview');
  if (!btn || !statusEl || !previewEl) return;

  btn.disabled = true;
  btn.textContent = 'Loading preview...';
  statusEl.innerHTML = '<span style="color:#fbbf24;">Analyzing metadata issues...</span>';

  try {
    const resp = await fetch('/api/admin/fix-blog-metadata', {
      headers: getAuthHeaders(),
      signal: AbortSignal.timeout(30000),
    });

    if (!resp.ok) {
      const errBody = await resp.text().catch(() => '');
      let errMsg = 'HTTP ' + resp.status;
      try { const j = JSON.parse(errBody); errMsg = j.error || errMsg; } catch {}
      throw new Error(errMsg);
    }

    const data = await resp.json();
    statusEl.innerHTML = '<span style="color:#4ade80;">Preview ready: ' + data.totalFixes + ' fixes across ' + data.articlesWithIssues + ' articles</span>';

    if (data.fixes && data.fixes.length > 0) {
      let phtml = '<div style="max-height:300px;overflow-y:auto;margin-bottom:8px;">';
      for (const fix of data.fixes) {
        const fieldLabel = fix.field === 'meta_title_en' ? 'Title' : 'Description';
        phtml += '<div style="margin-bottom:6px;padding:6px 8px;background:#0d1117;border-radius:4px;border-left:3px solid #7c3aed;">';
        phtml += '<div style="font-size:0.75rem;color:#c9d1d9;font-weight:600;">/blog/' + escapeHtml(fix.slug) + ' — ' + fieldLabel + '</div>';
        phtml += '<div style="font-size:0.7rem;color:#f87171;margin-top:2px;">Before (' + fix.oldLength + ' chars): ' + escapeHtml(fix.oldPreview) + '</div>';
        phtml += '<div style="font-size:0.7rem;color:#4ade80;margin-top:1px;">After (' + fix.newLength + ' chars): ' + escapeHtml(fix.newPreview) + '</div>';
        phtml += '<div style="font-size:0.65rem;color:#8b949e;margin-top:1px;">' + escapeHtml(fix.reason) + '</div>';
        phtml += '</div>';
      }
      phtml += '</div>';
      previewEl.innerHTML = phtml;
    } else {
      previewEl.innerHTML = '<div style="color:#4ade80;font-size:0.82rem;padding:8px;">No fixes needed — all metadata is compliant!</div>';
    }
  } catch (e) {
    statusEl.innerHTML = '<span style="color:#f87171;">Preview failed: ' + escapeHtml(e.message) + '</span>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Preview Fixes';
  }
}

async function applyMetadataFixes() {
  const btn = document.getElementById('applyFixBtn');
  const statusEl = document.getElementById('metadataFixStatus');
  if (!btn || !statusEl) return;

  if (!confirm('This will auto-fix metadata (titles > 60 chars, descriptions outside 120-160 chars) on all flagged articles. Continue?')) {
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Fixing...';
  statusEl.innerHTML = '<span style="color:#fbbf24;">Applying metadata fixes to database...</span>';

  try {
    const resp = await fetch('/api/admin/fix-blog-metadata', {
      method: 'POST',
      headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
      signal: AbortSignal.timeout(60000),
    });

    if (!resp.ok) {
      const errBody = await resp.text().catch(() => '');
      let errMsg = 'HTTP ' + resp.status;
      try { const j = JSON.parse(errBody); errMsg = j.error || errMsg; } catch {}
      throw new Error(errMsg);
    }

    const data = await resp.json();

    if (data.fixesApplied === 0) {
      statusEl.innerHTML = '<span style="color:#4ade80;">No fixes needed — all metadata is already compliant!</span>';
    } else {
      let resultHtml = '<span style="color:#4ade80;font-weight:600;">' + escapeHtml(data.message) + '</span>';
      if (data.results && data.results.length > 0) {
        resultHtml += '<div style="max-height:200px;overflow-y:auto;margin-top:6px;">';
        for (const r of data.results) {
          const icon = r.status === 'ok' ? '<span style="color:#4ade80;">✓</span>' : '<span style="color:#f87171;">✗</span>';
          resultHtml += '<div style="font-size:0.75rem;padding:3px 0;border-bottom:1px solid #21262d;">' +
            icon + ' <b>/blog/' + escapeHtml(r.slug) + '</b> — ' + r.fixes.map(function(f) { return escapeHtml(f); }).join(', ') +
            (r.error ? ' <span style="color:#f87171;">(' + escapeHtml(r.error) + ')</span>' : '') + '</div>';
        }
        resultHtml += '</div>';
      }
      resultHtml += '<div style="margin-top:8px;font-size:0.78rem;color:#fbbf24;">Re-run the audit to verify the fixes.</div>';
      statusEl.innerHTML = resultHtml;
    }
  } catch (e) {
    statusEl.innerHTML = '<span style="color:#f87171;">Fix failed: ' + escapeHtml(e.message) + '</span>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Auto-Fix All';
  }
}

async function loadAuditHistory() {
  const histEl = document.getElementById('auditHistory');
  histEl.innerHTML = '<div class="section"><h2>Loading history...</h2></div>';

  try {
    const resp = await fetch('/api/admin/master-audit', {
      headers: getAuthHeaders(),
      signal: AbortSignal.timeout(15000),
    });
    if (!resp.ok) {
      if (resp.status === 401 || resp.status === 403) throw new Error('Authentication failed — enter your CRON_SECRET above');
      throw new Error('HTTP ' + resp.status);
    }
    const data = await resp.json();

    if (!data.history || data.history.length === 0) {
      histEl.innerHTML = '<div class="section"><h2>Audit History</h2><p style="color:#666;font-size:0.85rem;">No previous audit runs found.</p></div>';
      return;
    }

    let html = '<div class="section"><h2>Audit History (' + data.history.length + ' runs)</h2>';
    for (const entry of data.history) {
      const icon = entry.status === 'success' ? '<span style="color:#4ade80;">✓</span>'
        : entry.status === 'error' ? '<span style="color:#f87171;">✗</span>'
        : '<span style="color:#fbbf24;">⚠</span>';
      const statusCls = entry.status === 'success' ? 'gate-pass' : entry.status === 'error' ? 'gate-fail' : 'severity-p1';
      const dateStr = entry.startedAt ? new Date(entry.startedAt).toLocaleString('en-GB', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' }) : 'Unknown';
      html += `<div class="audit-history-row">
        ${icon}
        <span style="flex:1;">${dateStr}</span>
        <span style="color:#666;font-size:0.8rem;">${entry.itemsProcessed || 0} pages, ${((entry.durationMs || 0) / 1000).toFixed(1)}s</span>
        ${entry.errorMessage ? '<span style="color:#fbbf24;font-size:0.75rem;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + escapeHtml(entry.errorMessage) + '</span>' : ''}
        <span class="gate-badge ${statusCls}">${escapeHtml(entry.status)}</span>
      </div>`;
    }
    html += '</div>';
    histEl.innerHTML = html;
  } catch (e) {
    histEl.innerHTML = `<div class="section" style="border-color:#991b1b;">
      <h2 style="color:#f87171;">Failed to load history</h2>
      <p style="color:#fca5a5;font-size:0.85rem;">${escapeHtml(e.message)}</p>
    </div>`;
  }
}
</script>
</body>
</html>
