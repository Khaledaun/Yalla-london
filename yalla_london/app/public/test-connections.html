<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yalla London — Connection Validator</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 20px; }
  h1 { text-align: center; margin-bottom: 8px; font-size: 1.6rem; color: #fff; }
  .subtitle { text-align: center; color: #888; margin-bottom: 24px; font-size: 0.9rem; }
  .section { background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; }
  .section h2 { font-size: 1rem; color: #aaa; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
  .test-row { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #1a1a1a; }
  .test-row:last-child { border-bottom: none; }
  .test-name { flex: 1; font-size: 0.9rem; }
  .test-status { font-size: 0.85rem; font-weight: 600; min-width: 100px; text-align: right; }
  .pass { color: #4ade80; }
  .fail { color: #f87171; }
  .warn { color: #fbbf24; }
  .pending { color: #666; }
  .detail { color: #888; font-size: 0.8rem; margin-top: 2px; word-break: break-all; }
  .summary-bar { display: flex; gap: 24px; justify-content: center; padding: 16px; background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; margin-bottom: 16px; }
  .summary-item { text-align: center; }
  .summary-num { font-size: 2rem; font-weight: 700; }
  .summary-label { font-size: 0.75rem; color: #888; text-transform: uppercase; }
  .status-banner { text-align: center; padding: 16px; border-radius: 12px; font-size: 1.1rem; font-weight: 700; margin-top: 16px; }
  .status-ok { background: #052e16; border: 1px solid #166534; color: #4ade80; }
  .status-warn { background: #422006; border: 1px solid #92400e; color: #fbbf24; }
  .status-fail { background: #450a0a; border: 1px solid #991b1b; color: #f87171; }
  button { background: #2563eb; color: white; border: none; padding: 12px 32px; border-radius: 8px; font-size: 1rem; cursor: pointer; display: block; margin: 0 auto 20px; }
  button:hover { background: #1d4ed8; }
  button:disabled { background: #333; color: #666; cursor: not-allowed; }
  .cron-input { background: #1a1a1a; border: 1px solid #333; color: #e0e0e0; padding: 8px 12px; border-radius: 6px; width: 100%; margin-bottom: 12px; font-family: monospace; }
  .cron-input::placeholder { color: #555; }
  .log { background: #0a0a0a; border: 1px solid #222; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; max-height: 300px; overflow-y: auto; margin-top: 12px; white-space: pre-wrap; color: #888; }
  .json-block { background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 12px; font-family: monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; margin-top: 8px; white-space: pre-wrap; color: #7ee787; }
  .diag { background: #1a0000; border: 1px solid #4a1a1a; border-radius: 6px; padding: 8px 12px; margin-top: 6px; font-size: 0.78rem; color: #fca5a5; }
  .diag strong { color: #f87171; }
  .diag code { background: #2a1010; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.75rem; }
  .diag-warn { background: #1a1400; border-color: #4a3a1a; color: #fde68a; }
  .diag-warn strong { color: #fbbf24; }
  .diag-warn code { background: #2a2010; }
  .tab-bar { display: flex; gap: 8px; margin-bottom: 16px; justify-content: center; flex-wrap: wrap; }
  .tab-btn { background: #1a1a1a; border: 1px solid #333; color: #888; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
  .tab-btn.active { background: #2563eb; color: white; border-color: #2563eb; }
</style>
</head>
<body>

<h1>Yalla London — System Validator</h1>
<p class="subtitle">Full pipeline test: GA4, Assets, Pages, SEO, Crons, Database, AI, Content, Orchestrator, Indexing, Site Health, Schema Audit (22 sections) + One-Click DB Migration + Copiable JSON Export</p>

<div class="tab-bar">
  <button class="tab-btn active" onclick="switchMode('quick')">Quick Test</button>
  <button class="tab-btn" onclick="switchMode('full')">Full Pipeline Test (needs CRON_SECRET)</button>
</div>

<div class="section" id="cronSection" style="display:none">
  <h2>Authentication</h2>
  <input type="password" id="cronSecret" class="cron-input" placeholder="Enter your CRON_SECRET to test cron endpoints and content pipeline...">
</div>

<div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-bottom:20px;">
  <button id="runBtn" onclick="runAllTests()">Run All Tests</button>
  <button id="scanBtn" onclick="scanDatabase()" style="background:#7c3aed;">Scan Missing Tables/Columns</button>
  <button id="migrateBtn" onclick="migrateDatabase()" style="background:#dc2626;">Fix Missing Tables &amp; Columns</button>
  <button id="seedBtn" onclick="seedStaticContent()" style="background:#059669;">Seed Static Articles → DB</button>
  <button id="jobsBtn" onclick="runAllJobs()" style="background:#d97706;">Run All Cron Jobs</button>
</div>

<div class="summary-bar">
  <div class="summary-item"><div class="summary-num pass" id="passCount">-</div><div class="summary-label">Passed</div></div>
  <div class="summary-item"><div class="summary-num warn" id="warnCount">-</div><div class="summary-label">Warnings</div></div>
  <div class="summary-item"><div class="summary-num fail" id="failCount">-</div><div class="summary-label">Failed</div></div>
</div>

<div id="results"></div>
<div id="statusBanner"></div>

<div class="section" style="margin-top:16px">
  <h2>Live Log</h2>
  <div class="log" id="log"></div>
</div>

<script>
let pass = 0, fail = 0, warn = 0;
let testMode = 'quick';
let allResults = []; // Collect all results for JSON export

function switchMode(mode) {
  testMode = mode;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-btn')[mode === 'quick' ? 0 : 1].classList.add('active');
  document.getElementById('cronSection').style.display = mode === 'full' ? 'block' : 'none';
}

function log(msg) {
  const el = document.getElementById('log');
  el.textContent += new Date().toISOString().substring(11,19) + ' ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}

function addSection(id, title) {
  const html = `<div class="section" id="section-${id}"><h2>${title}</h2><div id="tests-${id}"></div></div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function addResult(sectionId, name, status, detail, diagnostic) {
  if (status === 'pass') pass++;
  else if (status === 'fail') fail++;
  else warn++;

  // Track for JSON export
  allResults.push({ section: sectionId, name, status, detail: detail || null });

  const cls = status === 'pass' ? 'pass' : status === 'fail' ? 'fail' : 'warn';
  const icon = status === 'pass' ? '\u2713' : status === 'fail' ? '\u2717' : '\u26A0';
  const safeDetail = detail ? escapeHtml(String(detail)) : '';

  // Auto-diagnose common error patterns if no diagnostic provided
  let autoDiag = diagnostic || '';
  if (!diagnostic && status !== 'pass' && safeDetail) {
    const d = safeDetail.toLowerCase();
    if (d.includes('p2022') || d.includes('column') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2022:</strong> A column referenced in the query does not exist in the database. The Prisma schema defines it but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page, or run <code>npx prisma db push</code>.';
    } else if (d.includes('p2021') || d.includes('table') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2021:</strong> The table does not exist in the database. The model is defined in <code>prisma/schema.prisma</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page.';
    } else if (d.includes('p2002') || d.includes('unique constraint')) {
      autoDiag = '<strong>Prisma P2002:</strong> Unique constraint violation — a record with this value already exists. This usually means duplicate data or a re-run of a cron that already created this record.';
    } else if (d.includes('p1001') || d.includes('can\'t reach database') || d.includes('connection refused')) {
      autoDiag = '<strong>Database unreachable:</strong> The database server is not responding. Check that <code>DATABASE_URL</code> in Vercel env vars points to a running Supabase/PostgreSQL instance. If using Supabase, check that the project is not paused (free tier pauses after 7 days of inactivity).';
    } else if (d.includes('p1008') || d.includes('timed out')) {
      autoDiag = '<strong>Database timeout:</strong> The query took too long. This may be a cold start issue, a slow query, or the connection pool is exhausted. Check Supabase dashboard for connection count.';
    } else if (d.includes('type error') || d.includes('typeerror')) {
      autoDiag = '<strong>JavaScript TypeError:</strong> A code error is preventing this route from executing. Common causes: (1) A missing or misnamed import, (2) A function being called on <code>undefined</code>, (3) A build-time error that broke the serverless function chunk. Check Vercel Function Logs for the full stack trace.';
    } else if (d.includes('maxclientsinsessionmode') || d.includes('max clients reached') || d.includes('pool_size')) {
      autoDiag = '<strong>Connection Pool Exhausted:</strong> Supabase reached its connection limit. This happens when many API calls run in quick succession. Wait 30 seconds and retry, or increase the pool size in Supabase Dashboard → Settings → Database → Connection Pooling.';
    } else if (d.includes('http 0') || d.includes('failed to fetch') || d.includes('networkerror')) {
      autoDiag = '<strong>Network Error (HTTP 0):</strong> The request never reached the server. Causes: (1) The serverless function failed to load (build error), (2) Vercel is redeploying, (3) CORS or firewall blocking. Check Vercel deployment status and Function Logs.';
    } else if (d.includes('500')) {
      autoDiag = '<strong>HTTP 500 — Server Error:</strong> The route handler crashed. Check Vercel Function Logs for this specific path to see the full error and stack trace.';
    }
  }

  let diagHtml = '';
  if (autoDiag && status !== 'pass') {
    const diagCls = status === 'fail' ? 'diag' : 'diag diag-warn';
    diagHtml = `<div class="${diagCls}"><strong>Diagnosis:</strong> ${autoDiag}</div>`;
  }
  const html = `<div class="test-row">
    <div><div class="test-name">${escapeHtml(name)}</div>${safeDetail ? `<div class="detail">${safeDetail}</div>` : ''}${diagHtml}</div>
    <div class="test-status ${cls}">${icon} ${status.toUpperCase()}</div>
  </div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
  updateSummary();
}

function escapeHtml(str) {
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function addJsonBlock(sectionId, data) {
  const escaped = escapeHtml(JSON.stringify(data, null, 2));
  const html = `<div class="json-block">${escaped}</div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
}

function updateSummary() {
  document.getElementById('passCount').textContent = pass;
  document.getElementById('warnCount').textContent = warn;
  document.getElementById('failCount').textContent = fail;
}

async function testFetch(url, options = {}) {
  try {
    const resp = await fetch(url, { ...options, signal: AbortSignal.timeout(30000) });
    const text = await resp.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}
    // For non-OK responses, extract the most useful error detail
    let errorDetail = '';
    if (!resp.ok) {
      if (json?.error) errorDetail = json.error;
      else if (json?.message) errorDetail = json.message;
      else if (text.length < 500) errorDetail = text;
      else errorDetail = text.substring(0, 500);
    }
    return { ok: resp.ok, status: resp.status, text, json, headers: resp.headers, errorDetail };
  } catch (e) {
    return { ok: false, status: 0, text: e.message, json: null, error: e, errorDetail: e.message };
  }
}

// ─── Database Scan / Migrate ──────────────────────────────────────────
function getCronSecret() {
  return document.getElementById('cronSecret')?.value || '';
}

async function scanDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  document.getElementById('scanBtn').disabled = true;
  document.getElementById('scanBtn').textContent = 'Scanning...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbscan', 'Database Schema Scan — Missing Tables & Columns');
  log('Scanning database for missing tables and columns...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const s = j.summary || {};

      // Overall status
      if (s.needsMigration) {
        addResult('dbscan', 'Schema Status', 'fail',
          s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
          'Your database is out of sync with the Prisma schema. Click <strong>"Fix Missing Tables & Columns"</strong> to create the missing items automatically. This is safe — it only adds new tables/columns and never deletes existing data.');
      } else {
        addResult('dbscan', 'Schema Status', 'pass', 'All expected tables and columns exist');
      }

      // Missing tables
      if (j.missingTables && j.missingTables.length > 0) {
        for (const t of j.missingTables) {
          addResult('dbscan', 'Missing Table: ' + t.table, 'fail',
            'Prisma model ' + t.model + ' has no corresponding table in the database',
            'The <code>' + escapeHtml(t.table) + '</code> table needs to be created. This table is defined in <code>prisma/schema.prisma</code> as model <code>' + escapeHtml(t.model) + '</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> to create it.');
        }
      }

      // Missing columns
      if (j.missingColumns && j.missingColumns.length > 0) {
        for (const c of j.missingColumns) {
          addResult('dbscan', 'Missing Column: ' + c.table + '.' + c.column, 'fail',
            'Type: ' + c.type + ' — model ' + c.model,
            'Column <code>' + escapeHtml(c.column) + '</code> (' + escapeHtml(c.type) + ') is defined in the Prisma schema for model <code>' + escapeHtml(c.model) + '</code> but doesn\'t exist in the actual database table <code>' + escapeHtml(c.table) + '</code>. This will cause runtime errors (Prisma error P2022) when any API route tries to read or write this column. Click <strong>"Fix Missing Tables & Columns"</strong> to add it.');
        }
      }

      // Existing tables (info)
      if (j.existingTables) {
        addResult('dbscan', 'Existing Tables', 'pass',
          j.existingTables.length + ' tables found: ' + j.existingTables.slice(0, 15).join(', ') + (j.existingTables.length > 15 ? '...' : ''));
      }

      addJsonBlock('dbscan', j);
    } else if (resp.status === 401) {
      addResult('dbscan', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match. Go to Vercel → Settings → Environment Variables and copy the exact value.');
    } else {
      addResult('dbscan', 'Scan', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        resp.json?.hint || 'Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbscan', resp.json);
    }
  } catch (e) {
    addResult('dbscan', 'Scan', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">DATABASE SCHEMA IS IN SYNC</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SCHEMA ISSUE(S) — Click "Fix Missing Tables & Columns" to resolve</div>';
  }

  document.getElementById('scanBtn').disabled = false;
  document.getElementById('scanBtn').textContent = 'Scan Missing Tables/Columns';
}

async function migrateDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  if (!confirm('This will CREATE missing tables and ADD missing columns to your production database.\n\nIt will NOT delete any existing data.\n\nProceed?')) {
    return;
  }

  document.getElementById('migrateBtn').disabled = true;
  document.getElementById('migrateBtn').textContent = 'Migrating...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbmigrate', 'Database Migration — Creating Missing Tables & Columns');
  log('Running database migration...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const r = j.result || {};

      // Before/After summary
      addResult('dbmigrate', 'Before Migration',
        j.before.missingTables > 0 || j.before.missingColumns > 0 ? 'warn' : 'pass',
        j.before.missingTables + ' missing tables, ' + j.before.missingColumns + ' missing columns');

      addResult('dbmigrate', 'After Migration',
        j.after.missingTables === 0 && j.after.missingColumns === 0 ? 'pass' : 'warn',
        j.after.missingTables + ' missing tables, ' + j.after.missingColumns + ' missing columns',
        j.after.missingTables > 0 || j.after.missingColumns > 0 ? 'Some items could not be created. Check the errors below for details.' : undefined);

      // Tables created
      if (r.tablesCreated && r.tablesCreated.length > 0) {
        for (const t of r.tablesCreated) {
          addResult('dbmigrate', 'Created Table: ' + t, 'pass', 'Table created successfully');
        }
      }

      // Columns added
      if (r.columnsAdded && r.columnsAdded.length > 0) {
        for (const c of r.columnsAdded) {
          addResult('dbmigrate', 'Added Column: ' + c, 'pass', 'Column added successfully');
        }
      }

      // Indexes created
      if (r.indexesCreated && r.indexesCreated.length > 0) {
        addResult('dbmigrate', 'Indexes Created', 'pass', r.indexesCreated.length + ' indexes: ' + r.indexesCreated.slice(0, 8).join(', ') + (r.indexesCreated.length > 8 ? '...' : ''));
      }

      // Nothing to do
      if ((!r.tablesCreated || r.tablesCreated.length === 0) &&
          (!r.columnsAdded || r.columnsAdded.length === 0)) {
        addResult('dbmigrate', 'Result', 'pass', 'Nothing to migrate — database is already in sync');
      }

      // Errors
      if (r.errors && r.errors.length > 0) {
        for (const err of r.errors) {
          addResult('dbmigrate', 'Migration Error', 'fail', err,
            'This operation failed. It may require manual intervention or higher database permissions. Check that your database user has <code>CREATE TABLE</code> and <code>ALTER TABLE</code> privileges.');
        }
      }

      addJsonBlock('dbmigrate', j);
    } else if (resp.status === 401) {
      addResult('dbmigrate', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match.');
    } else {
      addResult('dbmigrate', 'Migration', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        (resp.json?.hint || '') + ' Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbmigrate', resp.json);
    }
  } catch (e) {
    addResult('dbmigrate', 'Migration', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">MIGRATION COMPLETE — All tables and columns synced</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' MIGRATION ERROR(S) — See details above</div>';
  }

  document.getElementById('migrateBtn').disabled = false;
  document.getElementById('migrateBtn').textContent = 'Fix Missing Tables & Columns';
}

// ─── Seed Static Content ──────────────────────────────────────────────────
async function seedStaticContent() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('seedBtn').disabled = true;
  document.getElementById('seedBtn').textContent = 'Seeding...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('seed', 'Seed Static Articles into Database');

  // First do a dry run
  log('Running dry-run scan of static content...');
  try {
    const dryResp = await testFetch('/api/admin/seed-content', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (dryResp.ok && dryResp.json) {
      const j = dryResp.json;
      addResult('seed', 'Static Articles Found', 'pass', j.totalStatic + ' published articles in data files');
      addResult('seed', 'Categories', 'pass', j.categories + ' categories');
      addResult('seed', 'Already in DB', j.alreadyInDb > 0 ? 'pass' : 'warn', j.alreadyInDb + ' articles already exist');
      addResult('seed', 'To Create', j.toCreate > 0 ? 'warn' : 'pass', j.toCreate + ' new articles to insert');
      addResult('seed', 'To Update', 'pass', j.toUpdate + ' existing articles to refresh');
      addJsonBlock('seed', j);
    } else if (dryResp.status === 401) {
      addResult('seed', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch');
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    } else {
      addResult('seed', 'Dry Run', 'fail', 'HTTP ' + dryResp.status + ' — ' + (dryResp.json?.error || ''));
      if (dryResp.json) addJsonBlock('seed', dryResp.json);
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    }
  } catch (e) {
    addResult('seed', 'Dry Run', 'fail', 'JS Error: ' + e.message);
    updateSummary();
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  if (!confirm('This will INSERT/UPDATE static articles into the BlogPost database table.\n\nArticles will be:\n• Published immediately\n• Assigned to site: yalla-london\n• Tagged with "imported-static"\n• Available to SEO agent, indexing, and CMS\n\nProceed?')) {
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  // Execute the seed in batches of 8 to avoid timeout
  const BATCH_SIZE = 8;
  let currentOffset = 0;
  let batchNum = 0;
  let totalCreated = 0, totalUpdated = 0, totalErrors = 0, totalSeoMeta = 0, totalUrlIdx = 0;
  let allCreatedSlugs = [], allUpdatedSlugs = [], allSkipped = [], allErrors = [];
  let lastAuthor = null, lastCategories = 0;
  let totalDurationMs = 0;

  log('Seeding static articles into database (batches of ' + BATCH_SIZE + ')...');

  while (true) {
    batchNum++;
    log('  Batch ' + batchNum + ': offset=' + currentOffset + ' limit=' + BATCH_SIZE);

    let seedResp;
    try {
      // Use 55s timeout for each batch (server has 50s budget)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 55000);
      const resp = await fetch('/api/admin/seed-content?offset=' + currentOffset + '&limit=' + BATCH_SIZE, {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}
      seedResp = { ok: resp.ok, status: resp.status, json, text };
    } catch (e) {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'Network error: ' + e.message + '. Try clicking Seed again — it will resume from where it stopped.');
      break;
    }

    if (seedResp.ok && seedResp.json) {
      const j = seedResp.json;
      const r = j.results || {};
      const b = j.batch || {};

      totalCreated += (r.created || []).length;
      totalUpdated += (r.updated || []).length;
      totalErrors += (r.errors || []).length;
      totalSeoMeta += r.seoMetaCreated || 0;
      totalUrlIdx += r.urlIndexingCreated || 0;
      totalDurationMs += j.durationMs || 0;
      allCreatedSlugs = allCreatedSlugs.concat(r.created || []);
      allUpdatedSlugs = allUpdatedSlugs.concat(r.updated || []);
      allSkipped = allSkipped.concat(r.skipped || []);
      allErrors = allErrors.concat(r.errors || []);
      if (j.author) lastAuthor = j.author;
      if (j.categories) lastCategories = j.categories;

      addResult('seed', 'Batch ' + batchNum, 'pass',
        (r.created||[]).length + ' created, ' + (r.updated||[]).length + ' updated' +
        (b.stoppedEarly ? ' (time-limited)' : '') + ' (' + j.durationMs + 'ms)');

      // Check if there are more articles to process
      if (!b.hasMore) {
        log('  All articles processed.');
        break;
      }
      currentOffset = b.nextOffset;
    } else {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'HTTP ' + seedResp.status + ' — ' + (seedResp.json?.error || seedResp.text?.substring(0, 200) || ''));
      if (seedResp.json) addJsonBlock('seed', seedResp.json);
      break;
    }
  }

  // Show combined results
  if (totalCreated + totalUpdated > 0) {
    addResult('seed', 'Seed Complete', 'pass',
      totalCreated + ' created, ' + totalUpdated + ' updated, ' + totalSeoMeta + ' SeoMeta, ' +
      totalUrlIdx + ' URLIndexing, ' + totalErrors + ' errors (' + totalDurationMs + 'ms total)');
    if (lastAuthor) addResult('seed', 'System Author', 'pass', lastAuthor.email + ' (ID: ' + lastAuthor.id + ')');
    addResult('seed', 'Categories', 'pass', lastCategories + ' categories in database');

    if (allCreatedSlugs.length > 0) {
      addResult('seed', 'New Articles', 'pass', allCreatedSlugs.length + ': ' + allCreatedSlugs.slice(0, 5).join(', ') + (allCreatedSlugs.length > 5 ? ' +' + (allCreatedSlugs.length-5) + ' more' : ''));
    }
    if (allUpdatedSlugs.length > 0) {
      addResult('seed', 'Updated Articles', 'pass', allUpdatedSlugs.length + ': ' + allUpdatedSlugs.slice(0, 5).join(', ') + (allUpdatedSlugs.length > 5 ? ' +' + (allUpdatedSlugs.length-5) + ' more' : ''));
    }
    if (allSkipped.length > 0) {
      addResult('seed', 'Skipped', 'warn', allSkipped.join(', '));
    }
    if (allErrors.length > 0) {
      for (const err of allErrors) {
        addResult('seed', 'Error: ' + err.slug, 'fail', err.error);
      }
    }
    addResult('seed', 'SEO Records', 'pass', totalSeoMeta + ' SeoMeta + ' + totalUrlIdx + ' URLIndexingStatus records created');

    addJsonBlock('seed', {
      action: 'seed-complete',
      batches: batchNum,
      totalDurationMs,
      created: allCreatedSlugs,
      updated: allUpdatedSlugs,
      skipped: allSkipped,
      errors: allErrors,
      seoMetaRecords: totalSeoMeta,
      urlIndexingRecords: totalUrlIdx,
    });
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">SEED COMPLETE — Static articles are now in the database</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SEED ERROR(S) — See details above</div>';
  }

  document.getElementById('seedBtn').disabled = false;
  document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
}

// ─── Run All Cron Jobs ────────────────────────────────────────────────────
// ── Smart Response Body Analyzer ──────────────────────────────────────────
// Detects hidden failures inside HTTP 200 responses from cron jobs.
// Returns null if the response looks genuinely healthy.
function analyzeJobResponse(jobName, json) {
  const issues = [];

  // 1. Explicit error fields buried in the response
  if (json.errors && typeof json.errors === 'object' && !Array.isArray(json.errors)) {
    const errorKeys = Object.keys(json.errors);
    if (errorKeys.length > 0) {
      const allErrored = errorKeys.every(k => json.errors[k] && String(json.errors[k]).length > 10);
      if (allErrored) {
        issues.push({
          severity: 'fail',
          msg: errorKeys.length + '/' + errorKeys.length + ' sites have errors',
          diag: 'All sites returned errors in the response body. First error: <code>' +
            escapeHtml(String(json.errors[errorKeys[0]]).substring(0, 200)) + '</code>'
        });
      } else if (errorKeys.some(k => json.errors[k] && String(json.errors[k]).length > 10)) {
        const failedSites = errorKeys.filter(k => json.errors[k] && String(json.errors[k]).length > 10);
        issues.push({
          severity: 'warn',
          msg: failedSites.length + '/' + errorKeys.length + ' sites have errors',
          diag: 'Some sites have errors: ' + failedSites.join(', ') + '. Check the JSON output for details.'
        });
      }
    }
  }

  // 2. Last run was timed_out (healthcheck endpoints report previous run status)
  if (json.lastRun?.status === 'timed_out' || json.lastRun?.duration_ms > 60000) {
    issues.push({
      severity: 'warn',
      msg: 'Last actual run timed out (' + (json.lastRun?.duration_ms || '?') + 'ms)',
      diag: 'The healthcheck passed but the last real execution timed out. The job likely needs optimization or a higher <code>maxDuration</code>.'
    });
  }

  // 3. All items failed (completed: 0, failed: N where N > 0)
  if (typeof json.completed === 'number' && typeof json.failed === 'number' &&
      json.failed > 0 && json.completed === 0) {
    issues.push({
      severity: 'fail',
      msg: 'All ' + json.failed + ' items failed, 0 completed',
      diag: 'Every item the job processed ended in failure. Check the error details in the JSON response.'
    });
  }

  // 4. items.failed > 0 or items_failed > 0 (withCronLog format)
  const itemsFailed = json.items?.failed ?? json.items_failed ?? json.metrics?.errors ?? 0;
  const itemsProcessed = json.items?.processed ?? json.items_processed ?? 0;
  if (itemsFailed > 0 && itemsProcessed > 0 && itemsFailed === itemsProcessed) {
    issues.push({
      severity: 'fail',
      msg: 'All ' + itemsFailed + ' processed items failed',
      diag: 'Every item the job attempted to process failed. None succeeded.'
    });
  } else if (itemsFailed > 0 && itemsFailed > itemsProcessed * 0.5) {
    issues.push({
      severity: 'warn',
      msg: itemsFailed + '/' + itemsProcessed + ' items failed (>' + Math.round(itemsFailed / itemsProcessed * 100) + '%)',
      diag: 'More than half of processed items failed. The job is degraded.'
    });
  }

  // 5. Absurd numeric values (e.g. interest scores in the trillions)
  if (json.keywordTrends && Array.isArray(json.keywordTrends)) {
    const absurdScores = json.keywordTrends.filter(t => t.interestScore > 1e9);
    if (absurdScores.length > 0) {
      issues.push({
        severity: 'warn',
        msg: absurdScores.length + ' keywords have nonsensical interest scores (>' + absurdScores[0].interestScore.toExponential(1) + ')',
        diag: 'Interest scores should typically range 0-100. Values in the billions/trillions indicate the trends data source is returning corrupt or unscaled data. The SERP API response may have changed format.'
      });
    }
  }
  if (json.contentOpportunities && Array.isArray(json.contentOpportunities)) {
    const absurdTraffic = json.contentOpportunities.filter(o => o.estimatedTraffic > 1e9);
    if (absurdTraffic.length > 0) {
      issues.push({
        severity: 'warn',
        msg: 'Estimated traffic values are nonsensical (' + absurdTraffic[0].estimatedTraffic.toExponential(1) + ')',
        diag: 'Traffic estimates are in the billions+. These numbers are not usable for content prioritization.'
      });
    }
  }

  // 6. Prisma/DB errors nested inside response objects
  const jsonStr = JSON.stringify(json);
  if (jsonStr.includes('Unknown argument') || jsonStr.includes('P2022') || jsonStr.includes('P2021') ||
      jsonStr.includes('does not exist') || jsonStr.includes('Invalid `prisma')) {
    issues.push({
      severity: 'fail',
      msg: 'Prisma/database schema errors in response',
      diag: 'The response contains Prisma errors indicating schema mismatches. The database may be missing columns or tables referenced by the code. Run <strong>"Fix Missing Tables & Columns"</strong> or <code>npx prisma db push</code>.'
    });
  }

  // 7. Permission errors (403) inside nested results
  if (jsonStr.includes('Insufficient Permission') || jsonStr.includes('insufficient authentication scopes') ||
      jsonStr.includes('"code": 403') || jsonStr.includes('"code":403')) {
    issues.push({
      severity: 'warn',
      msg: 'Permission errors (403) in sub-requests',
      diag: 'Some external API calls within the job returned 403 Forbidden. Check API credentials and OAuth scopes (e.g. Google Search Console service account permissions).'
    });
  }

  // 8. Zero work done when work was expected (not healthcheck responses)
  const isHealthcheck = json.status === 'healthy' || json.endpoint;
  if (!isHealthcheck) {
    const ran = json.ran ?? json.postsProcessed ?? null;
    const published = json.published ?? json.succeeded ?? null;
    if (typeof ran === 'number' && ran === 0 && typeof published === 'number' && published === 0) {
      // Only warn if this isn't a "nothing to do" situation
      const hasNothingToDo = json.message?.includes('No ') || json.availableTopics === 0;
      if (!hasNothingToDo) {
        issues.push({
          severity: 'warn',
          msg: 'Job ran 0 tasks, published 0 items',
          diag: 'The job completed but did nothing. This may indicate missing configuration, empty queues, or a silent failure mode.'
        });
      }
    }
  }

  // 9. totalErrors > 0 in response
  if (typeof json.totalErrors === 'number' && json.totalErrors > 0) {
    issues.push({
      severity: 'warn',
      msg: json.totalErrors + ' error(s) reported in response',
      diag: 'The job reported errors in its response. Check the detailed JSON output for specifics.'
    });
  }

  // 10. Most sites have zero URLs (indexing)
  if (json.results && Array.isArray(json.results)) {
    const siteResults = json.results.filter(r => r.siteId);
    const zeroUrlSites = siteResults.filter(r => r.urlsFound === 0);
    if (siteResults.length > 2 && zeroUrlSites.length >= siteResults.length - 1) {
      issues.push({
        severity: 'warn',
        msg: zeroUrlSites.length + '/' + siteResults.length + ' sites have 0 URLs to index',
        diag: 'Most sites have no URLs for indexing. This usually means no content has been published for those sites yet, or the URL discovery query is too restrictive.'
      });
    }
  }

  if (issues.length === 0) return null;

  // Pick the worst severity
  const hasFail = issues.some(i => i.severity === 'fail');
  const summary = issues.map(i => i.msg).join('; ');
  const diagnosis = issues.map(i => i.diag).join('<br><br>');

  return {
    severity: hasFail ? 'fail' : 'warn',
    summary: summary.substring(0, 250),
    diagnosis: diagnosis,
  };
}

// ── Expanded Job Detail Extractors ──────────────────────────────────────
// Each function extracts rich details from a specific cron job response
// to display exactly what was generated, where it was saved, and why things failed.

function extractJobDetails(jobName, json) {
  if (!json) return [];
  const details = [];
  const d = (label, value, cls) => details.push({ label, value: String(value).substring(0, 300), cls: cls || 'pass' });
  const w = (label, value) => d(label, value, 'warn');
  const f = (label, value) => d(label, value, 'fail');

  switch (jobName) {
    case 'Analytics Sync': {
      const ga = json.results?.ga4 || {};
      const gsc = json.results?.gsc || {};
      if (ga.status === 'not_configured') {
        w('GA4 Status', 'NOT CONFIGURED — Missing: ' + (ga.missing || ['GA4_PROPERTY_ID', 'GOOGLE_ANALYTICS_CLIENT_EMAIL', 'GOOGLE_ANALYTICS_PRIVATE_KEY']).join(', '));
        w('Action Required', 'Set these env vars in Vercel → Settings → Environment Variables. GA4 is needed for traffic analytics.');
      } else if (ga.status === 'success') {
        d('GA4 Sessions (30d)', (ga.sessions || 0).toLocaleString());
        d('GA4 Users (30d)', (ga.users || 0).toLocaleString());
        d('GA4 Page Views (30d)', (ga.pageViews || 0).toLocaleString());
        d('GA4 Bounce Rate', (ga.bounceRate || 0).toFixed(1) + '%');
        d('GA4 Top Pages Collected', (ga.topPagesCount || 0) + ' pages');
      } else if (ga.status === 'error') {
        f('GA4 Error', ga.error || 'Unknown GA4 error');
      }
      if (gsc.status === 'success') {
        d('GSC Queries (30d)', (gsc.queriesCount || 0) + ' search queries');
        if (gsc.topQueries?.length) d('Top GSC Query', gsc.topQueries[0].query + ' (' + gsc.topQueries[0].clicks + ' clicks, CTR ' + (gsc.topQueries[0].ctr * 100).toFixed(1) + '%)');
      } else if (gsc.status === 'error') {
        w('GSC Error', gsc.error || 'Unknown GSC error');
      } else {
        w('GSC Status', 'Not configured — need GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL + PRIVATE_KEY');
      }
      if (json.results?.snapshot?.status === 'created') d('Snapshot Saved', 'AnalyticsSnapshot record created in DB');
      break;
    }
    case 'Site Health Check': {
      if (json.results && Array.isArray(json.results)) {
        for (const s of json.results) {
          const score = s.health_score !== undefined ? ' (score: ' + s.health_score + '/100)' : '';
          d('Site: ' + s.site_id, s.status + score);
        }
      } else if (json.message) d('Status', json.message);
      break;
    }
    case 'Trends Monitor': {
      if (json.summary) {
        d('Relevant Trending Topics', json.summary.relevantTrendingTopics || 0);
        if (json.summary.risingKeywords?.length) d('Rising Keywords', json.summary.risingKeywords.join(', '));
        d('Content Opportunities', json.summary.contentOpportunities || 0);
      }
      if (json.trendingTopics?.length) d('Top Trend', json.trendingTopics[0].title + ' (traffic: ' + json.trendingTopics[0].traffic + ')');
      if (json.keywordTrends?.length) d('Keywords Tracked', json.keywordTrends.length + ' keywords');
      if (json.grokSocialTrends?.length) d('X/Twitter Trends (via Grok)', json.grokSocialTrends.length + ' social trends captured');
      else w('X/Twitter Trends', 'Not available — XAI_API_KEY needed for Grok live X search');
      d('Data Saved', 'SeoReport table (type: trends-monitor)');
      break;
    }
    case 'Weekly Topics': {
      d('Topics Generated', json.topicsGenerated || json.generated || 0);
      d('Pending Backlog', json.pendingCount || json.backlog || '?');
      if (json.skipped) d('Skipped', json.reason || 'Not Sunday / backlog sufficient');
      if (json.source) d('AI Source Used', json.source);
      if (json.topicsGenerated > 0) d('Saved To', 'TopicProposal table (status: pending, for content generation pipeline)');
      if (json.sites) {
        for (const [siteId, siteData] of Object.entries(json.sites || {})) {
          d('Site: ' + siteId, (siteData.en || 0) + ' EN + ' + (siteData.ar || 0) + ' AR topics');
        }
      }
      break;
    }
    case 'SEO Orchestrator': {
      if (json.lastRun) {
        d('Last Run', json.lastRun.status + (json.lastRun.at ? ' at ' + new Date(json.lastRun.at).toLocaleString() : ''));
        if (json.lastRun.healthScore !== undefined) d('Health Score', json.lastRun.healthScore + '/100');
        if (json.lastRun.issuesFound !== undefined) d('Issues Found', json.lastRun.issuesFound);
        if (json.lastRun.fixesApplied !== undefined) d('Auto-Fixes Applied', json.lastRun.fixesApplied);
      }
      d('Sites Monitored', json.sites || '?');
      d('Report Saved', 'SeoReport + SiteHealthCheck tables');
      break;
    }
    case 'SEO Agent': {
      if (json.lastRun) {
        d('Last Run', json.lastRun.status + ' — ' + new Date(json.lastRun.started_at || json.lastRun.at).toLocaleString());
        if (json.lastRun.duration_ms) d('Duration', json.lastRun.duration_ms + 'ms');
      }
      if (json.sites) d('Active Sites', json.sites);
      if (json.activeSites) d('Live Sites', json.activeSites.join(', '));
      d('Agent Tasks', '13-step autonomous SEO: audit → schema → indexing → GSC → content rewrite queue');
      d('Report Saved', 'SeoReport table + URLIndexingStatus + TopicProposal (rewrites)');
      break;
    }
    case 'SEO Health Report': {
      d('Status', json.message || json.status || 'Generated');
      if (json.score !== undefined) d('Overall SEO Score', json.score + '/100');
      d('Saved To', 'SeoReport table (type: weekly-health-report)');
      break;
    }
    case 'Daily Content Generate': {
      if (json.lastRun) {
        d('Last Run', json.lastRun.status + ' — ' + new Date(json.lastRun.started_at || json.lastRun.at).toLocaleString());
        if (json.lastRun.duration_ms > 60000) w('Duration', json.lastRun.duration_ms + 'ms (SLOW — risk of timeout)');
        else if (json.lastRun.duration_ms) d('Duration', json.lastRun.duration_ms + 'ms');
      }
      if (json.activeSites) d('Active Sites', json.activeSites.join(', '));
      if (json.sites && typeof json.sites === 'object' && !Array.isArray(json.sites)) {
        for (const [siteId, siteData] of Object.entries(json.sites)) {
          if (siteData.results) {
            const successes = siteData.results.filter(r => r.status === 'success');
            const slugs = successes.map(r => r.articleSlug).filter(Boolean);
            if (slugs.length) d('Generated (' + siteId + ')', slugs.join(', '));
            else if (siteData.status === 'failed') f('Failed (' + siteId + ')', siteData.error || 'Unknown error');
            else if (siteData.status === 'skipped') w('Skipped (' + siteId + ')', siteData.reason || 'Timeout or site not live');
          }
        }
      }
      d('AI Provider', 'Grok (primary) → Claude → OpenAI → Gemini → AbacusAI');
      d('Saved To', 'BlogPost table (status: published) + SeoMeta + URLIndexingStatus');
      d('Timeout Budget', '290s (300s maxDuration - 10s safety margin)');
      break;
    }
    case 'Daily Publish': {
      d('Status', json.message || 'Completed');
      if (json.published) d('Published', json.published + ' posts');
      if (json.availableTopics !== undefined) d('Available Topics', json.availableTopics);
      if (json.message?.includes('No approved')) w('Note', 'No approved topics in queue — weekly-topics cron needs to generate topics first');
      break;
    }
    case 'Scheduled Publish': {
      d('Status', json.message || 'Completed');
      if (json.published !== undefined) d('Published This Run', json.published + ' posts');
      if (json.pending !== undefined) d('Still Pending', json.pending + ' posts');
      if (json.nextScheduled?.length) d('Next Scheduled', json.nextScheduled.map(p => (p.title || '').substring(0, 40)).join('; '));
      break;
    }
    case 'Auto Generate': {
      d('Status', json.message || 'Completed');
      if (json.generated !== undefined) d('Generated', json.generated + ' articles');
      if (json.queued !== undefined) d('Queued', json.queued + ' articles');
      break;
    }
    case 'Fact Verification': {
      if (json.status === 'healthy') d('Status', 'Healthy (healthcheck mode)');
      else {
        d('Status', json.message || 'Completed');
        if (json.factsChecked !== undefined) d('Facts Checked', json.factsChecked);
        if (json.issuesFound !== undefined) d('Issues Found', json.issuesFound);
      }
      d('Saved To', 'FactEntry table (flagged facts for manual review)');
      break;
    }
    case 'London News': {
      d('Status', json.message || json.status || 'Completed');
      if (json.published !== undefined) d('News Items Published', json.published);
      if (json.archived !== undefined) d('Expired Items Archived', json.archived);
      if (json.grokNewsCount !== undefined) d('Live News via Grok/X', json.grokNewsCount + ' items');
      else w('Grok Live News', 'Not active — set XAI_API_KEY for live London news from X/Twitter');
      d('Saved To', 'NewsItem table + NewsResearchLog');
      break;
    }
    case 'Real-Time Optimization': {
      const checked = json.checked || json.articlesChecked || 0;
      const flagged = json.flagged || json.optimizationsNeeded || 0;
      d('Articles Checked', checked);
      d('Flagged for Optimization', flagged);
      if (flagged > 0) w('Action', flagged + ' articles need SEO score improvements or content updates');
      else d('Result', 'All checked articles meet quality thresholds');
      break;
    }
    case 'Google Indexing': {
      d('Total URLs Submitted', json.totalUrlsSubmitted || 0);
      if (json.totalErrors > 0) w('Submission Errors', json.totalErrors);
      if (json.results && Array.isArray(json.results)) {
        for (const r of json.results) {
          const inStatus = r.indexNow?.status || 'unknown';
          const inCount = r.indexNow?.submitted || 0;
          const gscOk = r.gscSitemap?.success;
          const siteLabel = r.siteId || 'unknown';
          if (r.urlsFound === 0) {
            w('Site: ' + siteLabel, '0 URLs found — no new/updated content in last 3 days');
          } else {
            d('Site: ' + siteLabel, r.urlsFound + ' URLs found → IndexNow: ' + inCount + ' submitted (' + inStatus + ')' + (gscOk ? ' | GSC sitemap: pinged' : gscOk === false ? ' | GSC sitemap: FAILED' : ''));
          }
        }
      }
      w('Indexing Pipeline', 'IndexNow → Bing/Yandex (instant) | GSC sitemap ping → Google (hours-days)');
      if (!json.hasIndexNowKey && json.hasIndexNowKey !== undefined) f('INDEXNOW_KEY', 'NOT SET — URLs cannot be submitted to Bing/Yandex. Set INDEXNOW_KEY in Vercel env vars.');
      if (!json.hasGscCredentials && json.hasGscCredentials !== undefined) w('GSC Credentials', 'Not configured — Google sitemap ping disabled');
      d('Tracking Table', 'URLIndexingStatus (per-URL status: submitted → pending_review → indexed | failed)');
      break;
    }
    case 'Autopilot': {
      d('Status', json.message || json.status || 'Completed');
      if (json.tasksRun !== undefined) d('Tasks Executed', json.tasksRun);
      if (json.tasksSeeded !== undefined) d('Tasks Self-Seeded', json.tasksSeeded);
      if (json.nextDue) d('Next Due Task', json.nextDue);
      break;
    }
    case 'Social': {
      const processed = json.postsProcessed || json.ran || 0;
      const published = json.published || json.succeeded || 0;
      const failed = json.failed || 0;
      if (processed === 0 && published === 0) {
        w('Status', 'MOCK IMPLEMENTATION — No posts queued. Social API integration not yet connected.');
        w('Note', 'Posts are marked "published" in DB but NOT actually sent to Twitter/X, Instagram, or LinkedIn.');
        w('Requires', 'TWITTER_API_KEY + TWITTER_API_SECRET + TWITTER_ACCESS_TOKEN + TWITTER_ACCESS_TOKEN_SECRET (just updated on Vercel)');
      } else {
        d('Posts Processed', processed);
        d('Published', published);
        if (failed > 0) f('Failed', failed);
      }
      if (json.results?.length) {
        for (const r of json.results) {
          d('Post: ' + r.platform, r.status + (r.note ? ' — ' + r.note : ''));
        }
      }
      break;
    }
  }
  return details;
}

async function runAllJobs() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('jobsBtn').disabled = true;
  document.getElementById('jobsBtn').textContent = 'Running Jobs...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  // Active sites banner
  addSection('sites-info', 'Active Sites Configuration');
  addResult('sites-info', 'Live Sites', 'pass', 'yalla-london (yalla-london.com)');
  addResult('sites-info', 'Inactive Sites (no website yet)', 'warn',
    'arabaldives, dubai, istanbul, thailand — cron jobs skip these sites to save AI tokens and time',
    'These sites are defined in <code>config/sites.ts</code> but have no deployed website. Cron jobs use <code>getActiveSiteIds()</code> to process only live sites. Add site IDs to <code>LIVE_SITES</code> array when their websites go live.');

  addSection('jobs', 'Cron Job Execution Results');

  // Jobs ordered by dependency chain: foundational first, then consumers
  const jobs = [
    { name: 'Analytics Sync',          path: '/api/cron/analytics',               method: 'GET',  timeout: 55000, category: 'Analytics & Data' },
    { name: 'Site Health Check',        path: '/api/cron/site-health-check',       method: 'GET',  timeout: 55000, category: 'Analytics & Data' },
    { name: 'Trends Monitor',          path: '/api/cron/trends-monitor',          method: 'GET',  timeout: 55000, category: 'Research & Intelligence' },
    { name: 'Weekly Topics',           path: '/api/cron/weekly-topics',           method: 'GET',  timeout: 55000, category: 'Research & Intelligence' },
    { name: 'SEO Orchestrator',        path: '/api/cron/seo-orchestrator?healthcheck=true', method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'SEO Agent',               path: '/api/cron/seo-agent?healthcheck=true',       method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'SEO Health Report',       path: '/api/cron/seo-health-report',      method: 'GET',  timeout: 55000, category: 'SEO' },
    { name: 'Daily Content Generate',  path: '/api/cron/daily-content-generate',  method: 'GET',  timeout: 115000, category: 'Content' },
    { name: 'Daily Publish',           path: '/api/cron/daily-publish',           method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Scheduled Publish',       path: '/api/cron/scheduled-publish',       method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Auto Generate',           path: '/api/cron/auto-generate',           method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Fact Verification',       path: '/api/cron/fact-verification?healthcheck=true', method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'London News',             path: '/api/cron/london-news',             method: 'GET',  timeout: 55000, category: 'Content' },
    { name: 'Real-Time Optimization',  path: '/api/cron/real-time-optimization',  method: 'POST', timeout: 55000, category: 'SEO' },
    { name: 'Google Indexing',          path: '/api/cron/google-indexing',          method: 'GET',  timeout: 55000, category: 'Indexing' },
    { name: 'Autopilot',              path: '/api/cron/autopilot',               method: 'GET',  timeout: 55000, category: 'Orchestration' },
    { name: 'Social',                 path: '/api/cron/social',                  method: 'GET',  timeout: 55000, category: 'Social' },
  ];

  let jobPass = 0, jobFail = 0, jobWarn = 0;
  const jobResults = [];
  const envStatus = {
    confirmed: ['DATABASE_URL', 'CRON_SECRET', 'NEXTAUTH_SECRET', 'NODE_ENV'],
    justUpdated: ['XAI_API_KEY', 'TWITTER_API_KEY'],
    needsVerification: [],
    missing: [],
  };

  for (let i = 0; i < jobs.length; i++) {
    const job = jobs[i];
    const startTime = Date.now();
    log('  [' + (i + 1) + '/' + jobs.length + '] ' + job.name + ' (' + job.path + ')...');
    updateSummary();

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), job.timeout);
      const resp = await fetch(job.path, {
        method: job.method,
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const elapsed = Date.now() - startTime;
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}

      const durationHint = json?.durationMs ? ' (' + json.durationMs + 'ms)' : ' (' + elapsed + 'ms)';

      // Smart response-body analysis
      const bodyIssues = resp.ok && json ? analyzeJobResponse(job.name, json) : null;

      // Determine overall status
      let status, detail, diagnosis;
      if (resp.ok && bodyIssues) {
        status = bodyIssues.severity;
        detail = 'HTTP ' + resp.status + durationHint + ' — ' + bodyIssues.summary;
        diagnosis = bodyIssues.diagnosis;
      } else if (resp.ok) {
        status = 'pass';
        detail = 'HTTP ' + resp.status + durationHint + ' — OK';
      } else if (resp.status === 504 || resp.status === 503) {
        status = 'warn';
        detail = 'HTTP ' + resp.status + ' — Timeout/Unavailable';
        diagnosis = resp.status === 504 ? 'Function exceeded Vercel timeout. This job needs a higher <code>maxDuration</code> or task splitting.' :
          'Service temporarily unavailable. May be a build error or cold start issue.';
      } else if (resp.status === 401) {
        status = 'fail';
        detail = 'HTTP 401 — CRON_SECRET mismatch';
      } else {
        status = 'fail';
        detail = 'HTTP ' + resp.status + ' — ' + (json?.error || text?.substring(0, 150) || 'Unknown error');
      }

      // Add main result
      addResult('jobs', job.name + '  [' + job.category + ']', status, detail, diagnosis);

      // Add expanded details
      const details = extractJobDetails(job.name, json);
      for (const dt of details) {
        addResult('jobs', '  ↳ ' + dt.label, dt.cls, dt.value);
      }

      // Track env var status from responses
      if (json) {
        if (json.results?.ga4?.status === 'not_configured') {
          (json.results.ga4.missing || ['GA4_PROPERTY_ID', 'GOOGLE_ANALYTICS_CLIENT_EMAIL', 'GOOGLE_ANALYTICS_PRIVATE_KEY']).forEach(v => {
            if (!envStatus.missing.includes(v)) envStatus.missing.push(v);
          });
        }
        if (json.hasIndexNowKey === false && !envStatus.missing.includes('INDEXNOW_KEY')) envStatus.missing.push('INDEXNOW_KEY');
        if (json.hasGscCredentials === false) {
          ['GOOGLE_SEARCH_CONSOLE_CLIENT_EMAIL', 'GOOGLE_SEARCH_CONSOLE_PRIVATE_KEY'].forEach(v => {
            if (!envStatus.missing.includes(v) && !envStatus.needsVerification.includes(v)) envStatus.needsVerification.push(v);
          });
        }
      }

      if (json) addJsonBlock('jobs', json);

      if (status === 'fail') jobFail++;
      else if (status === 'warn') jobWarn++;
      else jobPass++;

      jobResults.push({
        name: job.name,
        category: job.category,
        status,
        httpStatus: resp.status,
        durationMs: json?.durationMs || elapsed,
        detail: detail.substring(0, 250),
        expandedDetails: details,
        responseKeys: json ? Object.keys(json) : [],
      });
    } catch (e) {
      const elapsed = Date.now() - startTime;
      const isTimeout = e.name === 'AbortError' || e.message?.includes('aborted');
      if (isTimeout) {
        addResult('jobs', job.name + '  [' + job.category + ']', 'warn',
          'Client timeout (' + Math.round(elapsed / 1000) + 's) — function may still be running on server',
          job.name === 'Daily Content Generate'
            ? 'Content generation takes up to 290s. It likely completed on the server. Check Vercel Function Logs. Consider splitting per-site generation into separate cron entries.'
            : 'The function exceeded the client timeout. It may have completed on the server. Check Vercel Function Logs.');
        jobWarn++;
      } else {
        addResult('jobs', job.name + '  [' + job.category + ']', 'fail', 'Network error: ' + e.message);
        jobFail++;
      }
      jobResults.push({ name: job.name, category: job.category, status: isTimeout ? 'warn' : 'fail', durationMs: elapsed, error: e.message });
    }

    // 3s pause between jobs for PgBouncer session drain
    if (i < jobs.length - 1) {
      await new Promise(r => setTimeout(r, 3000));
    }
  }

  // ── Environment Variables Status ──
  addSection('envstatus', 'Environment Variables Status');
  for (const v of envStatus.confirmed) addResult('envstatus', v, 'pass', 'Confirmed set on Vercel');
  for (const v of envStatus.justUpdated) addResult('envstatus', v, 'pass', 'Just updated on Vercel (verify working)');
  for (const v of envStatus.needsVerification) addResult('envstatus', v, 'warn', 'Needs verification — set in Vercel but not confirmed working');
  for (const v of envStatus.missing) addResult('envstatus', v, 'fail', 'MISSING — not set in Vercel. Required for full functionality.',
    'Set this env var in Vercel → Settings → Environment Variables. See <code>.env.example</code> for format and description.');

  // ── Summary ──
  addResult('jobs', 'Summary', jobFail === 0 ? 'pass' : 'fail',
    jobPass + ' passed, ' + jobWarn + ' warnings, ' + jobFail + ' failed out of ' + jobs.length + ' jobs');

  // ── Extensive Summary JSON + Copy Button ──
  const fullSummary = {
    action: 'run-all-jobs',
    timestamp: new Date().toISOString(),
    platform: {
      activeSites: ['yalla-london'],
      inactiveSites: ['arabaldives', 'dubai', 'istanbul', 'thailand'],
      reason: 'Only yalla-london has a deployed website. Other sites skip cron processing.',
    },
    summary: {
      passed: jobPass,
      warnings: jobWarn,
      failed: jobFail,
      total: jobs.length,
      verdict: jobFail === 0 && jobWarn === 0 ? 'ALL_CLEAR' : jobFail === 0 ? 'OPERATIONAL_WITH_WARNINGS' : 'NEEDS_ATTENTION',
    },
    environmentVariables: envStatus,
    results: jobResults,
    recommendations: [
      ...(envStatus.missing.includes('INDEXNOW_KEY') ? ['Set INDEXNOW_KEY for Bing/Yandex fast indexing'] : []),
      ...(envStatus.missing.some(v => v.includes('GA4')) ? ['Set GA4_PROPERTY_ID + service account for analytics data'] : []),
      ...(envStatus.missing.some(v => v.includes('GSC') || v.includes('SEARCH_CONSOLE')) ? ['Set GSC service account credentials for search performance data'] : []),
      ...(jobResults.some(r => r.name === 'Social' && r.status === 'warn') ? ['Social posting is MOCK — implement real Twitter/X API integration when ready'] : []),
      ...(jobResults.some(r => r.name === 'Daily Content Generate' && r.durationMs > 60000) ? ['Content generation is slow — consider splitting per-site into separate cron entries'] : []),
    ],
    cronSchedule: {
      '3:00 UTC': 'Analytics sync',
      '4:00 UTC Mon': 'Weekly topic research',
      '5:00 UTC': 'Daily content generation',
      '5:00 UTC Sun': 'SEO orchestrator (weekly)',
      '6:00 UTC': 'Trends monitor + SEO orchestrator (daily)',
      '7:00 UTC': 'SEO agent run 1',
      '7:30 UTC': 'SEO daily cron',
      '8:00 UTC Sun': 'SEO weekly cron',
      '9:00 UTC': 'Scheduled publish (morning)',
      '10:00 UTC': 'Google indexing',
      '13:00 UTC': 'SEO agent run 2',
      '16:00 UTC': 'Scheduled publish (afternoon)',
      '20:00 UTC': 'SEO agent run 3',
    },
    knownIssues: [
      'Social cron is MOCK — marks published in DB but does NOT post to Twitter/X/Instagram/LinkedIn',
      'Soft-delete migrations not deployed — deletedAt column dormant',
      'PgBouncer connection_limit=1 workaround for Supabase session mode',
      'Content generation timeout risk at 290s budget — works for 1 site, may need splitting for 5',
    ],
  };

  // Remove existing JSON export
  const existing = document.getElementById('section-jobsjson');
  if (existing) existing.remove();

  const jsonStr = JSON.stringify(fullSummary, null, 2);
  const jsonHtml = `<div class="section" id="section-jobsjson">
    <h2>Full Operations Report — JSON</h2>
    <p style="color:#888;font-size:0.8rem;margin-bottom:8px;">Complete diagnostic data including env vars, recommendations, schedule, and known issues.</p>
    <button onclick="copyJobsJson()" id="copyJobsBtn" style="margin:0 0 12px;padding:8px 20px;font-size:0.85rem;background:#7c3aed;">Copy JSON to Clipboard</button>
    <textarea id="jobsJsonArea" readonly style="width:100%;height:400px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.75rem;resize:vertical;">${escapeHtml(jsonStr)}</textarea>
  </div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', jsonHtml);

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (jobFail === 0 && jobWarn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL ' + jobs.length + ' CRON JOBS PASSED</div>';
  } else if (jobFail === 0) {
    banner.innerHTML = '<div class="status-banner status-warn">' + jobPass + ' JOBS PASSED, ' + jobWarn + ' WARNINGS — No critical failures</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + jobFail + ' JOB(S) FAILED — See details above</div>';
  }

  document.getElementById('jobsBtn').disabled = false;
  document.getElementById('jobsBtn').textContent = 'Run All Cron Jobs';
}

function copyJobsJson() {
  const area = document.getElementById('jobsJsonArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = document.getElementById('copyJobsBtn');
    btn.textContent = 'Copied!';
    btn.style.background = '#16a34a';
    setTimeout(() => { btn.textContent = 'Copy JSON to Clipboard'; btn.style.background = '#7c3aed'; }, 2000);
  }).catch(() => { document.execCommand('copy'); });
}

// ─── Test Runner ──────────────────────────────────────────────────────────
async function runAllTests() {
  pass = 0; fail = 0; warn = 0;
  allResults = [];
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  document.getElementById('runBtn').disabled = true;
  document.getElementById('runBtn').textContent = 'Testing...';

  const cronSecret = document.getElementById('cronSecret')?.value || '';

  // ── 1. GA4 Client-Side ──
  log('Testing GA4 client-side tracking...');
  addSection('ga4', '1. GA4 Client-Side Tracking');

  const homeResp = await testFetch('/');
  if (homeResp.ok) {
    const gaMatch = homeResp.text.match(/G-[A-Z0-9]{8,12}/);
    if (gaMatch) {
      addResult('ga4', 'GA4 Measurement ID', 'pass', 'Found on homepage: ' + gaMatch[0]);
      if (homeResp.text.includes('googletagmanager.com/gtag')) {
        addResult('ga4', 'gtag.js Script', 'pass', 'Script tag present on homepage');
      } else {
        addResult('ga4', 'gtag.js Script', 'warn', 'ID found but script tag not detected (may load async)');
      }
    } else {
      addResult('ga4', 'GA4 Measurement ID', 'fail', 'Not found in homepage source',
        'The <code>NEXT_PUBLIC_GA_MEASUREMENT_ID</code> env var may be missing in Vercel, or the GA4 script is not injected in <code>app/layout.tsx</code>. Check Vercel → Settings → Environment Variables for a value like <code>G-XXXXXXXXXX</code>.');
    }
  } else {
    addResult('ga4', 'Homepage Load', 'fail', 'Could not load homepage: HTTP ' + homeResp.status,
      homeResp.status === 0 ? 'Network error — site may be down or Cloudflare is blocking. Check Vercel deployment status.' :
      homeResp.status === 500 ? 'Server error — check Vercel Function Logs for the root cause (likely a missing env var or DB connection issue).' :
      homeResp.status === 503 ? 'Service unavailable — Vercel may be redeploying or the function timed out.' :
      'Unexpected HTTP ' + homeResp.status + ' — check Vercel logs.');
  }

  // ── 2. Static Assets (cache-bust to bypass stale CDN 404s) ──
  log('Testing static assets (with cache-bust)...');
  addSection('assets', '2. Static Assets');

  const cacheBust = '?v=' + Date.now();
  const assets = [
    ['/og-image.jpg' + cacheBust, 'OG Image (og-image.jpg)'],
    ['/icons/icon-512x512.png' + cacheBust, 'Icon 512x512'],
    ['/icons/icon-192x192.png' + cacheBust, 'Icon 192x192'],
    ['/favicon.ico' + cacheBust, 'Favicon ICO'],
    ['/favicon.png' + cacheBust, 'Favicon PNG'],
    ['/favicon.svg' + cacheBust, 'Favicon SVG'],
    ['/manifest.json' + cacheBust, 'Manifest'],
  ];

  for (const [url, label] of assets) {
    const resp = await testFetch(url, { method: 'HEAD' });
    if (resp.ok) {
      addResult('assets', label, 'pass', url.split('?')[0] + ' — HTTP ' + resp.status);
    } else {
      addResult('assets', label, 'fail', url.split('?')[0] + ' — HTTP ' + resp.status,
        resp.status === 404 ? 'File missing from <code>public/</code> folder. Ensure the file exists at <code>yalla_london/app/public' + url.split('?')[0] + '</code> and redeploy.' :
        'HTTP ' + resp.status + ' — may need Cloudflare cache purge. Try: Cloudflare Dashboard → Caching → Purge Everything.');
    }
  }

  // ── 3. Core Pages ──
  log('Testing core pages...');
  addSection('pages', '3. Core Pages');

  const pages = [
    ['/', 'Homepage'],
    ['/events', 'Events'],
    ['/blog', 'Blog'],
    ['/about', 'About'],
    ['/recommendations', 'Recommendations'],
    ['/sitemap.xml', 'Sitemap XML'],
  ];

  for (const [url, label] of pages) {
    const resp = await testFetch(url);
    if (resp.ok) {
      addResult('pages', label, 'pass', 'HTTP ' + resp.status);
    } else if (resp.status === 404) {
      addResult('pages', label, 'warn', 'HTTP 404',
        'Page not found. Check that <code>app/' + url.replace(/^\//, '') + '/page.tsx</code> exists in the App Router. If using dynamic routes, the page may need published content in the database to render.');
    } else {
      addResult('pages', label, 'fail', 'HTTP ' + resp.status,
        resp.status === 500 ? 'Server error rendering this page. Check Vercel Function Logs → filter by path <code>' + url + '</code> for the stack trace.' :
        resp.status === 0 ? 'Network timeout — page may be too slow to render. Check for expensive DB queries or missing data.' :
        'HTTP ' + resp.status + ' — check Vercel logs for this route.');
    }
  }

  // ── 4. SEO Meta Tags ──
  log('Testing SEO meta tags...');
  addSection('meta', '4. SEO Meta Tags');

  if (homeResp.ok) {
    const checks = [
      [/property="og:image"[^>]*content="([^"]+)"/, 'og:image'],
      [/property="og:title"[^>]*content="([^"]+)"/, 'og:title'],
      [/property="og:description"[^>]*content="([^"]+)"/, 'og:description'],
      [/rel="canonical"[^>]*href="([^"]+)"/, 'Canonical URL'],
    ];
    for (const [regex, label] of checks) {
      const match = homeResp.text.match(regex);
      if (match) addResult('meta', label, 'pass', match[1].substring(0, 80));
      else addResult('meta', label, 'warn', 'Not found on homepage',
        'Meta tag <code>' + label + '</code> is missing. Check the homepage <code>metadata</code> export in <code>app/page.tsx</code> or <code>app/layout.tsx</code>. For og:image, ensure <code>public/og-image.jpg</code> exists and is referenced in the metadata.');
    }
    const jsonLd = homeResp.text.match(/type="application\/ld\+json"/);
    if (jsonLd) addResult('meta', 'JSON-LD Schema', 'pass', 'Present');
    else addResult('meta', 'JSON-LD Schema', 'warn', 'Not found',
      'No JSON-LD structured data on homepage. Add a <code>&lt;script type="application/ld+json"&gt;</code> block in the layout or use the schema generator at <code>lib/seo/schema-generator.ts</code>.');
  }

  // ── 5. Database ──
  log('Testing database connection...');
  addSection('db', '5. Database Connection');

  const blogApiResp = await testFetch('/api/blog?limit=1');
  if (blogApiResp.ok && blogApiResp.json) {
    const j = blogApiResp.json;
    const count = j.total || j.posts?.length || j.length || '?';
    addResult('db', 'Blog API', 'pass', 'Connected — ' + count + ' posts returned');
  } else if (blogApiResp.status === 404) {
    addResult('db', 'Blog API', 'warn', 'No public blog API (DB may work via internal routes)',
      'No <code>/api/blog</code> route found. The blog API may be under <code>/api/admin/blog</code> (auth-required). The database itself is likely fine — this just means there is no public unauthenticated blog API.');
  } else {
    addResult('db', 'Blog API', blogApiResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + blogApiResp.status,
      blogApiResp.status === 500 ? 'Database connection failed. Check <code>DATABASE_URL</code> in Vercel env vars. The Prisma client may need <code>prisma generate</code> or the DB may be unreachable.' :
      blogApiResp.status === 503 ? 'Database temporarily unavailable — Supabase may be paused or connection pool exhausted.' :
      'HTTP ' + blogApiResp.status + ' — check <code>/api/blog/route.ts</code> for issues.');
  }

  // ── 6. AI Provider ──
  log('Testing AI provider...');
  addSection('ai', '6. AI Provider');

  const aiResp = await testFetch('/api/ai/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  if (aiResp.status === 401 || aiResp.status === 403) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (auth-protected)');
  } else if (aiResp.status === 400) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (needs valid payload)');
  } else if (aiResp.status === 404) {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'Not found at /api/ai/generate',
      'The AI generate endpoint doesn\'t exist at this path. Content generation uses the internal <code>lib/ai/provider.ts</code> layer directly from cron jobs — this is expected if there\'s no public AI endpoint.');
  } else if (aiResp.ok) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Responded OK');
  } else {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'HTTP ' + aiResp.status,
      aiResp.status === 500 ? 'AI provider error. Check that <code>ANTHROPIC_API_KEY</code> (or <code>OPENAI_API_KEY</code> / <code>ABACUSAI_API_KEY</code>) is set in Vercel env vars. Also check <code>ModelProvider</code> table in the DB.' :
      'Unexpected response — check Vercel function logs for <code>/api/ai/generate</code>.');
  }

  // ── Full pipeline tests (need CRON_SECRET) ──
  if (testMode === 'full' && cronSecret) {
    const cronHeaders = { 'Authorization': 'Bearer ' + cronSecret };

    // ── 7. Content Generation Pipeline ──
    log('Testing content generation pipeline...');
    addSection('pipeline', '7. Content Generation Pipeline');
    try {
      log('  Testing daily-content-generate...');
      const contentResp = await testFetch('/api/cron/daily-content-generate?healthcheck=true', { headers: cronHeaders });
      if (contentResp.ok && contentResp.json) {
        const j = contentResp.json;
        addResult('pipeline', 'Daily Content Generate', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('pipeline', 'Last Run', 'pass', j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        if (j.sites !== undefined) addResult('pipeline', 'Active Sites', 'pass', j.sites + ' sites configured');
        addJsonBlock('pipeline', j);
      } else if (contentResp.status === 401) {
        addResult('pipeline', 'Daily Content Generate', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'The CRON_SECRET you entered doesn\'t match what\'s in Vercel. Go to Vercel → Settings → Environment Variables → find <code>CRON_SECRET</code> and copy the exact value.');
      } else {
        const err = contentResp.json?.error || contentResp.text?.substring(0, 150) || 'Unknown error';
        const pipelineStatus = contentResp.status === 503 ? 'warn' : 'fail';
        addResult('pipeline', 'Daily Content Generate', pipelineStatus, 'HTTP ' + contentResp.status + ' — ' + err,
          contentResp.status === 500 ? 'Content generation crashed. Common causes: (1) No AI API key set (<code>ANTHROPIC_API_KEY</code>), (2) Database unreachable (<code>DATABASE_URL</code>), (3) No categories/authors seeded. Check Vercel Function Logs → filter <code>/api/cron/daily-content-generate</code>.' :
          contentResp.status === 503 ? 'The endpoint returned 503 (unhealthy). This usually means a dependent service (AI API, database, or config) is not available. Check that <code>ANTHROPIC_API_KEY</code> or another AI provider key is set in Vercel Environment Variables.' :
          'Check Vercel Function Logs for the full error stack trace.');
        if (contentResp.json) addJsonBlock('pipeline', contentResp.json);
      }
    } catch (e) { log('  ERROR in section 7: ' + e.message); addResult('pipeline', 'Daily Content Generate', 'fail', 'JS Error: ' + e.message); }

    // ── 8. Scheduled Publish ──
    log('  Testing scheduled-publish...');
    addSection('publish', '8. Scheduled Publish');
    try {
      const publishResp = await testFetch('/api/cron/scheduled-publish', { headers: cronHeaders });
      if (publishResp.ok && publishResp.json) {
        const j = publishResp.json;
        addResult('publish', 'Scheduled Publish', 'pass', j.message || 'OK');
        if (j.published !== undefined) addResult('publish', 'Posts Published', 'pass', j.published + ' posts published this run');
        if (j.pending !== undefined) addResult('publish', 'Pending Schedule', 'pass', j.pending + ' posts pending');
        if (Array.isArray(j.nextScheduled) && j.nextScheduled.length) addResult('publish', 'Next Scheduled', 'pass', j.nextScheduled.map(p => (p.title || '').substring(0,40) + ' @ ' + (p.scheduled_at || '')).join('; '));
        addJsonBlock('publish', j);
      } else if (publishResp.status === 401) {
        addResult('publish', 'Scheduled Publish', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('publish', 'Scheduled Publish', 'warn', 'HTTP ' + publishResp.status + ' — ' + (publishResp.json?.error || publishResp.text?.substring(0,100) || ''),
          publishResp.status === 500 ? 'Publisher crashed. Likely a DB issue or no <code>ScheduledContent</code> records. Check Vercel logs for <code>/api/cron/scheduled-publish</code>.' :
          'Check Vercel Function Logs for details.');
        if (publishResp.json) addJsonBlock('publish', publishResp.json);
      }
    } catch (e) { log('  ERROR in section 8: ' + e.message); addResult('publish', 'Scheduled Publish', 'fail', 'JS Error: ' + e.message); }

    // ── 9. Weekly Topics ──
    log('  Testing weekly-topics...');
    addSection('topics', '9. Weekly Topics Research');
    try {
      const topicsResp = await testFetch('/api/cron/weekly-topics', { headers: cronHeaders });
      if (topicsResp.ok && topicsResp.json) {
        const j = topicsResp.json;
        addResult('topics', 'Weekly Topics', 'pass', j.message || 'OK');
        if (j.topicsGenerated !== undefined) addResult('topics', 'Topics Generated', 'pass', j.topicsGenerated + ' topics');
        if (j.pendingCount !== undefined) addResult('topics', 'Pending Backlog', 'pass', j.pendingCount + ' topics in backlog');
        if (j.skipped) addResult('topics', 'Status', 'pass', 'Skipped (not Sunday / backlog sufficient)');
        addJsonBlock('topics', j);
      } else if (topicsResp.status === 401) {
        addResult('topics', 'Weekly Topics', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('topics', 'Weekly Topics', 'warn', 'HTTP ' + topicsResp.status + ' — ' + (topicsResp.json?.error || topicsResp.text?.substring(0,100) || ''),
          topicsResp.status === 500 ? 'Topic research crashed. This cron uses AI to generate topics — check that AI API keys are configured and the <code>TopicProposal</code> table exists in Prisma.' :
          'Check Vercel Function Logs for <code>/api/cron/weekly-topics</code>.');
        if (topicsResp.json) addJsonBlock('topics', topicsResp.json);
      }
    } catch (e) { log('  ERROR in section 9: ' + e.message); addResult('topics', 'Weekly Topics', 'fail', 'JS Error: ' + e.message); }

    // ── 10. Trends Monitor ──
    log('  Testing trends-monitor...');
    addSection('trends', '10. Trends Monitor');
    try {
      const trendsResp = await testFetch('/api/cron/trends-monitor?healthcheck=true', { headers: cronHeaders });
      if (trendsResp.ok && trendsResp.json) {
        const j = trendsResp.json;
        addResult('trends', 'Trends Monitor', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('trends', 'Last Run', 'pass', new Date(j.lastRun.generatedAt).toLocaleString());
        if (j.monitoredKeywords) addResult('trends', 'Monitored Keywords', 'pass', j.monitoredKeywords + ' keywords tracked');
        addJsonBlock('trends', j);
      } else if (trendsResp.status === 401) {
        addResult('trends', 'Trends Monitor', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('trends', 'Trends Monitor', 'warn', 'HTTP ' + trendsResp.status + ' — ' + (trendsResp.json?.error || trendsResp.text?.substring(0,100) || ''),
          trendsResp.status === 500 ? 'Trends monitor crashed. It fetches RSS feeds and Google Trends data. Check <code>SERPAPI_API_KEY</code> env var and Vercel logs for <code>/api/cron/trends-monitor</code>.' :
          'Check Vercel Function Logs for details.');
        if (trendsResp.json) addJsonBlock('trends', trendsResp.json);
      }
    } catch (e) { log('  ERROR in section 10: ' + e.message); addResult('trends', 'Trends Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 11. Analytics Sync ──
    log('  Testing analytics sync...');
    addSection('analytics', '11. Analytics Sync');
    try {
      const analyticsResp = await testFetch('/api/cron/analytics', { headers: cronHeaders });
      if (analyticsResp.ok && analyticsResp.json) {
        const j = analyticsResp.json;
        addResult('analytics', 'Analytics Cron', 'pass', j.message || 'OK');
        if (j.reach !== undefined) addResult('analytics', 'Reach Count', 'pass', String(j.reach).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        if (j.pageViews !== undefined) addResult('analytics', 'Page Views', 'pass', String(j.pageViews).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        if (j.visitors !== undefined) addResult('analytics', 'Visitors', 'pass', String(j.visitors).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        addJsonBlock('analytics', j);
      } else if (analyticsResp.status === 401) {
        addResult('analytics', 'Analytics Cron', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('analytics', 'Analytics Cron', 'warn', 'HTTP ' + analyticsResp.status + ' — ' + (analyticsResp.json?.error || analyticsResp.text?.substring(0,100) || ''),
          analyticsResp.status === 500 ? 'Analytics sync crashed. Check: (1) <code>GA4_PROPERTY_ID</code> is set, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> + <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> are configured, (3) Service account has "Viewer" role on the GA4 property.' :
          'Check Vercel Function Logs for <code>/api/cron/analytics</code>.');
        if (analyticsResp.json) addJsonBlock('analytics', analyticsResp.json);
      }
    } catch (e) { log('  ERROR in section 11: ' + e.message); addResult('analytics', 'Analytics Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 12. SEO Agent ──
    log('  Testing SEO agent...');
    addSection('seoagent', '12. SEO Agent');
    try {
      const seoResp = await testFetch('/api/cron/seo-agent?healthcheck=true', { headers: cronHeaders });
      if (seoResp.ok && seoResp.json) {
        const j = seoResp.json;
        addResult('seoagent', 'SEO Agent', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('seoagent', 'Last Run', 'pass', j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        addJsonBlock('seoagent', j);
      } else if (seoResp.status === 401) {
        addResult('seoagent', 'SEO Agent', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('seoagent', 'SEO Agent', 'warn', 'HTTP ' + seoResp.status + ' — ' + (seoResp.json?.error || seoResp.text?.substring(0,100) || ''),
          seoResp.status === 500 ? 'SEO Agent crashed. This is the core 13-step agent. Check Vercel logs for <code>/api/cron/seo-agent</code>. Common causes: DB unreachable, missing GSC credentials, or the <code>SeoReport</code> / <code>BlogPost</code> tables have schema mismatches after a migration.' :
          'Check Vercel Function Logs for details.');
        if (seoResp.json) addJsonBlock('seoagent', seoResp.json);
      }
    } catch (e) { log('  ERROR in section 12: ' + e.message); addResult('seoagent', 'SEO Agent', 'fail', 'JS Error: ' + e.message); }

    // ── 13. SEO Daily Cron ──
    log('  Testing SEO daily cron...');
    try {
      const seoCronResp = await testFetch('/api/seo/cron?task=daily&healthcheck=true', { headers: cronHeaders });
      if (seoCronResp.ok && seoCronResp.json) {
        addResult('seoagent', 'SEO Daily Cron', 'pass', seoCronResp.json.message || 'OK');
      } else if (seoCronResp.status === 401) {
        addResult('seoagent', 'SEO Daily Cron', 'fail', 'HTTP 401');
      } else {
        addResult('seoagent', 'SEO Daily Cron', 'warn', 'HTTP ' + seoCronResp.status);
      }
    } catch (e) { log('  ERROR in section 13: ' + e.message); addResult('seoagent', 'SEO Daily Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 14. SEO Orchestrator ──
    log('  Testing SEO orchestrator...');
    addSection('orchestrator', '14. SEO Orchestrator');
    try {
      const orchResp = await testFetch('/api/cron/seo-orchestrator?healthcheck=true', { headers: cronHeaders });
      if (orchResp.ok && orchResp.json) {
        const j = orchResp.json;
        addResult('orchestrator', 'Orchestrator Status', 'pass', j.status === 'healthy' ? 'Healthy' : (j.status || 'OK'));
        if (j.lastRun) {
          addResult('orchestrator', 'Last Run', j.lastRun.status === 'error' ? 'fail' : 'pass',
            (j.lastRun.status || 'unknown') + (j.lastRun.at ? ' — ' + new Date(j.lastRun.at).toLocaleString() : ''));
          if (j.lastRun.healthScore !== undefined) addResult('orchestrator', 'Health Score', j.lastRun.healthScore >= 60 ? 'pass' : 'warn', j.lastRun.healthScore + '/100');
          if (j.lastRun.issuesFound !== undefined) addResult('orchestrator', 'Issues Found', j.lastRun.issuesFound > 10 ? 'warn' : 'pass', j.lastRun.issuesFound + ' issues');
          if (j.lastRun.fixesApplied !== undefined) addResult('orchestrator', 'Fixes Applied', 'pass', j.lastRun.fixesApplied + ' auto-fixes');
        }
        if (j.sites !== undefined) addResult('orchestrator', 'Sites Monitored', 'pass', j.sites + ' sites');
        addJsonBlock('orchestrator', j);
      } else if (orchResp.status === 401) {
        addResult('orchestrator', 'Orchestrator', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('orchestrator', 'Orchestrator', 'warn', 'HTTP ' + orchResp.status + ' — ' + (orchResp.json?.error || orchResp.text?.substring(0,150) || ''),
          orchResp.status === 500 ? 'Orchestrator crashed. This runs the 5-module system (live auditor, business goals, agent monitor, metrics collection, report storage). Check Vercel logs for <code>/api/cron/seo-orchestrator</code>. Most common cause: DB connection failure or missing <code>SiteHealthCheck</code> table.' :
          orchResp.status === 504 ? 'Timeout — the orchestrator audits all 5 sites sequentially and may exceed the function timeout. Check <code>maxDuration</code> in vercel.json (should be 120 for cron routes).' :
          'Check Vercel Function Logs for the full error.');
        if (orchResp.json) addJsonBlock('orchestrator', orchResp.json);
      }
    } catch (e) { log('  ERROR in section 14: ' + e.message); addResult('orchestrator', 'Orchestrator', 'fail', 'JS Error: ' + e.message); }

    // ── 15. Health Monitor (Cron Execution Proof) ──
    log('  Testing health monitor (cron log proof)...');
    addSection('healthmon', '15. Health Monitor — Cron Execution Proof');
    try {
      const hmResp = await testFetch('/api/admin/health-monitor', { headers: cronHeaders });
      if (hmResp.ok && hmResp.json) {
        const j = hmResp.json;
        // Database
        if (j.database) {
          addResult('healthmon', 'Database Connection', j.database.connected ? 'pass' : 'fail',
            j.database.connected ? 'Connected — ' + (j.database.latencyMs || '?') + 'ms latency' : (j.database.error || 'Disconnected'));
        }
        // Cron job status
        if (j.cronJobs && j.cronJobs.length > 0) {
          addResult('healthmon', 'Cron Jobs Tracked', 'pass', j.cronJobs.length + ' jobs in CronJobLog');
          const now = Date.now();
          for (const cron of j.cronJobs) {
            const ago = cron.lastRun ? Math.round((now - new Date(cron.lastRun).getTime()) / 3600000) : null;
            const agoStr = ago !== null ? ago + 'h ago' : 'never';
            const cronStatus = cron.status === 'completed' ? 'pass' : cron.status === 'failed' ? 'fail' : 'warn';
            addResult('healthmon', 'Cron: ' + cron.jobName, cronStatus,
              cron.status + ' — last: ' + agoStr + (cron.durationMs ? ' (' + cron.durationMs + 'ms)' : ''));
          }
        } else {
          addResult('healthmon', 'Cron Jobs', 'fail', 'No CronJobLog entries found — crons may not be executing',
            'The <code>cron_job_logs</code> table has zero entries. This means either: (1) No Vercel cron has fired yet — check Vercel Dashboard → project → Settings → Crons to see if they\'re scheduled, (2) The <code>CronJobLog</code> table doesn\'t exist — run <code>npx prisma db push</code> to sync the schema, or (3) The cron jobs are running but not using <code>logCronExecution()</code>.');
        }
        // Site health
        if (j.sites && j.sites.length > 0) {
          for (const site of j.sites) {
            const siteStatus = site.status === 'healthy' ? 'pass' : 'warn';
            addResult('healthmon', 'Site: ' + site.siteName, siteStatus,
              site.status + (site.healthScore !== null ? ' — score: ' + site.healthScore + '/100' : '') + ' (' + site.domain + ')',
              site.status === 'unknown' ? 'No health check data yet — the <code>site-health-check</code> cron has never run for this site. Once Vercel crons start executing, health scores will be populated automatically.' : undefined);
          }
        }
        // Indexing
        if (j.indexing) {
          const ix = j.indexing;
          addResult('healthmon', 'Indexing Status', ix.indexed > 0 ? 'pass' : 'warn',
            ix.indexed + '/' + ix.totalUrls + ' indexed (' + (ix.indexRate || 0) + '%) — ' + ix.submitted + ' submitted, ' + ix.errors + ' errors');
        }
        // Recent errors
        if (j.recentErrors && j.recentErrors.length > 0) {
          addResult('healthmon', 'Recent Errors (24h)', 'warn', j.recentErrors.length + ' errors');
          for (const err of j.recentErrors.slice(0, 5)) {
            addResult('healthmon', '  Error: ' + err.jobName, 'warn', err.error.substring(0, 120) + ' — ' + new Date(err.timestamp).toLocaleString());
          }
        } else if (j.recentErrors) {
          addResult('healthmon', 'Recent Errors (24h)', 'pass', 'None');
        }
        // Summary
        if (j.summary) {
          addResult('healthmon', 'Overall Summary', j.summary.failedCronJobs === 0 ? 'pass' : 'warn',
            j.summary.healthySites + '/' + j.summary.totalSites + ' healthy, ' +
            j.summary.failedCronJobs + ' failed crons, ' + j.summary.errorsLast24h + ' errors 24h');
        }
        addJsonBlock('healthmon', j);
      } else if (hmResp.status === 401 || hmResp.status === 403) {
        addResult('healthmon', 'Health Monitor', 'warn', 'Auth required — endpoint needs admin session cookie, not CRON_SECRET',
          'The <code>/api/admin/health-monitor</code> endpoint uses <code>withAdminAuth</code> which checks your NextAuth session cookie, not CRON_SECRET. Log into the admin dashboard first, then re-run this test in the same browser. Alternatively, access it directly while logged in: <code>/api/admin/health-monitor</code>.');
      } else {
        addResult('healthmon', 'Health Monitor', 'warn', 'HTTP ' + hmResp.status + ' — ' + (hmResp.json?.error || hmResp.text?.substring(0,100) || ''),
          hmResp.status === 500 ? 'Health monitor crashed. Check if the DB is reachable and the <code>CronJobLog</code>, <code>SiteHealthCheck</code>, and <code>URLIndexingStatus</code> tables exist.' :
          'Check Vercel Function Logs for <code>/api/admin/health-monitor</code>.');
        if (hmResp.json) addJsonBlock('healthmon', hmResp.json);
      }
    } catch (e) { log('  ERROR in section 15: ' + e.message); addResult('healthmon', 'Health Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 16. SEO Indexing Status ──
    log('  Testing SEO indexing status...');
    addSection('indexing', '16. SEO Indexing & Search Console');
    try {
      const idxResp = await testFetch('/api/admin/seo/indexing?type=stats', { headers: cronHeaders });
      if (idxResp.ok && idxResp.json) {
        const j = idxResp.json;
        const s = j.stats || {};
        addResult('indexing', 'Indexing Reports', j.success ? 'pass' : 'warn',
          s.totalReports + ' reports (' + s.totalSubmissions + ' submissions, ' + s.totalAudits + ' audits)');
        if (s.totalGoogleSubmitted !== undefined) addResult('indexing', 'Google API Submissions', s.totalGoogleSubmitted > 0 ? 'pass' : 'warn', s.totalGoogleSubmitted + ' URLs submitted');
        if (s.totalIndexNowSubmitted !== undefined) addResult('indexing', 'IndexNow Submissions', s.totalIndexNowSubmitted > 0 ? 'pass' : 'warn', s.totalIndexNowSubmitted + ' URLs submitted');
        if (s.lastSubmission) addResult('indexing', 'Last Submission', 'pass', new Date(s.lastSubmission).toLocaleString());
        if (s.latestSnapshot) {
          addResult('indexing', 'Indexed Pages', s.latestSnapshot.indexed > 0 ? 'pass' : 'warn',
            s.latestSnapshot.indexed + '/' + s.latestSnapshot.totalPages + ' indexed (' + s.latestSnapshot.notIndexed + ' not indexed)');
        }
        if (s.timeline && s.timeline.length > 0) {
          addResult('indexing', 'Recent Activity', 'pass', s.timeline.length + ' submissions in timeline');
        }
        addJsonBlock('indexing', j);
      } else if (idxResp.status === 401 || idxResp.status === 403) {
        addResult('indexing', 'Indexing API', 'warn', 'Needs admin auth');
      } else {
        addResult('indexing', 'Indexing API', 'warn', 'HTTP ' + idxResp.status);
        if (idxResp.json) addJsonBlock('indexing', idxResp.json);
      }
    } catch (e) { log('  ERROR in section 16: ' + e.message); addResult('indexing', 'Indexing', 'fail', 'JS Error: ' + e.message); }

    // ── 17. GA4 Server-Side Data (real proof of analytics) ──
    log('  Testing GA4 server-side data...');
    addSection('ga4server', '17. GA4 Server-Side Data API');
    try {
      const gaResp = await testFetch('/api/admin/analytics/ga4', { headers: cronHeaders });
      if (gaResp.ok && gaResp.json) {
        const j = gaResp.json;
        if (j.configured !== undefined) addResult('ga4server', 'GA4 Configured', j.configured ? 'pass' : 'fail', j.configured ? 'Credentials present' : 'Missing GA4_PROPERTY_ID or service account',
          !j.configured ? 'GA4 server-side data requires 3 env vars in Vercel: (1) <code>GA4_PROPERTY_ID</code> — your numeric GA4 property ID, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> — service account email, (3) <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> — the full private key (with <code>\\n</code> newlines). The service account must have "Viewer" role on the GA4 property in Google Analytics Admin → Property Access Management.' : undefined);
        if (j.metrics) {
          const m = j.metrics;
          addResult('ga4server', 'Sessions (30d)', m.sessions > 0 ? 'pass' : 'warn', m.sessions.toLocaleString());
          addResult('ga4server', 'Page Views (30d)', m.pageViews > 0 ? 'pass' : 'warn', m.pageViews.toLocaleString());
          addResult('ga4server', 'Users (30d)', m.totalUsers > 0 ? 'pass' : 'warn', m.totalUsers.toLocaleString());
          addResult('ga4server', 'Bounce Rate', m.bounceRate < 70 ? 'pass' : 'warn', m.bounceRate.toFixed(1) + '%');
          addResult('ga4server', 'Engagement Rate', m.engagementRate > 30 ? 'pass' : 'warn', m.engagementRate.toFixed(1) + '%');
        }
        if (j.topPages && j.topPages.length > 0) {
          addResult('ga4server', 'Top Pages', 'pass', j.topPages.slice(0,5).map(p => p.path + ' (' + p.pageViews + ' views)').join(', '));
        }
        if (j.topSources && j.topSources.length > 0) {
          addResult('ga4server', 'Top Traffic Sources', 'pass', j.topSources.slice(0,5).map(s => s.source + ' (' + s.sessions + ')').join(', '));
        }
        addJsonBlock('ga4server', j);
      } else if (gaResp.status === 401 || gaResp.status === 403) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Needs admin auth',
          'This endpoint uses admin auth. Log into the admin dashboard first, then revisit. The GA4 data is still fetched by crons even if this admin endpoint needs auth.');
      } else if (gaResp.status === 404) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Endpoint not found — /api/admin/analytics/ga4 may not exist',
          'No dedicated GA4 admin endpoint exists. GA4 data is fetched internally by the SEO agent and analytics cron via <code>lib/seo/ga4-data-api.ts</code>. You can verify it works by checking the SEO Agent report (section 12) which includes <code>trafficAnalysis</code> data from GA4.');
      } else {
        addResult('ga4server', 'GA4 Data API', 'warn', 'HTTP ' + gaResp.status,
          gaResp.status === 500 ? 'GA4 API call failed. Check: (1) <code>GA4_PROPERTY_ID</code> is correct, (2) service account private key doesn\'t have encoding issues (\\n vs actual newlines), (3) service account email has GA4 property access.' :
          'Check Vercel Function Logs.');
        if (gaResp.json) addJsonBlock('ga4server', gaResp.json);
      }
    } catch (e) { log('  ERROR in section 17: ' + e.message); addResult('ga4server', 'GA4 Data API', 'fail', 'JS Error: ' + e.message); }

    // ── 18. Blog Content Audit (proof content generator works) ──
    log('  Testing blog content audit...');
    addSection('blogaudit', '18. Blog Content Audit — Auto-Generated Proof');
    try {
      const blogResp = await testFetch('/api/blog?limit=20&sort=created_at:desc');
      if (blogResp.ok && blogResp.json) {
        const posts = blogResp.json.posts || blogResp.json.data || (Array.isArray(blogResp.json) ? blogResp.json : []);
        const total = blogResp.json.total || blogResp.json.count || posts.length;
        addResult('blogaudit', 'Total Posts', total > 0 ? 'pass' : 'warn', total + ' published blog posts in database',
          total === 0 ? 'Zero published blog posts in the database. Click <strong>"Seed Static Articles → DB"</strong> to import the 23 static articles into the database. Once seeded, the SEO agent, indexing pipeline, and CMS will manage them automatically.' : undefined);

        let autoGen = 0, withMeta = 0, withAr = 0, withSchema = 0, recentCount = 0;
        const now = Date.now();
        const sevenDays = 7 * 24 * 60 * 60 * 1000;

        for (const p of posts) {
          if (p.tags && Array.isArray(p.tags) && p.tags.includes('auto-generated')) autoGen++;
          if (p.meta_title_en || p.meta_description_en) withMeta++;
          if (p.content_ar && p.content_ar !== null && !p.content_ar.startsWith('[0 ')) withAr++;
          if (p.authority_links_json || p.keywords_json) withSchema++;
          if (p.created_at && (now - new Date(p.created_at).getTime()) < sevenDays) recentCount++;
        }

        addResult('blogaudit', 'Auto-Generated Posts', autoGen > 0 ? 'pass' : 'warn',
          autoGen + '/' + posts.length + ' posts have "auto-generated" tag (content pipeline proof)',
          autoGen === 0 ? 'No posts have the <code>auto-generated</code> tag. This means the daily content generation cron (<code>/api/cron/daily-content-generate</code>) hasn\'t successfully created any posts. Check: (1) Vercel cron schedule is active, (2) AI API key is set, (3) The cron healthcheck (section 7) shows a recent successful run.' : undefined);
        addResult('blogaudit', 'Posts with Meta Tags', withMeta > 0 ? 'pass' : 'warn',
          withMeta + '/' + posts.length + ' have SEO meta titles/descriptions');
        addResult('blogaudit', 'Arabic Content', withAr > 0 ? 'pass' : 'warn',
          withAr + '/' + posts.length + ' have Arabic content (>100 chars)');
        addResult('blogaudit', 'SEO Data (keywords/schema)', withSchema > 0 ? 'pass' : 'warn',
          withSchema + '/' + posts.length + ' have keywords or schema data');
        addResult('blogaudit', 'Recent Posts (7d)', recentCount > 0 ? 'pass' : 'warn',
          recentCount + ' posts created in last 7 days',
          recentCount === 0 ? 'No posts in the last 7 days. The daily content cron should create 2 posts per site per day (10 total). Check Vercel → Settings → Crons to confirm <code>/api/cron/daily-content-generate</code> is scheduled at 5:00 UTC daily and has recent executions.' : undefined);

        // Show latest 3 posts
        for (const p of posts.slice(0, 3)) {
          const age = p.created_at ? Math.round((now - new Date(p.created_at).getTime()) / 3600000) + 'h ago' : '?';
          const tags = (p.tags || []).join(', ');
          addResult('blogaudit', 'Post: ' + (p.title_en || p.slug || '').substring(0, 50), 'pass',
            age + ' | seo:' + (p.seo_score || '?') + ' | tags: ' + tags.substring(0, 80));
        }
        addJsonBlock('blogaudit', { total, sample: posts.slice(0, 3) });
      } else if (blogResp.status === 404) {
        addResult('blogaudit', 'Blog API', 'warn', 'No public /api/blog endpoint — test via admin');
      } else {
        addResult('blogaudit', 'Blog API', 'warn', 'HTTP ' + blogResp.status);
      }
    } catch (e) { log('  ERROR in section 18: ' + e.message); addResult('blogaudit', 'Blog Audit', 'fail', 'JS Error: ' + e.message); }

    // ── 19. SEO Reports (proof orchestrator writes to DB) ──
    log('  Testing SEO reports...');
    addSection('seoreports', '19. SEO Reports — Orchestrator Output Proof');
    try {
      const reportResp = await testFetch('/api/admin/seo/reports?limit=5', { headers: cronHeaders });
      if (reportResp.ok && reportResp.json) {
        const reports = reportResp.json.reports || reportResp.json.data || (Array.isArray(reportResp.json) ? reportResp.json : []);
        addResult('seoreports', 'SEO Reports in DB', reports.length > 0 ? 'pass' : 'warn', reports.length + ' reports found');
        for (const r of reports.slice(0, 5)) {
          const age = r.generatedAt ? Math.round((Date.now() - new Date(r.generatedAt).getTime()) / 3600000) + 'h ago' : '?';
          const score = r.data?.health_score || r.data?.healthScore || '?';
          addResult('seoreports', r.reportType + ' report', 'pass',
            age + ' | score: ' + score + ' | site: ' + (r.site_id || 'all'));
        }
        if (reports.length > 0) addJsonBlock('seoreports', reports[0]);
      } else if (reportResp.status === 401 || reportResp.status === 403) {
        addResult('seoreports', 'SEO Reports', 'warn', 'Needs admin auth — try admin session');
      } else if (reportResp.status === 404) {
        addResult('seoreports', 'SEO Reports', 'warn', 'No /api/admin/seo/reports endpoint');
      } else {
        addResult('seoreports', 'SEO Reports', 'warn', 'HTTP ' + reportResp.status);
        if (reportResp.json) addJsonBlock('seoreports', reportResp.json);
      }
    } catch (e) { log('  ERROR in section 19: ' + e.message); addResult('seoreports', 'SEO Reports', 'fail', 'JS Error: ' + e.message); }

    // ── 20. Yalla London Site Health Check ──
    log('  Testing Yalla London site health...');
    addSection('multisite', '20. Yalla London Site Health');
    try {
      const siteResp = await testFetch('/api/admin/sites/yalla-london/health', { headers: cronHeaders });
      if (siteResp.ok && siteResp.json) {
        const j = siteResp.json;
        const score = j.healthScore ?? '?';
        const statusCls = j.status === 'healthy' ? 'pass' : j.status === 'degraded' ? 'warn' : j.status === 'down' ? 'fail' : 'warn';
        addResult('multisite', j.siteName || 'Yalla London', statusCls,
          j.status + ' — score: ' + score + '/100' +
          (j.indexing ? ' | indexed: ' + j.indexing.indexed + '/' + j.indexing.totalUrls : '') +
          (j.content ? ' | posts: ' + j.content.publishedPosts + '/' + j.content.totalPosts : '') +
          ' (' + (j.domain || 'yalla-london.com') + ')');
        if (j.crons7d) {
          addResult('multisite', 'Crons (7d)', j.crons7d.failed === 0 ? 'pass' : 'warn',
            j.crons7d.completed + ' completed, ' + j.crons7d.failed + ' failed, ' + j.crons7d.timedOut + ' timed out');
        }
        if (j.seo) {
          addResult('multisite', 'SEO Indexing', j.seo.indexed_pages > 0 ? 'pass' : 'warn',
            j.seo.indexed_pages + '/' + j.seo.total_pages + ' pages indexed (' + (j.seo.indexing_rate || 0) + '%)');
        }
        addJsonBlock('multisite', j);
      } else if (siteResp.status === 404) {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP 404 — site health endpoint not found',
          'The <code>/api/admin/sites/yalla-london/health</code> route returned 404. This endpoint may not be deployed yet. Ensure the route exists at <code>app/api/admin/sites/[siteId]/health/route.ts</code> and redeploy.');
      } else {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP ' + siteResp.status + ' — ' + (siteResp.errorDetail || ''));
      }
    } catch (e) { log('  ERROR in section 20: ' + e.message); addResult('multisite', 'Site Health', 'fail', 'JS Error: ' + e.message); }

    // ── 21. Content & Indexing Deep Audit ──
    log('  Running content & indexing deep audit...');
    addSection('contentaudit', '21. Content & Indexing Deep Audit');
    try {
      const auditResp = await testFetch('/api/admin/content-audit', { headers: cronHeaders });
      if (auditResp.ok && auditResp.json) {
        const j = auditResp.json;
        const s = j.summary;

        // Global totals
        addResult('contentaudit', 'Total Articles/Posts', s.totalPosts > 0 ? 'pass' : 'warn',
          s.totalPosts + ' total (' + s.totalPublished + ' published, ' + s.totalDrafts + ' drafts)',
          s.totalPosts === 0 ? 'No blog posts yet. The content generation cron needs to run successfully to create posts. This is normal for a fresh deployment.' : undefined);

        addResult('contentaudit', 'URLs Tracked for Indexing', s.totalTrackedUrls > 0 ? 'pass' : 'warn',
          s.totalTrackedUrls + ' URLs in URLIndexingStatus table',
          s.totalTrackedUrls === 0 ? 'No URLs being tracked for indexing. The SEO agent should create URL tracking entries when it runs. Check section 12 (SEO Agent) for status.' : undefined);

        addResult('contentaudit', 'Indexing Requested (Submitted)', s.totalSubmittedPending > 0 || s.totalIndexed > 0 ? 'pass' : 'warn',
          (s.totalSubmittedPending + s.totalIndexed) + ' URLs submitted to Google/IndexNow (' + s.totalSubmittedPending + ' pending, ' + s.totalIndexed + ' confirmed indexed)',
          s.totalSubmittedPending === 0 && s.totalIndexed === 0 ? 'No URLs have been submitted for indexing. Check that <code>INDEXNOW_KEY</code> is set and the SEO agent is running. The agent submits URLs via IndexNow and Google Indexing API.' : undefined);

        addResult('contentaudit', 'Confirmed Indexed in Google', s.totalIndexed > 0 ? 'pass' : 'warn',
          s.totalIndexed + ' pages confirmed indexed (' + s.indexRate + '% index rate)',
          s.totalIndexed === 0 ? 'Zero pages confirmed indexed. This is normal for new sites — Google can take days to weeks to index pages. The SEO agent checks via GSC URL Inspection API. Ensure GSC service account credentials are configured.' : undefined);

        addResult('contentaudit', 'Indexing Errors', s.totalErrors === 0 ? 'pass' : 'warn',
          s.totalErrors + ' URLs with indexing errors',
          s.totalErrors > 0 ? 'Some URLs failed indexing submission. See the error details below for specific causes.' : undefined);

        addResult('contentaudit', 'Untracked Published Posts', s.totalUntracked === 0 ? 'pass' : 'warn',
          s.totalUntracked + ' published posts not yet tracked in URLIndexingStatus',
          s.totalUntracked > 0 ? 'These published posts have no entry in the URL tracking table. The SEO agent should pick them up on its next run and create tracking entries + submit them for indexing.' : undefined);

        // Per-site breakdown
        if (j.perSite && j.perSite.length > 0) {
          for (const site of j.perSite) {
            const ix = site.indexing || {};
            addResult('contentaudit', site.siteName + ' (' + site.domain + ')',
              ix.indexed > 0 ? 'pass' : site.published > 0 ? 'warn' : 'warn',
              site.published + ' published, ' + site.drafts + ' drafts | indexed: ' + ix.indexed + '/' + ix.total + ' (' + ix.indexRate + '%) | submitted: ' + ix.submitted + ' | errors: ' + ix.error);

            // Show not-indexed reasons for this site
            if (site.notIndexedReasons && site.notIndexedReasons.length > 0) {
              for (const r of site.notIndexedReasons) {
                addResult('contentaudit', '  ↳ Not indexed: ' + r.reason, 'warn', r.count + ' URLs',
                  r.reason.includes('not indexed') ? 'Google crawled the page but decided not to index it. Common reasons: thin content (<300 words), duplicate content, low-quality content, or noindex tag. Check Google Search Console → Pages for details.' :
                  r.reason.includes('discovered') ? 'Google knows the page exists but hasn\'t crawled it yet. This is normal for new pages — give it time or request indexing via GSC.' :
                  r.reason.includes('redirect') ? 'Page redirects to another URL. Check for broken redirect chains.' :
                  r.reason.includes('blocked') ? 'Page is blocked by robots.txt or a noindex meta tag. Check the page\'s robots directives.' :
                  'GSC coverage state: ' + r.reason + '. Check Google Search Console → Pages → this specific status for detailed information.');
              }
            }
          }
        }

        // Stuck pages (submitted >7 days ago, still not indexed)
        if (j.stuckPages && j.stuckPages.length > 0) {
          addResult('contentaudit', 'Stuck Pages (submitted >7d ago, not indexed)', 'warn', j.stuckPages.length + ' pages');
          for (const p of j.stuckPages.slice(0, 10)) {
            const daysAgo = Math.round((Date.now() - new Date(p.submittedAt).getTime()) / 86400000);
            addResult('contentaudit', '  ↳ ' + (p.slug || p.url).substring(0, 50), 'warn',
              daysAgo + 'd since submission | attempts: ' + p.attempts + ' | GSC: ' + (p.coverageState || 'unknown'),
              'This page was submitted ' + daysAgo + ' days ago but still isn\'t indexed. Try: (1) Resubmit via GSC "Request Indexing", (2) Check if page returns 200 status, (3) Ensure content is high-quality (>1200 words), (4) Add internal links to this page from indexed pages.');
          }
        } else if (j.stuckPages) {
          addResult('contentaudit', 'Stuck Pages', 'pass', 'None — all submitted pages are progressing');
        }

        // URL errors
        if (j.urlErrors && j.urlErrors.length > 0) {
          addResult('contentaudit', 'URLs with Errors', 'warn', j.urlErrors.length + ' errors');
          for (const e of j.urlErrors.slice(0, 10)) {
            addResult('contentaudit', '  ↳ ' + (e.slug || e.url).substring(0, 50), 'fail',
              'Error: ' + (e.error || 'unknown').substring(0, 100) + ' | attempts: ' + e.attempts,
              'This URL failed indexing. Error: <code>' + escapeHtml((e.error || '').substring(0, 150)) + '</code>. Check if the URL returns HTTP 200 and has proper content.');
          }
        } else if (j.urlErrors) {
          addResult('contentaudit', 'URL Errors', 'pass', 'None');
        }

        // Untracked posts
        if (j.untrackedPosts && j.untrackedPosts.length > 0) {
          addResult('contentaudit', 'Untracked Published Posts', 'warn', j.untrackedPosts.length + ' posts not in URL tracker');
          for (const p of j.untrackedPosts.slice(0, 5)) {
            addResult('contentaudit', '  ↳ ' + (p.title || p.slug).substring(0, 50), 'warn',
              p.siteId + ' — created: ' + new Date(p.createdAt).toLocaleDateString(),
              'This published post has no URL tracking entry. The SEO agent will pick it up on its next run. To force immediate tracking, trigger the SEO agent manually.');
          }
        }

        addJsonBlock('contentaudit', { summary: j.summary, perSite: j.perSite });
      } else if (auditResp.status === 401 || auditResp.status === 403) {
        addResult('contentaudit', 'Content Audit', 'fail', 'HTTP ' + auditResp.status + ' — auth failed');
      } else {
        addResult('contentaudit', 'Content Audit', 'warn', 'HTTP ' + auditResp.status + ' — ' + (auditResp.json?.error || auditResp.text?.substring(0,150) || ''));
        if (auditResp.json) addJsonBlock('contentaudit', auditResp.json);
      }
    } catch (e) { log('  ERROR in section 21: ' + e.message); addResult('contentaudit', 'Content Audit', 'fail', 'JS Error: ' + e.message); }

  } else if (testMode === 'full' && !cronSecret) {
    addSection('pipeline', '7. Content Generation Pipeline');
    addResult('pipeline', 'Pipeline Tests', 'fail', 'Enter CRON_SECRET above and re-run');
  }

  // ── Auto-scan for missing tables (after all tests) ──
  if (testMode === 'full' && cronSecret) {
    // Wait 3s to let DB connection pool drain from previous tests
    log('  Waiting 3s for connection pool to drain...');
    await new Promise(r => setTimeout(r, 3000));
    log('  Auto-scanning database schema for missing tables/columns...');
    addSection('dbcheck', '22. Database Schema Health');
    try {
      const dbScanResp = await testFetch('/api/admin/db-migrate', {
        headers: { 'Authorization': 'Bearer ' + cronSecret },
      });
      if (dbScanResp.ok && dbScanResp.json) {
        const j = dbScanResp.json;
        const s = j.summary || {};
        if (s.needsMigration) {
          addResult('dbcheck', 'Schema Sync', 'fail',
            s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
            'Database schema is out of sync with the Prisma models. This causes runtime errors like <strong>P2022 (column does not exist)</strong> or <strong>P2021 (table does not exist)</strong>. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page to resolve, or run <code>npx prisma db push</code> on the server.');
          if (j.missingTables) {
            for (const t of j.missingTables) {
              addResult('dbcheck', 'Missing: ' + t.table, 'fail', 'Model: ' + t.model + ' — table needs to be created',
                'Table <code>' + escapeHtml(t.table) + '</code> does not exist. Any API route that queries <code>prisma.' + escapeHtml(t.model.charAt(0).toLowerCase() + t.model.slice(1)) + '</code> will throw <strong>P2021: The table does not exist in the current database</strong>. Routes affected include any cron job, page, or API route that imports this model.');
            }
          }
          if (j.missingColumns) {
            for (const c of j.missingColumns) {
              addResult('dbcheck', 'Missing: ' + c.table + '.' + c.column, 'fail', c.type + ' — column needs to be added',
                'Column <code>' + escapeHtml(c.column) + '</code> is missing from table <code>' + escapeHtml(c.table) + '</code>. Any query that filters by, selects, or sorts on this column will throw <strong>P2022: The column does not exist</strong>. This is the root cause of many HTTP 500 errors in cron jobs and API routes.');
            }
          }
        } else {
          addResult('dbcheck', 'Schema Sync', 'pass', 'All ' + j.existingTables.length + ' tables and checked columns are in sync');
        }
        addJsonBlock('dbcheck', { summary: s, existingTables: j.existingTables?.length, missingTables: j.missingTables, missingColumns: j.missingColumns });
      } else if (dbScanResp.status === 401) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Auth failed — CRON_SECRET may be wrong');
      } else if (dbScanResp.status === 404) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Endpoint /api/admin/db-migrate not deployed yet — redeploy to enable',
          'The database schema scan endpoint has not been deployed yet. Push the latest code and redeploy on Vercel to enable this feature.');
      } else {
        addResult('dbcheck', 'Schema Scan', 'warn', 'HTTP ' + dbScanResp.status + ' — ' + (dbScanResp.json?.error || dbScanResp.text?.substring(0, 150) || ''));
        if (dbScanResp.json) addJsonBlock('dbcheck', dbScanResp.json);
      }
    } catch (e) { log('  ERROR in section 22: ' + e.message); addResult('dbcheck', 'Schema Scan', 'warn', 'JS Error: ' + e.message); }
  }

  // ── Final Status ──
  log('All tests complete: ' + pass + ' passed, ' + warn + ' warnings, ' + fail + ' failed');

  const banner = document.getElementById('statusBanner');
  if (fail === 0 && warn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL SYSTEMS GO</div>';
  } else if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-warn">OPERATIONAL — ' + warn + ' warning(s)</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' ISSUE(S) NEED ATTENTION</div>';
  }

  // ── Generate Copiable JSON Test Result ──
  renderJsonResult();

  document.getElementById('runBtn').disabled = false;
  document.getElementById('runBtn').textContent = 'Run All Tests Again';
}

function renderJsonResult() {
  const jsonResult = {
    timestamp: new Date().toISOString(),
    mode: testMode,
    summary: { passed: pass, warnings: warn, failed: fail, total: pass + warn + fail },
    results: allResults,
  };
  const jsonStr = JSON.stringify(jsonResult, null, 2);

  // Remove any existing JSON export section
  const existing = document.getElementById('section-jsonexport');
  if (existing) existing.remove();

  const html = `<div class="section" id="section-jsonexport">
    <h2>Test Results — Copiable JSON</h2>
    <p style="color:#888;font-size:0.8rem;margin-bottom:8px;">Click the text area below and press Ctrl+A then Ctrl+C to copy, or use the Copy button.</p>
    <button onclick="copyJsonResult()" style="margin:0 0 12px;padding:8px 20px;font-size:0.85rem;background:#7c3aed;">Copy JSON to Clipboard</button>
    <textarea id="jsonResultArea" readonly style="width:100%;height:300px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.75rem;resize:vertical;">${escapeHtml(jsonStr)}</textarea>
  </div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function copyJsonResult() {
  const area = document.getElementById('jsonResultArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = event.target;
    btn.textContent = 'Copied!';
    btn.style.background = '#16a34a';
    setTimeout(() => { btn.textContent = 'Copy JSON to Clipboard'; btn.style.background = '#7c3aed'; }, 2000);
  }).catch(() => {
    // Fallback for older browsers
    document.execCommand('copy');
  });
}
</script>
</body>
</html>
