<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yalla London — Connection Validator</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 20px; }
  h1 { text-align: center; margin-bottom: 8px; font-size: 1.6rem; color: #fff; }
  .subtitle { text-align: center; color: #888; margin-bottom: 24px; font-size: 0.9rem; }
  .section { background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; }
  .section h2 { font-size: 1rem; color: #aaa; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
  .test-row { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #1a1a1a; }
  .test-row:last-child { border-bottom: none; }
  .test-name { flex: 1; font-size: 0.9rem; }
  .test-status { font-size: 0.85rem; font-weight: 600; min-width: 100px; text-align: right; }
  .pass { color: #4ade80; }
  .fail { color: #f87171; }
  .warn { color: #fbbf24; }
  .pending { color: #666; }
  .detail { color: #888; font-size: 0.8rem; margin-top: 2px; word-break: break-all; }
  .summary-bar { display: flex; gap: 24px; justify-content: center; padding: 16px; background: #141414; border: 1px solid #2a2a2a; border-radius: 12px; margin-bottom: 16px; }
  .summary-item { text-align: center; }
  .summary-num { font-size: 2rem; font-weight: 700; }
  .summary-label { font-size: 0.75rem; color: #888; text-transform: uppercase; }
  .status-banner { text-align: center; padding: 16px; border-radius: 12px; font-size: 1.1rem; font-weight: 700; margin-top: 16px; }
  .status-ok { background: #052e16; border: 1px solid #166534; color: #4ade80; }
  .status-warn { background: #422006; border: 1px solid #92400e; color: #fbbf24; }
  .status-fail { background: #450a0a; border: 1px solid #991b1b; color: #f87171; }
  button { background: #2563eb; color: white; border: none; padding: 12px 32px; border-radius: 8px; font-size: 1rem; cursor: pointer; display: block; margin: 0 auto 20px; }
  button:hover { background: #1d4ed8; }
  button:disabled { background: #333; color: #666; cursor: not-allowed; }
  .cron-input { background: #1a1a1a; border: 1px solid #333; color: #e0e0e0; padding: 8px 12px; border-radius: 6px; width: 100%; margin-bottom: 12px; font-family: monospace; }
  .cron-input::placeholder { color: #555; }
  .log { background: #0a0a0a; border: 1px solid #222; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; max-height: 300px; overflow-y: auto; margin-top: 12px; white-space: pre-wrap; color: #888; }
  .json-block { background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 12px; font-family: monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; margin-top: 8px; white-space: pre-wrap; color: #7ee787; }
  .diag { background: #1a0000; border: 1px solid #4a1a1a; border-radius: 6px; padding: 8px 12px; margin-top: 6px; font-size: 0.78rem; color: #fca5a5; }
  .diag strong { color: #f87171; }
  .diag code { background: #2a1010; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.75rem; }
  .diag-warn { background: #1a1400; border-color: #4a3a1a; color: #fde68a; }
  .diag-warn strong { color: #fbbf24; }
  .diag-warn code { background: #2a2010; }
  .tab-bar { display: flex; gap: 8px; margin-bottom: 16px; justify-content: center; flex-wrap: wrap; }
  .tab-btn { background: #1a1a1a; border: 1px solid #333; color: #888; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
  .tab-btn.active { background: #2563eb; color: white; border-color: #2563eb; }
</style>
</head>
<body>

<h1>Yalla London — System Validator</h1>
<p class="subtitle">Full pipeline test: GA4, Assets, Pages, SEO, Crons, Database, AI, Content, Orchestrator, Indexing, Site Health, Schema Audit (22 sections) + One-Click DB Migration + Copiable JSON Export</p>

<div class="tab-bar">
  <button class="tab-btn active" onclick="switchMode('quick')">Quick Test</button>
  <button class="tab-btn" onclick="switchMode('full')">Full Pipeline Test (needs CRON_SECRET)</button>
</div>

<div class="section" id="cronSection" style="display:none">
  <h2>Authentication</h2>
  <input type="password" id="cronSecret" class="cron-input" placeholder="Enter your CRON_SECRET to test cron endpoints and content pipeline...">
</div>

<div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-bottom:20px;">
  <button id="runBtn" onclick="runAllTests()">Run All Tests</button>
  <button id="scanBtn" onclick="scanDatabase()" style="background:#7c3aed;">Scan Missing Tables/Columns</button>
  <button id="migrateBtn" onclick="migrateDatabase()" style="background:#dc2626;">Fix Missing Tables &amp; Columns</button>
  <button id="seedBtn" onclick="seedStaticContent()" style="background:#059669;">Seed Static Articles → DB</button>
  <button id="jobsBtn" onclick="runAllJobs()" style="background:#d97706;">Run All Cron Jobs</button>
</div>

<div class="summary-bar">
  <div class="summary-item"><div class="summary-num pass" id="passCount">-</div><div class="summary-label">Passed</div></div>
  <div class="summary-item"><div class="summary-num warn" id="warnCount">-</div><div class="summary-label">Warnings</div></div>
  <div class="summary-item"><div class="summary-num fail" id="failCount">-</div><div class="summary-label">Failed</div></div>
</div>

<div id="results"></div>
<div id="statusBanner"></div>

<div class="section" style="margin-top:16px">
  <h2>Live Log</h2>
  <div class="log" id="log"></div>
</div>

<script>
let pass = 0, fail = 0, warn = 0;
let testMode = 'quick';
let allResults = []; // Collect all results for JSON export

function switchMode(mode) {
  testMode = mode;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-btn')[mode === 'quick' ? 0 : 1].classList.add('active');
  document.getElementById('cronSection').style.display = mode === 'full' ? 'block' : 'none';
}

function log(msg) {
  const el = document.getElementById('log');
  el.textContent += new Date().toISOString().substring(11,19) + ' ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}

function addSection(id, title) {
  const html = `<div class="section" id="section-${id}"><h2>${title}</h2><div id="tests-${id}"></div></div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function addResult(sectionId, name, status, detail, diagnostic) {
  if (status === 'pass') pass++;
  else if (status === 'fail') fail++;
  else warn++;

  // Track for JSON export
  allResults.push({ section: sectionId, name, status, detail: detail || null });

  const cls = status === 'pass' ? 'pass' : status === 'fail' ? 'fail' : 'warn';
  const icon = status === 'pass' ? '\u2713' : status === 'fail' ? '\u2717' : '\u26A0';
  const safeDetail = detail ? escapeHtml(String(detail)) : '';

  // Auto-diagnose common error patterns if no diagnostic provided
  let autoDiag = diagnostic || '';
  if (!diagnostic && status !== 'pass' && safeDetail) {
    const d = safeDetail.toLowerCase();
    if (d.includes('p2022') || d.includes('column') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2022:</strong> A column referenced in the query does not exist in the database. The Prisma schema defines it but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page, or run <code>npx prisma db push</code>.';
    } else if (d.includes('p2021') || d.includes('table') && d.includes('does not exist')) {
      autoDiag = '<strong>Prisma P2021:</strong> The table does not exist in the database. The model is defined in <code>prisma/schema.prisma</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page.';
    } else if (d.includes('p2002') || d.includes('unique constraint')) {
      autoDiag = '<strong>Prisma P2002:</strong> Unique constraint violation — a record with this value already exists. This usually means duplicate data or a re-run of a cron that already created this record.';
    } else if (d.includes('p1001') || d.includes('can\'t reach database') || d.includes('connection refused')) {
      autoDiag = '<strong>Database unreachable:</strong> The database server is not responding. Check that <code>DATABASE_URL</code> in Vercel env vars points to a running Supabase/PostgreSQL instance. If using Supabase, check that the project is not paused (free tier pauses after 7 days of inactivity).';
    } else if (d.includes('p1008') || d.includes('timed out')) {
      autoDiag = '<strong>Database timeout:</strong> The query took too long. This may be a cold start issue, a slow query, or the connection pool is exhausted. Check Supabase dashboard for connection count.';
    } else if (d.includes('type error') || d.includes('typeerror')) {
      autoDiag = '<strong>JavaScript TypeError:</strong> A code error is preventing this route from executing. Common causes: (1) A missing or misnamed import, (2) A function being called on <code>undefined</code>, (3) A build-time error that broke the serverless function chunk. Check Vercel Function Logs for the full stack trace.';
    } else if (d.includes('maxclientsinsessionmode') || d.includes('max clients reached') || d.includes('pool_size')) {
      autoDiag = '<strong>Connection Pool Exhausted:</strong> Supabase reached its connection limit. This happens when many API calls run in quick succession. Wait 30 seconds and retry, or increase the pool size in Supabase Dashboard → Settings → Database → Connection Pooling.';
    } else if (d.includes('http 0') || d.includes('failed to fetch') || d.includes('networkerror')) {
      autoDiag = '<strong>Network Error (HTTP 0):</strong> The request never reached the server. Causes: (1) The serverless function failed to load (build error), (2) Vercel is redeploying, (3) CORS or firewall blocking. Check Vercel deployment status and Function Logs.';
    } else if (d.includes('500')) {
      autoDiag = '<strong>HTTP 500 — Server Error:</strong> The route handler crashed. Check Vercel Function Logs for this specific path to see the full error and stack trace.';
    }
  }

  let diagHtml = '';
  if (autoDiag && status !== 'pass') {
    const diagCls = status === 'fail' ? 'diag' : 'diag diag-warn';
    diagHtml = `<div class="${diagCls}"><strong>Diagnosis:</strong> ${autoDiag}</div>`;
  }
  const html = `<div class="test-row">
    <div><div class="test-name">${escapeHtml(name)}</div>${safeDetail ? `<div class="detail">${safeDetail}</div>` : ''}${diagHtml}</div>
    <div class="test-status ${cls}">${icon} ${status.toUpperCase()}</div>
  </div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
  updateSummary();
}

function escapeHtml(str) {
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function addJsonBlock(sectionId, data) {
  const escaped = escapeHtml(JSON.stringify(data, null, 2));
  const html = `<div class="json-block">${escaped}</div>`;
  document.getElementById('tests-' + sectionId).insertAdjacentHTML('beforeend', html);
}

function updateSummary() {
  document.getElementById('passCount').textContent = pass;
  document.getElementById('warnCount').textContent = warn;
  document.getElementById('failCount').textContent = fail;
}

async function testFetch(url, options = {}) {
  try {
    const resp = await fetch(url, { ...options, signal: AbortSignal.timeout(30000) });
    const text = await resp.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}
    // For non-OK responses, extract the most useful error detail
    let errorDetail = '';
    if (!resp.ok) {
      if (json?.error) errorDetail = json.error;
      else if (json?.message) errorDetail = json.message;
      else if (text.length < 500) errorDetail = text;
      else errorDetail = text.substring(0, 500);
    }
    return { ok: resp.ok, status: resp.status, text, json, headers: resp.headers, errorDetail };
  } catch (e) {
    return { ok: false, status: 0, text: e.message, json: null, error: e, errorDetail: e.message };
  }
}

// ─── Database Scan / Migrate ──────────────────────────────────────────
function getCronSecret() {
  return document.getElementById('cronSecret')?.value || '';
}

async function scanDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  document.getElementById('scanBtn').disabled = true;
  document.getElementById('scanBtn').textContent = 'Scanning...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbscan', 'Database Schema Scan — Missing Tables & Columns');
  log('Scanning database for missing tables and columns...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const s = j.summary || {};

      // Overall status
      if (s.needsMigration) {
        addResult('dbscan', 'Schema Status', 'fail',
          s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
          'Your database is out of sync with the Prisma schema. Click <strong>"Fix Missing Tables & Columns"</strong> to create the missing items automatically. This is safe — it only adds new tables/columns and never deletes existing data.');
      } else {
        addResult('dbscan', 'Schema Status', 'pass', 'All expected tables and columns exist');
      }

      // Missing tables
      if (j.missingTables && j.missingTables.length > 0) {
        for (const t of j.missingTables) {
          addResult('dbscan', 'Missing Table: ' + t.table, 'fail',
            'Prisma model ' + t.model + ' has no corresponding table in the database',
            'The <code>' + escapeHtml(t.table) + '</code> table needs to be created. This table is defined in <code>prisma/schema.prisma</code> as model <code>' + escapeHtml(t.model) + '</code> but the migration was never run. Click <strong>"Fix Missing Tables & Columns"</strong> to create it.');
        }
      }

      // Missing columns
      if (j.missingColumns && j.missingColumns.length > 0) {
        for (const c of j.missingColumns) {
          addResult('dbscan', 'Missing Column: ' + c.table + '.' + c.column, 'fail',
            'Type: ' + c.type + ' — model ' + c.model,
            'Column <code>' + escapeHtml(c.column) + '</code> (' + escapeHtml(c.type) + ') is defined in the Prisma schema for model <code>' + escapeHtml(c.model) + '</code> but doesn\'t exist in the actual database table <code>' + escapeHtml(c.table) + '</code>. This will cause runtime errors (Prisma error P2022) when any API route tries to read or write this column. Click <strong>"Fix Missing Tables & Columns"</strong> to add it.');
        }
      }

      // Existing tables (info)
      if (j.existingTables) {
        addResult('dbscan', 'Existing Tables', 'pass',
          j.existingTables.length + ' tables found: ' + j.existingTables.slice(0, 15).join(', ') + (j.existingTables.length > 15 ? '...' : ''));
      }

      addJsonBlock('dbscan', j);
    } else if (resp.status === 401) {
      addResult('dbscan', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match. Go to Vercel → Settings → Environment Variables and copy the exact value.');
    } else {
      addResult('dbscan', 'Scan', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        resp.json?.hint || 'Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbscan', resp.json);
    }
  } catch (e) {
    addResult('dbscan', 'Scan', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">DATABASE SCHEMA IS IN SYNC</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SCHEMA ISSUE(S) — Click "Fix Missing Tables & Columns" to resolve</div>';
  }

  document.getElementById('scanBtn').disabled = false;
  document.getElementById('scanBtn').textContent = 'Scan Missing Tables/Columns';
}

async function migrateDatabase() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }
  if (!confirm('This will CREATE missing tables and ADD missing columns to your production database.\n\nIt will NOT delete any existing data.\n\nProceed?')) {
    return;
  }

  document.getElementById('migrateBtn').disabled = true;
  document.getElementById('migrateBtn').textContent = 'Migrating...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('dbmigrate', 'Database Migration — Creating Missing Tables & Columns');
  log('Running database migration...');

  try {
    const resp = await testFetch('/api/admin/db-migrate', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (resp.ok && resp.json) {
      const j = resp.json;
      const r = j.result || {};

      // Before/After summary
      addResult('dbmigrate', 'Before Migration',
        j.before.missingTables > 0 || j.before.missingColumns > 0 ? 'warn' : 'pass',
        j.before.missingTables + ' missing tables, ' + j.before.missingColumns + ' missing columns');

      addResult('dbmigrate', 'After Migration',
        j.after.missingTables === 0 && j.after.missingColumns === 0 ? 'pass' : 'warn',
        j.after.missingTables + ' missing tables, ' + j.after.missingColumns + ' missing columns',
        j.after.missingTables > 0 || j.after.missingColumns > 0 ? 'Some items could not be created. Check the errors below for details.' : undefined);

      // Tables created
      if (r.tablesCreated && r.tablesCreated.length > 0) {
        for (const t of r.tablesCreated) {
          addResult('dbmigrate', 'Created Table: ' + t, 'pass', 'Table created successfully');
        }
      }

      // Columns added
      if (r.columnsAdded && r.columnsAdded.length > 0) {
        for (const c of r.columnsAdded) {
          addResult('dbmigrate', 'Added Column: ' + c, 'pass', 'Column added successfully');
        }
      }

      // Indexes created
      if (r.indexesCreated && r.indexesCreated.length > 0) {
        addResult('dbmigrate', 'Indexes Created', 'pass', r.indexesCreated.length + ' indexes: ' + r.indexesCreated.slice(0, 8).join(', ') + (r.indexesCreated.length > 8 ? '...' : ''));
      }

      // Nothing to do
      if ((!r.tablesCreated || r.tablesCreated.length === 0) &&
          (!r.columnsAdded || r.columnsAdded.length === 0)) {
        addResult('dbmigrate', 'Result', 'pass', 'Nothing to migrate — database is already in sync');
      }

      // Errors
      if (r.errors && r.errors.length > 0) {
        for (const err of r.errors) {
          addResult('dbmigrate', 'Migration Error', 'fail', err,
            'This operation failed. It may require manual intervention or higher database permissions. Check that your database user has <code>CREATE TABLE</code> and <code>ALTER TABLE</code> privileges.');
        }
      }

      addJsonBlock('dbmigrate', j);
    } else if (resp.status === 401) {
      addResult('dbmigrate', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
        'The CRON_SECRET you entered does not match.');
    } else {
      addResult('dbmigrate', 'Migration', 'fail', 'HTTP ' + resp.status + ' — ' + (resp.json?.error || resp.text?.substring(0, 200) || 'Unknown error'),
        (resp.json?.hint || '') + ' Check Vercel Function Logs for <code>/api/admin/db-migrate</code>.');
      if (resp.json) addJsonBlock('dbmigrate', resp.json);
    }
  } catch (e) {
    addResult('dbmigrate', 'Migration', 'fail', 'JS Error: ' + e.message,
      'Network error — the endpoint may not be deployed yet. Push the latest code and redeploy, then try again.');
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">MIGRATION COMPLETE — All tables and columns synced</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' MIGRATION ERROR(S) — See details above</div>';
  }

  document.getElementById('migrateBtn').disabled = false;
  document.getElementById('migrateBtn').textContent = 'Fix Missing Tables & Columns';
}

// ─── Seed Static Content ──────────────────────────────────────────────────
async function seedStaticContent() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('seedBtn').disabled = true;
  document.getElementById('seedBtn').textContent = 'Seeding...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('seed', 'Seed Static Articles into Database');

  // First do a dry run
  log('Running dry-run scan of static content...');
  try {
    const dryResp = await testFetch('/api/admin/seed-content', {
      headers: { 'Authorization': 'Bearer ' + cronSecret },
    });

    if (dryResp.ok && dryResp.json) {
      const j = dryResp.json;
      addResult('seed', 'Static Articles Found', 'pass', j.totalStatic + ' published articles in data files');
      addResult('seed', 'Categories', 'pass', j.categories + ' categories');
      addResult('seed', 'Already in DB', j.alreadyInDb > 0 ? 'pass' : 'warn', j.alreadyInDb + ' articles already exist');
      addResult('seed', 'To Create', j.toCreate > 0 ? 'warn' : 'pass', j.toCreate + ' new articles to insert');
      addResult('seed', 'To Update', 'pass', j.toUpdate + ' existing articles to refresh');
      addJsonBlock('seed', j);
    } else if (dryResp.status === 401) {
      addResult('seed', 'Auth', 'fail', 'HTTP 401 — CRON_SECRET mismatch');
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    } else {
      addResult('seed', 'Dry Run', 'fail', 'HTTP ' + dryResp.status + ' — ' + (dryResp.json?.error || ''));
      if (dryResp.json) addJsonBlock('seed', dryResp.json);
      updateSummary();
      document.getElementById('seedBtn').disabled = false;
      document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
      return;
    }
  } catch (e) {
    addResult('seed', 'Dry Run', 'fail', 'JS Error: ' + e.message);
    updateSummary();
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  if (!confirm('This will INSERT/UPDATE static articles into the BlogPost database table.\n\nArticles will be:\n• Published immediately\n• Assigned to site: yalla-london\n• Tagged with "imported-static"\n• Available to SEO agent, indexing, and CMS\n\nProceed?')) {
    document.getElementById('seedBtn').disabled = false;
    document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
    return;
  }

  // Execute the seed in batches of 8 to avoid timeout
  const BATCH_SIZE = 8;
  let currentOffset = 0;
  let batchNum = 0;
  let totalCreated = 0, totalUpdated = 0, totalErrors = 0, totalSeoMeta = 0, totalUrlIdx = 0;
  let allCreatedSlugs = [], allUpdatedSlugs = [], allSkipped = [], allErrors = [];
  let lastAuthor = null, lastCategories = 0;
  let totalDurationMs = 0;

  log('Seeding static articles into database (batches of ' + BATCH_SIZE + ')...');

  while (true) {
    batchNum++;
    log('  Batch ' + batchNum + ': offset=' + currentOffset + ' limit=' + BATCH_SIZE);

    let seedResp;
    try {
      // Use 55s timeout for each batch (server has 50s budget)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 55000);
      const resp = await fetch('/api/admin/seed-content?offset=' + currentOffset + '&limit=' + BATCH_SIZE, {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}
      seedResp = { ok: resp.ok, status: resp.status, json, text };
    } catch (e) {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'Network error: ' + e.message + '. Try clicking Seed again — it will resume from where it stopped.');
      break;
    }

    if (seedResp.ok && seedResp.json) {
      const j = seedResp.json;
      const r = j.results || {};
      const b = j.batch || {};

      totalCreated += (r.created || []).length;
      totalUpdated += (r.updated || []).length;
      totalErrors += (r.errors || []).length;
      totalSeoMeta += r.seoMetaCreated || 0;
      totalUrlIdx += r.urlIndexingCreated || 0;
      totalDurationMs += j.durationMs || 0;
      allCreatedSlugs = allCreatedSlugs.concat(r.created || []);
      allUpdatedSlugs = allUpdatedSlugs.concat(r.updated || []);
      allSkipped = allSkipped.concat(r.skipped || []);
      allErrors = allErrors.concat(r.errors || []);
      if (j.author) lastAuthor = j.author;
      if (j.categories) lastCategories = j.categories;

      addResult('seed', 'Batch ' + batchNum, 'pass',
        (r.created||[]).length + ' created, ' + (r.updated||[]).length + ' updated' +
        (b.stoppedEarly ? ' (time-limited)' : '') + ' (' + j.durationMs + 'ms)');

      // Check if there are more articles to process
      if (!b.hasMore) {
        log('  All articles processed.');
        break;
      }
      currentOffset = b.nextOffset;
    } else {
      addResult('seed', 'Batch ' + batchNum, 'fail', 'HTTP ' + seedResp.status + ' — ' + (seedResp.json?.error || seedResp.text?.substring(0, 200) || ''));
      if (seedResp.json) addJsonBlock('seed', seedResp.json);
      break;
    }
  }

  // Show combined results
  if (totalCreated + totalUpdated > 0) {
    addResult('seed', 'Seed Complete', 'pass',
      totalCreated + ' created, ' + totalUpdated + ' updated, ' + totalSeoMeta + ' SeoMeta, ' +
      totalUrlIdx + ' URLIndexing, ' + totalErrors + ' errors (' + totalDurationMs + 'ms total)');
    if (lastAuthor) addResult('seed', 'System Author', 'pass', lastAuthor.email + ' (ID: ' + lastAuthor.id + ')');
    addResult('seed', 'Categories', 'pass', lastCategories + ' categories in database');

    if (allCreatedSlugs.length > 0) {
      addResult('seed', 'New Articles', 'pass', allCreatedSlugs.length + ': ' + allCreatedSlugs.slice(0, 5).join(', ') + (allCreatedSlugs.length > 5 ? ' +' + (allCreatedSlugs.length-5) + ' more' : ''));
    }
    if (allUpdatedSlugs.length > 0) {
      addResult('seed', 'Updated Articles', 'pass', allUpdatedSlugs.length + ': ' + allUpdatedSlugs.slice(0, 5).join(', ') + (allUpdatedSlugs.length > 5 ? ' +' + (allUpdatedSlugs.length-5) + ' more' : ''));
    }
    if (allSkipped.length > 0) {
      addResult('seed', 'Skipped', 'warn', allSkipped.join(', '));
    }
    if (allErrors.length > 0) {
      for (const err of allErrors) {
        addResult('seed', 'Error: ' + err.slug, 'fail', err.error);
      }
    }
    addResult('seed', 'SEO Records', 'pass', totalSeoMeta + ' SeoMeta + ' + totalUrlIdx + ' URLIndexingStatus records created');

    addJsonBlock('seed', {
      action: 'seed-complete',
      batches: batchNum,
      totalDurationMs,
      created: allCreatedSlugs,
      updated: allUpdatedSlugs,
      skipped: allSkipped,
      errors: allErrors,
      seoMetaRecords: totalSeoMeta,
      urlIndexingRecords: totalUrlIdx,
    });
  }

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">SEED COMPLETE — Static articles are now in the database</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' SEED ERROR(S) — See details above</div>';
  }

  document.getElementById('seedBtn').disabled = false;
  document.getElementById('seedBtn').textContent = 'Seed Static Articles → DB';
}

// ─── Run All Cron Jobs ────────────────────────────────────────────────────
async function runAllJobs() {
  const cronSecret = getCronSecret();
  if (!cronSecret) {
    alert('Enter your CRON_SECRET first (switch to "Full Pipeline Test" mode).');
    return;
  }

  document.getElementById('jobsBtn').disabled = true;
  document.getElementById('jobsBtn').textContent = 'Running Jobs...';
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  pass = 0; fail = 0; warn = 0;

  addSection('jobs', 'Run All Cron Jobs');

  // Jobs ordered by dependency chain: foundational first, then consumers
  const jobs = [
    { name: 'Analytics Sync',          path: '/api/cron/analytics',               method: 'GET',  timeout: 55000 },
    { name: 'Site Health Check',        path: '/api/cron/site-health-check',       method: 'GET',  timeout: 55000 },
    { name: 'Trends Monitor',          path: '/api/cron/trends-monitor',          method: 'GET',  timeout: 55000 },
    { name: 'Weekly Topics',           path: '/api/cron/weekly-topics',           method: 'GET',  timeout: 55000 },
    { name: 'SEO Orchestrator',        path: '/api/cron/seo-orchestrator',        method: 'GET',  timeout: 55000 },
    { name: 'SEO Agent',               path: '/api/cron/seo-agent',              method: 'GET',  timeout: 55000 },
    { name: 'SEO Health Report',       path: '/api/cron/seo-health-report',      method: 'GET',  timeout: 55000 },
    { name: 'Daily Content Generate',  path: '/api/cron/daily-content-generate',  method: 'GET',  timeout: 55000 },
    { name: 'Daily Publish',           path: '/api/cron/daily-publish',           method: 'GET',  timeout: 55000 },
    { name: 'Scheduled Publish',       path: '/api/cron/scheduled-publish',       method: 'GET',  timeout: 55000 },
    { name: 'Auto Generate',           path: '/api/cron/auto-generate',           method: 'GET',  timeout: 55000 },
    { name: 'Fact Verification',       path: '/api/cron/fact-verification',       method: 'GET',  timeout: 55000 },
    { name: 'London News',             path: '/api/cron/london-news',             method: 'GET',  timeout: 55000 },
    { name: 'Real-Time Optimization',  path: '/api/cron/real-time-optimization',  method: 'POST', timeout: 55000 },
    { name: 'Google Indexing',          path: '/api/cron/google-indexing',          method: 'GET',  timeout: 55000 },
    { name: 'Autopilot',              path: '/api/cron/autopilot',               method: 'GET',  timeout: 55000 },
    { name: 'Social',                 path: '/api/cron/social',                  method: 'GET',  timeout: 55000 },
  ];

  let jobPass = 0, jobFail = 0, jobWarn = 0;
  const jobResults = [];

  for (let i = 0; i < jobs.length; i++) {
    const job = jobs[i];
    log('  [' + (i + 1) + '/' + jobs.length + '] ' + job.name + ' (' + job.path + ')...');
    updateSummary();

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), job.timeout);
      const resp = await fetch(job.path, {
        method: job.method,
        headers: { 'Authorization': 'Bearer ' + cronSecret },
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const text = await resp.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}

      const durationHint = json?.durationMs ? ' (' + json.durationMs + 'ms)' : '';
      const detail = json?.error || json?.message || json?.status || '';

      if (resp.ok) {
        addResult('jobs', job.name, 'pass', 'HTTP ' + resp.status + durationHint + (detail ? ' — ' + String(detail).substring(0, 120) : ''));
        jobPass++;
        jobResults.push({ name: job.name, status: 'pass', httpStatus: resp.status, detail });
      } else if (resp.status === 504 || resp.status === 503) {
        addResult('jobs', job.name, 'warn', 'HTTP ' + resp.status + ' — Timeout/Unavailable' + (detail ? ': ' + String(detail).substring(0, 120) : ''),
          resp.status === 504 ? 'Function exceeded Vercel timeout (60s). This job may need optimization or a higher <code>maxDuration</code>.' :
          'Service temporarily unavailable. The function may have a build error or cold start issue.');
        jobWarn++;
        jobResults.push({ name: job.name, status: 'warn', httpStatus: resp.status, detail });
      } else if (resp.status === 401) {
        addResult('jobs', job.name, 'fail', 'HTTP 401 — CRON_SECRET mismatch');
        jobFail++;
        jobResults.push({ name: job.name, status: 'fail', httpStatus: 401, detail: 'Auth failed' });
      } else {
        addResult('jobs', job.name, 'fail', 'HTTP ' + resp.status + (detail ? ' — ' + String(detail).substring(0, 150) : ''));
        jobFail++;
        jobResults.push({ name: job.name, status: 'fail', httpStatus: resp.status, detail });
      }
      if (json) addJsonBlock('jobs', json);
    } catch (e) {
      const isTimeout = e.name === 'AbortError' || e.message?.includes('aborted');
      if (isTimeout) {
        addResult('jobs', job.name, 'warn', 'Client timeout (55s) — function may still be running on server',
          'The function exceeded the 55s client timeout. It may have completed on the server. Check Vercel Function Logs.');
        jobWarn++;
      } else {
        addResult('jobs', job.name, 'fail', 'Network error: ' + e.message);
        jobFail++;
      }
      jobResults.push({ name: job.name, status: isTimeout ? 'warn' : 'fail', error: e.message });
    }

    // 5s pause between jobs to let Supabase PgBouncer session-mode connections drain
    if (i < jobs.length - 1) {
      await new Promise(r => setTimeout(r, 5000));
    }
  }

  // Summary
  addResult('jobs', 'Summary', jobFail === 0 ? 'pass' : 'fail',
    jobPass + ' passed, ' + jobWarn + ' warnings, ' + jobFail + ' failed out of ' + jobs.length + ' jobs');

  addJsonBlock('jobs', {
    action: 'run-all-jobs',
    timestamp: new Date().toISOString(),
    summary: { passed: jobPass, warnings: jobWarn, failed: jobFail, total: jobs.length },
    results: jobResults,
  });

  updateSummary();
  const banner = document.getElementById('statusBanner');
  if (jobFail === 0 && jobWarn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL ' + jobs.length + ' CRON JOBS PASSED</div>';
  } else if (jobFail === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">' + jobPass + ' JOBS PASSED, ' + jobWarn + ' WARNINGS — No critical failures</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + jobFail + ' JOB(S) FAILED — See details above</div>';
  }

  document.getElementById('jobsBtn').disabled = false;
  document.getElementById('jobsBtn').textContent = 'Run All Cron Jobs';
}

// ─── Test Runner ──────────────────────────────────────────────────────────
async function runAllTests() {
  pass = 0; fail = 0; warn = 0;
  allResults = [];
  document.getElementById('results').innerHTML = '';
  document.getElementById('statusBanner').innerHTML = '';
  document.getElementById('log').textContent = '';
  document.getElementById('runBtn').disabled = true;
  document.getElementById('runBtn').textContent = 'Testing...';

  const cronSecret = document.getElementById('cronSecret')?.value || '';

  // ── 1. GA4 Client-Side ──
  log('Testing GA4 client-side tracking...');
  addSection('ga4', '1. GA4 Client-Side Tracking');

  const homeResp = await testFetch('/');
  if (homeResp.ok) {
    const gaMatch = homeResp.text.match(/G-[A-Z0-9]{8,12}/);
    if (gaMatch) {
      addResult('ga4', 'GA4 Measurement ID', 'pass', 'Found on homepage: ' + gaMatch[0]);
      if (homeResp.text.includes('googletagmanager.com/gtag')) {
        addResult('ga4', 'gtag.js Script', 'pass', 'Script tag present on homepage');
      } else {
        addResult('ga4', 'gtag.js Script', 'warn', 'ID found but script tag not detected (may load async)');
      }
    } else {
      addResult('ga4', 'GA4 Measurement ID', 'fail', 'Not found in homepage source',
        'The <code>NEXT_PUBLIC_GA_MEASUREMENT_ID</code> env var may be missing in Vercel, or the GA4 script is not injected in <code>app/layout.tsx</code>. Check Vercel → Settings → Environment Variables for a value like <code>G-XXXXXXXXXX</code>.');
    }
  } else {
    addResult('ga4', 'Homepage Load', 'fail', 'Could not load homepage: HTTP ' + homeResp.status,
      homeResp.status === 0 ? 'Network error — site may be down or Cloudflare is blocking. Check Vercel deployment status.' :
      homeResp.status === 500 ? 'Server error — check Vercel Function Logs for the root cause (likely a missing env var or DB connection issue).' :
      homeResp.status === 503 ? 'Service unavailable — Vercel may be redeploying or the function timed out.' :
      'Unexpected HTTP ' + homeResp.status + ' — check Vercel logs.');
  }

  // ── 2. Static Assets (cache-bust to bypass stale CDN 404s) ──
  log('Testing static assets (with cache-bust)...');
  addSection('assets', '2. Static Assets');

  const cacheBust = '?v=' + Date.now();
  const assets = [
    ['/og-image.jpg' + cacheBust, 'OG Image (og-image.jpg)'],
    ['/icons/icon-512x512.png' + cacheBust, 'Icon 512x512'],
    ['/icons/icon-192x192.png' + cacheBust, 'Icon 192x192'],
    ['/favicon.ico' + cacheBust, 'Favicon ICO'],
    ['/favicon.png' + cacheBust, 'Favicon PNG'],
    ['/favicon.svg' + cacheBust, 'Favicon SVG'],
    ['/manifest.json' + cacheBust, 'Manifest'],
  ];

  for (const [url, label] of assets) {
    const resp = await testFetch(url, { method: 'HEAD' });
    if (resp.ok) {
      addResult('assets', label, 'pass', url.split('?')[0] + ' — HTTP ' + resp.status);
    } else {
      addResult('assets', label, 'fail', url.split('?')[0] + ' — HTTP ' + resp.status,
        resp.status === 404 ? 'File missing from <code>public/</code> folder. Ensure the file exists at <code>yalla_london/app/public' + url.split('?')[0] + '</code> and redeploy.' :
        'HTTP ' + resp.status + ' — may need Cloudflare cache purge. Try: Cloudflare Dashboard → Caching → Purge Everything.');
    }
  }

  // ── 3. Core Pages ──
  log('Testing core pages...');
  addSection('pages', '3. Core Pages');

  const pages = [
    ['/', 'Homepage'],
    ['/events', 'Events'],
    ['/blog', 'Blog'],
    ['/about', 'About'],
    ['/recommendations', 'Recommendations'],
    ['/sitemap.xml', 'Sitemap XML'],
  ];

  for (const [url, label] of pages) {
    const resp = await testFetch(url);
    if (resp.ok) {
      addResult('pages', label, 'pass', 'HTTP ' + resp.status);
    } else if (resp.status === 404) {
      addResult('pages', label, 'warn', 'HTTP 404',
        'Page not found. Check that <code>app/' + url.replace(/^\//, '') + '/page.tsx</code> exists in the App Router. If using dynamic routes, the page may need published content in the database to render.');
    } else {
      addResult('pages', label, 'fail', 'HTTP ' + resp.status,
        resp.status === 500 ? 'Server error rendering this page. Check Vercel Function Logs → filter by path <code>' + url + '</code> for the stack trace.' :
        resp.status === 0 ? 'Network timeout — page may be too slow to render. Check for expensive DB queries or missing data.' :
        'HTTP ' + resp.status + ' — check Vercel logs for this route.');
    }
  }

  // ── 4. SEO Meta Tags ──
  log('Testing SEO meta tags...');
  addSection('meta', '4. SEO Meta Tags');

  if (homeResp.ok) {
    const checks = [
      [/property="og:image"[^>]*content="([^"]+)"/, 'og:image'],
      [/property="og:title"[^>]*content="([^"]+)"/, 'og:title'],
      [/property="og:description"[^>]*content="([^"]+)"/, 'og:description'],
      [/rel="canonical"[^>]*href="([^"]+)"/, 'Canonical URL'],
    ];
    for (const [regex, label] of checks) {
      const match = homeResp.text.match(regex);
      if (match) addResult('meta', label, 'pass', match[1].substring(0, 80));
      else addResult('meta', label, 'warn', 'Not found on homepage',
        'Meta tag <code>' + label + '</code> is missing. Check the homepage <code>metadata</code> export in <code>app/page.tsx</code> or <code>app/layout.tsx</code>. For og:image, ensure <code>public/og-image.jpg</code> exists and is referenced in the metadata.');
    }
    const jsonLd = homeResp.text.match(/type="application\/ld\+json"/);
    if (jsonLd) addResult('meta', 'JSON-LD Schema', 'pass', 'Present');
    else addResult('meta', 'JSON-LD Schema', 'warn', 'Not found',
      'No JSON-LD structured data on homepage. Add a <code>&lt;script type="application/ld+json"&gt;</code> block in the layout or use the schema generator at <code>lib/seo/schema-generator.ts</code>.');
  }

  // ── 5. Database ──
  log('Testing database connection...');
  addSection('db', '5. Database Connection');

  const blogApiResp = await testFetch('/api/blog?limit=1');
  if (blogApiResp.ok && blogApiResp.json) {
    const j = blogApiResp.json;
    const count = j.total || j.posts?.length || j.length || '?';
    addResult('db', 'Blog API', 'pass', 'Connected — ' + count + ' posts returned');
  } else if (blogApiResp.status === 404) {
    addResult('db', 'Blog API', 'warn', 'No public blog API (DB may work via internal routes)',
      'No <code>/api/blog</code> route found. The blog API may be under <code>/api/admin/blog</code> (auth-required). The database itself is likely fine — this just means there is no public unauthenticated blog API.');
  } else {
    addResult('db', 'Blog API', blogApiResp.status === 500 ? 'fail' : 'warn', 'HTTP ' + blogApiResp.status,
      blogApiResp.status === 500 ? 'Database connection failed. Check <code>DATABASE_URL</code> in Vercel env vars. The Prisma client may need <code>prisma generate</code> or the DB may be unreachable.' :
      blogApiResp.status === 503 ? 'Database temporarily unavailable — Supabase may be paused or connection pool exhausted.' :
      'HTTP ' + blogApiResp.status + ' — check <code>/api/blog/route.ts</code> for issues.');
  }

  // ── 6. AI Provider ──
  log('Testing AI provider...');
  addSection('ai', '6. AI Provider');

  const aiResp = await testFetch('/api/ai/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  if (aiResp.status === 401 || aiResp.status === 403) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (auth-protected)');
  } else if (aiResp.status === 400) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Exists (needs valid payload)');
  } else if (aiResp.status === 404) {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'Not found at /api/ai/generate',
      'The AI generate endpoint doesn\'t exist at this path. Content generation uses the internal <code>lib/ai/provider.ts</code> layer directly from cron jobs — this is expected if there\'s no public AI endpoint.');
  } else if (aiResp.ok) {
    addResult('ai', 'AI Generate Endpoint', 'pass', 'Responded OK');
  } else {
    addResult('ai', 'AI Generate Endpoint', 'warn', 'HTTP ' + aiResp.status,
      aiResp.status === 500 ? 'AI provider error. Check that <code>ANTHROPIC_API_KEY</code> (or <code>OPENAI_API_KEY</code> / <code>ABACUSAI_API_KEY</code>) is set in Vercel env vars. Also check <code>ModelProvider</code> table in the DB.' :
      'Unexpected response — check Vercel function logs for <code>/api/ai/generate</code>.');
  }

  // ── Full pipeline tests (need CRON_SECRET) ──
  if (testMode === 'full' && cronSecret) {
    const cronHeaders = { 'Authorization': 'Bearer ' + cronSecret };

    // ── 7. Content Generation Pipeline ──
    log('Testing content generation pipeline...');
    addSection('pipeline', '7. Content Generation Pipeline');
    try {
      log('  Testing daily-content-generate...');
      const contentResp = await testFetch('/api/cron/daily-content-generate?healthcheck=true', { headers: cronHeaders });
      if (contentResp.ok && contentResp.json) {
        const j = contentResp.json;
        addResult('pipeline', 'Daily Content Generate', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('pipeline', 'Last Run', 'pass', j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        if (j.sites !== undefined) addResult('pipeline', 'Active Sites', 'pass', j.sites + ' sites configured');
        addJsonBlock('pipeline', j);
      } else if (contentResp.status === 401) {
        addResult('pipeline', 'Daily Content Generate', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'The CRON_SECRET you entered doesn\'t match what\'s in Vercel. Go to Vercel → Settings → Environment Variables → find <code>CRON_SECRET</code> and copy the exact value.');
      } else {
        const err = contentResp.json?.error || contentResp.text?.substring(0, 150) || 'Unknown error';
        const pipelineStatus = contentResp.status === 503 ? 'warn' : 'fail';
        addResult('pipeline', 'Daily Content Generate', pipelineStatus, 'HTTP ' + contentResp.status + ' — ' + err,
          contentResp.status === 500 ? 'Content generation crashed. Common causes: (1) No AI API key set (<code>ANTHROPIC_API_KEY</code>), (2) Database unreachable (<code>DATABASE_URL</code>), (3) No categories/authors seeded. Check Vercel Function Logs → filter <code>/api/cron/daily-content-generate</code>.' :
          contentResp.status === 503 ? 'The endpoint returned 503 (unhealthy). This usually means a dependent service (AI API, database, or config) is not available. Check that <code>ANTHROPIC_API_KEY</code> or another AI provider key is set in Vercel Environment Variables.' :
          'Check Vercel Function Logs for the full error stack trace.');
        if (contentResp.json) addJsonBlock('pipeline', contentResp.json);
      }
    } catch (e) { log('  ERROR in section 7: ' + e.message); addResult('pipeline', 'Daily Content Generate', 'fail', 'JS Error: ' + e.message); }

    // ── 8. Scheduled Publish ──
    log('  Testing scheduled-publish...');
    addSection('publish', '8. Scheduled Publish');
    try {
      const publishResp = await testFetch('/api/cron/scheduled-publish', { headers: cronHeaders });
      if (publishResp.ok && publishResp.json) {
        const j = publishResp.json;
        addResult('publish', 'Scheduled Publish', 'pass', j.message || 'OK');
        if (j.published !== undefined) addResult('publish', 'Posts Published', 'pass', j.published + ' posts published this run');
        if (j.pending !== undefined) addResult('publish', 'Pending Schedule', 'pass', j.pending + ' posts pending');
        if (Array.isArray(j.nextScheduled) && j.nextScheduled.length) addResult('publish', 'Next Scheduled', 'pass', j.nextScheduled.map(p => (p.title || '').substring(0,40) + ' @ ' + (p.scheduled_at || '')).join('; '));
        addJsonBlock('publish', j);
      } else if (publishResp.status === 401) {
        addResult('publish', 'Scheduled Publish', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('publish', 'Scheduled Publish', 'warn', 'HTTP ' + publishResp.status + ' — ' + (publishResp.json?.error || publishResp.text?.substring(0,100) || ''),
          publishResp.status === 500 ? 'Publisher crashed. Likely a DB issue or no <code>ScheduledContent</code> records. Check Vercel logs for <code>/api/cron/scheduled-publish</code>.' :
          'Check Vercel Function Logs for details.');
        if (publishResp.json) addJsonBlock('publish', publishResp.json);
      }
    } catch (e) { log('  ERROR in section 8: ' + e.message); addResult('publish', 'Scheduled Publish', 'fail', 'JS Error: ' + e.message); }

    // ── 9. Weekly Topics ──
    log('  Testing weekly-topics...');
    addSection('topics', '9. Weekly Topics Research');
    try {
      const topicsResp = await testFetch('/api/cron/weekly-topics', { headers: cronHeaders });
      if (topicsResp.ok && topicsResp.json) {
        const j = topicsResp.json;
        addResult('topics', 'Weekly Topics', 'pass', j.message || 'OK');
        if (j.topicsGenerated !== undefined) addResult('topics', 'Topics Generated', 'pass', j.topicsGenerated + ' topics');
        if (j.pendingCount !== undefined) addResult('topics', 'Pending Backlog', 'pass', j.pendingCount + ' topics in backlog');
        if (j.skipped) addResult('topics', 'Status', 'pass', 'Skipped (not Sunday / backlog sufficient)');
        addJsonBlock('topics', j);
      } else if (topicsResp.status === 401) {
        addResult('topics', 'Weekly Topics', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel → Settings → Environment Variables.');
      } else {
        addResult('topics', 'Weekly Topics', 'warn', 'HTTP ' + topicsResp.status + ' — ' + (topicsResp.json?.error || topicsResp.text?.substring(0,100) || ''),
          topicsResp.status === 500 ? 'Topic research crashed. This cron uses AI to generate topics — check that AI API keys are configured and the <code>TopicProposal</code> table exists in Prisma.' :
          'Check Vercel Function Logs for <code>/api/cron/weekly-topics</code>.');
        if (topicsResp.json) addJsonBlock('topics', topicsResp.json);
      }
    } catch (e) { log('  ERROR in section 9: ' + e.message); addResult('topics', 'Weekly Topics', 'fail', 'JS Error: ' + e.message); }

    // ── 10. Trends Monitor ──
    log('  Testing trends-monitor...');
    addSection('trends', '10. Trends Monitor');
    try {
      const trendsResp = await testFetch('/api/cron/trends-monitor?healthcheck=true', { headers: cronHeaders });
      if (trendsResp.ok && trendsResp.json) {
        const j = trendsResp.json;
        addResult('trends', 'Trends Monitor', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('trends', 'Last Run', 'pass', new Date(j.lastRun.generatedAt).toLocaleString());
        if (j.monitoredKeywords) addResult('trends', 'Monitored Keywords', 'pass', j.monitoredKeywords + ' keywords tracked');
        addJsonBlock('trends', j);
      } else if (trendsResp.status === 401) {
        addResult('trends', 'Trends Monitor', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('trends', 'Trends Monitor', 'warn', 'HTTP ' + trendsResp.status + ' — ' + (trendsResp.json?.error || trendsResp.text?.substring(0,100) || ''),
          trendsResp.status === 500 ? 'Trends monitor crashed. It fetches RSS feeds and Google Trends data. Check <code>SERPAPI_API_KEY</code> env var and Vercel logs for <code>/api/cron/trends-monitor</code>.' :
          'Check Vercel Function Logs for details.');
        if (trendsResp.json) addJsonBlock('trends', trendsResp.json);
      }
    } catch (e) { log('  ERROR in section 10: ' + e.message); addResult('trends', 'Trends Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 11. Analytics Sync ──
    log('  Testing analytics sync...');
    addSection('analytics', '11. Analytics Sync');
    try {
      const analyticsResp = await testFetch('/api/cron/analytics', { headers: cronHeaders });
      if (analyticsResp.ok && analyticsResp.json) {
        const j = analyticsResp.json;
        addResult('analytics', 'Analytics Cron', 'pass', j.message || 'OK');
        if (j.reach !== undefined) addResult('analytics', 'Reach Count', 'pass', String(j.reach).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        if (j.pageViews !== undefined) addResult('analytics', 'Page Views', 'pass', String(j.pageViews).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        if (j.visitors !== undefined) addResult('analytics', 'Visitors', 'pass', String(j.visitors).replace(/\B(?=(\d{3})+(?!\d))/g, ','));
        addJsonBlock('analytics', j);
      } else if (analyticsResp.status === 401) {
        addResult('analytics', 'Analytics Cron', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('analytics', 'Analytics Cron', 'warn', 'HTTP ' + analyticsResp.status + ' — ' + (analyticsResp.json?.error || analyticsResp.text?.substring(0,100) || ''),
          analyticsResp.status === 500 ? 'Analytics sync crashed. Check: (1) <code>GA4_PROPERTY_ID</code> is set, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> + <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> are configured, (3) Service account has "Viewer" role on the GA4 property.' :
          'Check Vercel Function Logs for <code>/api/cron/analytics</code>.');
        if (analyticsResp.json) addJsonBlock('analytics', analyticsResp.json);
      }
    } catch (e) { log('  ERROR in section 11: ' + e.message); addResult('analytics', 'Analytics Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 12. SEO Agent ──
    log('  Testing SEO agent...');
    addSection('seoagent', '12. SEO Agent');
    try {
      const seoResp = await testFetch('/api/cron/seo-agent?healthcheck=true', { headers: cronHeaders });
      if (seoResp.ok && seoResp.json) {
        const j = seoResp.json;
        addResult('seoagent', 'SEO Agent', 'pass', j.status === 'healthy' ? 'Healthy' : (j.message || 'OK'));
        if (j.lastRun) addResult('seoagent', 'Last Run', 'pass', j.lastRun.status + ' — ' + new Date(j.lastRun.started_at).toLocaleString());
        addJsonBlock('seoagent', j);
      } else if (seoResp.status === 401) {
        addResult('seoagent', 'SEO Agent', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('seoagent', 'SEO Agent', 'warn', 'HTTP ' + seoResp.status + ' — ' + (seoResp.json?.error || seoResp.text?.substring(0,100) || ''),
          seoResp.status === 500 ? 'SEO Agent crashed. This is the core 13-step agent. Check Vercel logs for <code>/api/cron/seo-agent</code>. Common causes: DB unreachable, missing GSC credentials, or the <code>SeoReport</code> / <code>BlogPost</code> tables have schema mismatches after a migration.' :
          'Check Vercel Function Logs for details.');
        if (seoResp.json) addJsonBlock('seoagent', seoResp.json);
      }
    } catch (e) { log('  ERROR in section 12: ' + e.message); addResult('seoagent', 'SEO Agent', 'fail', 'JS Error: ' + e.message); }

    // ── 13. SEO Daily Cron ──
    log('  Testing SEO daily cron...');
    try {
      const seoCronResp = await testFetch('/api/seo/cron?task=daily&healthcheck=true', { headers: cronHeaders });
      if (seoCronResp.ok && seoCronResp.json) {
        addResult('seoagent', 'SEO Daily Cron', 'pass', seoCronResp.json.message || 'OK');
      } else if (seoCronResp.status === 401) {
        addResult('seoagent', 'SEO Daily Cron', 'fail', 'HTTP 401');
      } else {
        addResult('seoagent', 'SEO Daily Cron', 'warn', 'HTTP ' + seoCronResp.status);
      }
    } catch (e) { log('  ERROR in section 13: ' + e.message); addResult('seoagent', 'SEO Daily Cron', 'fail', 'JS Error: ' + e.message); }

    // ── 14. SEO Orchestrator ──
    log('  Testing SEO orchestrator...');
    addSection('orchestrator', '14. SEO Orchestrator');
    try {
      const orchResp = await testFetch('/api/cron/seo-orchestrator?healthcheck=true', { headers: cronHeaders });
      if (orchResp.ok && orchResp.json) {
        const j = orchResp.json;
        addResult('orchestrator', 'Orchestrator Status', 'pass', j.status === 'healthy' ? 'Healthy' : (j.status || 'OK'));
        if (j.lastRun) {
          addResult('orchestrator', 'Last Run', j.lastRun.status === 'error' ? 'fail' : 'pass',
            (j.lastRun.status || 'unknown') + (j.lastRun.at ? ' — ' + new Date(j.lastRun.at).toLocaleString() : ''));
          if (j.lastRun.healthScore !== undefined) addResult('orchestrator', 'Health Score', j.lastRun.healthScore >= 60 ? 'pass' : 'warn', j.lastRun.healthScore + '/100');
          if (j.lastRun.issuesFound !== undefined) addResult('orchestrator', 'Issues Found', j.lastRun.issuesFound > 10 ? 'warn' : 'pass', j.lastRun.issuesFound + ' issues');
          if (j.lastRun.fixesApplied !== undefined) addResult('orchestrator', 'Fixes Applied', 'pass', j.lastRun.fixesApplied + ' auto-fixes');
        }
        if (j.sites !== undefined) addResult('orchestrator', 'Sites Monitored', 'pass', j.sites + ' sites');
        addJsonBlock('orchestrator', j);
      } else if (orchResp.status === 401) {
        addResult('orchestrator', 'Orchestrator', 'fail', 'HTTP 401 — CRON_SECRET mismatch',
          'CRON_SECRET doesn\'t match. Copy the exact value from Vercel.');
      } else {
        addResult('orchestrator', 'Orchestrator', 'warn', 'HTTP ' + orchResp.status + ' — ' + (orchResp.json?.error || orchResp.text?.substring(0,150) || ''),
          orchResp.status === 500 ? 'Orchestrator crashed. This runs the 5-module system (live auditor, business goals, agent monitor, metrics collection, report storage). Check Vercel logs for <code>/api/cron/seo-orchestrator</code>. Most common cause: DB connection failure or missing <code>SiteHealthCheck</code> table.' :
          orchResp.status === 504 ? 'Timeout — the orchestrator audits all 5 sites sequentially and may exceed the function timeout. Check <code>maxDuration</code> in vercel.json (should be 120 for cron routes).' :
          'Check Vercel Function Logs for the full error.');
        if (orchResp.json) addJsonBlock('orchestrator', orchResp.json);
      }
    } catch (e) { log('  ERROR in section 14: ' + e.message); addResult('orchestrator', 'Orchestrator', 'fail', 'JS Error: ' + e.message); }

    // ── 15. Health Monitor (Cron Execution Proof) ──
    log('  Testing health monitor (cron log proof)...');
    addSection('healthmon', '15. Health Monitor — Cron Execution Proof');
    try {
      const hmResp = await testFetch('/api/admin/health-monitor', { headers: cronHeaders });
      if (hmResp.ok && hmResp.json) {
        const j = hmResp.json;
        // Database
        if (j.database) {
          addResult('healthmon', 'Database Connection', j.database.connected ? 'pass' : 'fail',
            j.database.connected ? 'Connected — ' + (j.database.latencyMs || '?') + 'ms latency' : (j.database.error || 'Disconnected'));
        }
        // Cron job status
        if (j.cronJobs && j.cronJobs.length > 0) {
          addResult('healthmon', 'Cron Jobs Tracked', 'pass', j.cronJobs.length + ' jobs in CronJobLog');
          const now = Date.now();
          for (const cron of j.cronJobs) {
            const ago = cron.lastRun ? Math.round((now - new Date(cron.lastRun).getTime()) / 3600000) : null;
            const agoStr = ago !== null ? ago + 'h ago' : 'never';
            const cronStatus = cron.status === 'completed' ? 'pass' : cron.status === 'failed' ? 'fail' : 'warn';
            addResult('healthmon', 'Cron: ' + cron.jobName, cronStatus,
              cron.status + ' — last: ' + agoStr + (cron.durationMs ? ' (' + cron.durationMs + 'ms)' : ''));
          }
        } else {
          addResult('healthmon', 'Cron Jobs', 'fail', 'No CronJobLog entries found — crons may not be executing',
            'The <code>cron_job_logs</code> table has zero entries. This means either: (1) No Vercel cron has fired yet — check Vercel Dashboard → project → Settings → Crons to see if they\'re scheduled, (2) The <code>CronJobLog</code> table doesn\'t exist — run <code>npx prisma db push</code> to sync the schema, or (3) The cron jobs are running but not using <code>logCronExecution()</code>.');
        }
        // Site health
        if (j.sites && j.sites.length > 0) {
          for (const site of j.sites) {
            const siteStatus = site.status === 'healthy' ? 'pass' : 'warn';
            addResult('healthmon', 'Site: ' + site.siteName, siteStatus,
              site.status + (site.healthScore !== null ? ' — score: ' + site.healthScore + '/100' : '') + ' (' + site.domain + ')',
              site.status === 'unknown' ? 'No health check data yet — the <code>site-health-check</code> cron has never run for this site. Once Vercel crons start executing, health scores will be populated automatically.' : undefined);
          }
        }
        // Indexing
        if (j.indexing) {
          const ix = j.indexing;
          addResult('healthmon', 'Indexing Status', ix.indexed > 0 ? 'pass' : 'warn',
            ix.indexed + '/' + ix.totalUrls + ' indexed (' + (ix.indexRate || 0) + '%) — ' + ix.submitted + ' submitted, ' + ix.errors + ' errors');
        }
        // Recent errors
        if (j.recentErrors && j.recentErrors.length > 0) {
          addResult('healthmon', 'Recent Errors (24h)', 'warn', j.recentErrors.length + ' errors');
          for (const err of j.recentErrors.slice(0, 5)) {
            addResult('healthmon', '  Error: ' + err.jobName, 'warn', err.error.substring(0, 120) + ' — ' + new Date(err.timestamp).toLocaleString());
          }
        } else if (j.recentErrors) {
          addResult('healthmon', 'Recent Errors (24h)', 'pass', 'None');
        }
        // Summary
        if (j.summary) {
          addResult('healthmon', 'Overall Summary', j.summary.failedCronJobs === 0 ? 'pass' : 'warn',
            j.summary.healthySites + '/' + j.summary.totalSites + ' healthy, ' +
            j.summary.failedCronJobs + ' failed crons, ' + j.summary.errorsLast24h + ' errors 24h');
        }
        addJsonBlock('healthmon', j);
      } else if (hmResp.status === 401 || hmResp.status === 403) {
        addResult('healthmon', 'Health Monitor', 'warn', 'Auth required — endpoint needs admin session cookie, not CRON_SECRET',
          'The <code>/api/admin/health-monitor</code> endpoint uses <code>withAdminAuth</code> which checks your NextAuth session cookie, not CRON_SECRET. Log into the admin dashboard first, then re-run this test in the same browser. Alternatively, access it directly while logged in: <code>/api/admin/health-monitor</code>.');
      } else {
        addResult('healthmon', 'Health Monitor', 'warn', 'HTTP ' + hmResp.status + ' — ' + (hmResp.json?.error || hmResp.text?.substring(0,100) || ''),
          hmResp.status === 500 ? 'Health monitor crashed. Check if the DB is reachable and the <code>CronJobLog</code>, <code>SiteHealthCheck</code>, and <code>URLIndexingStatus</code> tables exist.' :
          'Check Vercel Function Logs for <code>/api/admin/health-monitor</code>.');
        if (hmResp.json) addJsonBlock('healthmon', hmResp.json);
      }
    } catch (e) { log('  ERROR in section 15: ' + e.message); addResult('healthmon', 'Health Monitor', 'fail', 'JS Error: ' + e.message); }

    // ── 16. SEO Indexing Status ──
    log('  Testing SEO indexing status...');
    addSection('indexing', '16. SEO Indexing & Search Console');
    try {
      const idxResp = await testFetch('/api/admin/seo/indexing?type=stats', { headers: cronHeaders });
      if (idxResp.ok && idxResp.json) {
        const j = idxResp.json;
        const s = j.stats || {};
        addResult('indexing', 'Indexing Reports', j.success ? 'pass' : 'warn',
          s.totalReports + ' reports (' + s.totalSubmissions + ' submissions, ' + s.totalAudits + ' audits)');
        if (s.totalGoogleSubmitted !== undefined) addResult('indexing', 'Google API Submissions', s.totalGoogleSubmitted > 0 ? 'pass' : 'warn', s.totalGoogleSubmitted + ' URLs submitted');
        if (s.totalIndexNowSubmitted !== undefined) addResult('indexing', 'IndexNow Submissions', s.totalIndexNowSubmitted > 0 ? 'pass' : 'warn', s.totalIndexNowSubmitted + ' URLs submitted');
        if (s.lastSubmission) addResult('indexing', 'Last Submission', 'pass', new Date(s.lastSubmission).toLocaleString());
        if (s.latestSnapshot) {
          addResult('indexing', 'Indexed Pages', s.latestSnapshot.indexed > 0 ? 'pass' : 'warn',
            s.latestSnapshot.indexed + '/' + s.latestSnapshot.totalPages + ' indexed (' + s.latestSnapshot.notIndexed + ' not indexed)');
        }
        if (s.timeline && s.timeline.length > 0) {
          addResult('indexing', 'Recent Activity', 'pass', s.timeline.length + ' submissions in timeline');
        }
        addJsonBlock('indexing', j);
      } else if (idxResp.status === 401 || idxResp.status === 403) {
        addResult('indexing', 'Indexing API', 'warn', 'Needs admin auth');
      } else {
        addResult('indexing', 'Indexing API', 'warn', 'HTTP ' + idxResp.status);
        if (idxResp.json) addJsonBlock('indexing', idxResp.json);
      }
    } catch (e) { log('  ERROR in section 16: ' + e.message); addResult('indexing', 'Indexing', 'fail', 'JS Error: ' + e.message); }

    // ── 17. GA4 Server-Side Data (real proof of analytics) ──
    log('  Testing GA4 server-side data...');
    addSection('ga4server', '17. GA4 Server-Side Data API');
    try {
      const gaResp = await testFetch('/api/admin/analytics/ga4', { headers: cronHeaders });
      if (gaResp.ok && gaResp.json) {
        const j = gaResp.json;
        if (j.configured !== undefined) addResult('ga4server', 'GA4 Configured', j.configured ? 'pass' : 'fail', j.configured ? 'Credentials present' : 'Missing GA4_PROPERTY_ID or service account',
          !j.configured ? 'GA4 server-side data requires 3 env vars in Vercel: (1) <code>GA4_PROPERTY_ID</code> — your numeric GA4 property ID, (2) <code>GOOGLE_ANALYTICS_CLIENT_EMAIL</code> — service account email, (3) <code>GOOGLE_ANALYTICS_PRIVATE_KEY</code> — the full private key (with <code>\\n</code> newlines). The service account must have "Viewer" role on the GA4 property in Google Analytics Admin → Property Access Management.' : undefined);
        if (j.metrics) {
          const m = j.metrics;
          addResult('ga4server', 'Sessions (30d)', m.sessions > 0 ? 'pass' : 'warn', m.sessions.toLocaleString());
          addResult('ga4server', 'Page Views (30d)', m.pageViews > 0 ? 'pass' : 'warn', m.pageViews.toLocaleString());
          addResult('ga4server', 'Users (30d)', m.totalUsers > 0 ? 'pass' : 'warn', m.totalUsers.toLocaleString());
          addResult('ga4server', 'Bounce Rate', m.bounceRate < 70 ? 'pass' : 'warn', m.bounceRate.toFixed(1) + '%');
          addResult('ga4server', 'Engagement Rate', m.engagementRate > 30 ? 'pass' : 'warn', m.engagementRate.toFixed(1) + '%');
        }
        if (j.topPages && j.topPages.length > 0) {
          addResult('ga4server', 'Top Pages', 'pass', j.topPages.slice(0,5).map(p => p.path + ' (' + p.pageViews + ' views)').join(', '));
        }
        if (j.topSources && j.topSources.length > 0) {
          addResult('ga4server', 'Top Traffic Sources', 'pass', j.topSources.slice(0,5).map(s => s.source + ' (' + s.sessions + ')').join(', '));
        }
        addJsonBlock('ga4server', j);
      } else if (gaResp.status === 401 || gaResp.status === 403) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Needs admin auth',
          'This endpoint uses admin auth. Log into the admin dashboard first, then revisit. The GA4 data is still fetched by crons even if this admin endpoint needs auth.');
      } else if (gaResp.status === 404) {
        addResult('ga4server', 'GA4 Data API', 'warn', 'Endpoint not found — /api/admin/analytics/ga4 may not exist',
          'No dedicated GA4 admin endpoint exists. GA4 data is fetched internally by the SEO agent and analytics cron via <code>lib/seo/ga4-data-api.ts</code>. You can verify it works by checking the SEO Agent report (section 12) which includes <code>trafficAnalysis</code> data from GA4.');
      } else {
        addResult('ga4server', 'GA4 Data API', 'warn', 'HTTP ' + gaResp.status,
          gaResp.status === 500 ? 'GA4 API call failed. Check: (1) <code>GA4_PROPERTY_ID</code> is correct, (2) service account private key doesn\'t have encoding issues (\\n vs actual newlines), (3) service account email has GA4 property access.' :
          'Check Vercel Function Logs.');
        if (gaResp.json) addJsonBlock('ga4server', gaResp.json);
      }
    } catch (e) { log('  ERROR in section 17: ' + e.message); addResult('ga4server', 'GA4 Data API', 'fail', 'JS Error: ' + e.message); }

    // ── 18. Blog Content Audit (proof content generator works) ──
    log('  Testing blog content audit...');
    addSection('blogaudit', '18. Blog Content Audit — Auto-Generated Proof');
    try {
      const blogResp = await testFetch('/api/blog?limit=20&sort=created_at:desc');
      if (blogResp.ok && blogResp.json) {
        const posts = blogResp.json.posts || blogResp.json.data || (Array.isArray(blogResp.json) ? blogResp.json : []);
        const total = blogResp.json.total || blogResp.json.count || posts.length;
        addResult('blogaudit', 'Total Posts', total > 0 ? 'pass' : 'warn', total + ' published blog posts in database',
          total === 0 ? 'Zero published blog posts in the database. Click <strong>"Seed Static Articles → DB"</strong> to import the 23 static articles into the database. Once seeded, the SEO agent, indexing pipeline, and CMS will manage them automatically.' : undefined);

        let autoGen = 0, withMeta = 0, withAr = 0, withSchema = 0, recentCount = 0;
        const now = Date.now();
        const sevenDays = 7 * 24 * 60 * 60 * 1000;

        for (const p of posts) {
          if (p.tags && Array.isArray(p.tags) && p.tags.includes('auto-generated')) autoGen++;
          if (p.meta_title_en || p.meta_description_en) withMeta++;
          if (p.content_ar && p.content_ar !== null && !p.content_ar.startsWith('[0 ')) withAr++;
          if (p.authority_links_json || p.keywords_json) withSchema++;
          if (p.created_at && (now - new Date(p.created_at).getTime()) < sevenDays) recentCount++;
        }

        addResult('blogaudit', 'Auto-Generated Posts', autoGen > 0 ? 'pass' : 'warn',
          autoGen + '/' + posts.length + ' posts have "auto-generated" tag (content pipeline proof)',
          autoGen === 0 ? 'No posts have the <code>auto-generated</code> tag. This means the daily content generation cron (<code>/api/cron/daily-content-generate</code>) hasn\'t successfully created any posts. Check: (1) Vercel cron schedule is active, (2) AI API key is set, (3) The cron healthcheck (section 7) shows a recent successful run.' : undefined);
        addResult('blogaudit', 'Posts with Meta Tags', withMeta > 0 ? 'pass' : 'warn',
          withMeta + '/' + posts.length + ' have SEO meta titles/descriptions');
        addResult('blogaudit', 'Arabic Content', withAr > 0 ? 'pass' : 'warn',
          withAr + '/' + posts.length + ' have Arabic content (>100 chars)');
        addResult('blogaudit', 'SEO Data (keywords/schema)', withSchema > 0 ? 'pass' : 'warn',
          withSchema + '/' + posts.length + ' have keywords or schema data');
        addResult('blogaudit', 'Recent Posts (7d)', recentCount > 0 ? 'pass' : 'warn',
          recentCount + ' posts created in last 7 days',
          recentCount === 0 ? 'No posts in the last 7 days. The daily content cron should create 2 posts per site per day (10 total). Check Vercel → Settings → Crons to confirm <code>/api/cron/daily-content-generate</code> is scheduled at 5:00 UTC daily and has recent executions.' : undefined);

        // Show latest 3 posts
        for (const p of posts.slice(0, 3)) {
          const age = p.created_at ? Math.round((now - new Date(p.created_at).getTime()) / 3600000) + 'h ago' : '?';
          const tags = (p.tags || []).join(', ');
          addResult('blogaudit', 'Post: ' + (p.title_en || p.slug || '').substring(0, 50), 'pass',
            age + ' | seo:' + (p.seo_score || '?') + ' | tags: ' + tags.substring(0, 80));
        }
        addJsonBlock('blogaudit', { total, sample: posts.slice(0, 3) });
      } else if (blogResp.status === 404) {
        addResult('blogaudit', 'Blog API', 'warn', 'No public /api/blog endpoint — test via admin');
      } else {
        addResult('blogaudit', 'Blog API', 'warn', 'HTTP ' + blogResp.status);
      }
    } catch (e) { log('  ERROR in section 18: ' + e.message); addResult('blogaudit', 'Blog Audit', 'fail', 'JS Error: ' + e.message); }

    // ── 19. SEO Reports (proof orchestrator writes to DB) ──
    log('  Testing SEO reports...');
    addSection('seoreports', '19. SEO Reports — Orchestrator Output Proof');
    try {
      const reportResp = await testFetch('/api/admin/seo/reports?limit=5', { headers: cronHeaders });
      if (reportResp.ok && reportResp.json) {
        const reports = reportResp.json.reports || reportResp.json.data || (Array.isArray(reportResp.json) ? reportResp.json : []);
        addResult('seoreports', 'SEO Reports in DB', reports.length > 0 ? 'pass' : 'warn', reports.length + ' reports found');
        for (const r of reports.slice(0, 5)) {
          const age = r.generatedAt ? Math.round((Date.now() - new Date(r.generatedAt).getTime()) / 3600000) + 'h ago' : '?';
          const score = r.data?.health_score || r.data?.healthScore || '?';
          addResult('seoreports', r.reportType + ' report', 'pass',
            age + ' | score: ' + score + ' | site: ' + (r.site_id || 'all'));
        }
        if (reports.length > 0) addJsonBlock('seoreports', reports[0]);
      } else if (reportResp.status === 401 || reportResp.status === 403) {
        addResult('seoreports', 'SEO Reports', 'warn', 'Needs admin auth — try admin session');
      } else if (reportResp.status === 404) {
        addResult('seoreports', 'SEO Reports', 'warn', 'No /api/admin/seo/reports endpoint');
      } else {
        addResult('seoreports', 'SEO Reports', 'warn', 'HTTP ' + reportResp.status);
        if (reportResp.json) addJsonBlock('seoreports', reportResp.json);
      }
    } catch (e) { log('  ERROR in section 19: ' + e.message); addResult('seoreports', 'SEO Reports', 'fail', 'JS Error: ' + e.message); }

    // ── 20. Yalla London Site Health Check ──
    log('  Testing Yalla London site health...');
    addSection('multisite', '20. Yalla London Site Health');
    try {
      const siteResp = await testFetch('/api/admin/sites/yalla-london/health', { headers: cronHeaders });
      if (siteResp.ok && siteResp.json) {
        const j = siteResp.json;
        const score = j.healthScore ?? '?';
        const statusCls = j.status === 'healthy' ? 'pass' : j.status === 'degraded' ? 'warn' : j.status === 'down' ? 'fail' : 'warn';
        addResult('multisite', j.siteName || 'Yalla London', statusCls,
          j.status + ' — score: ' + score + '/100' +
          (j.indexing ? ' | indexed: ' + j.indexing.indexed + '/' + j.indexing.totalUrls : '') +
          (j.content ? ' | posts: ' + j.content.publishedPosts + '/' + j.content.totalPosts : '') +
          ' (' + (j.domain || 'yalla-london.com') + ')');
        if (j.crons7d) {
          addResult('multisite', 'Crons (7d)', j.crons7d.failed === 0 ? 'pass' : 'warn',
            j.crons7d.completed + ' completed, ' + j.crons7d.failed + ' failed, ' + j.crons7d.timedOut + ' timed out');
        }
        if (j.seo) {
          addResult('multisite', 'SEO Indexing', j.seo.indexed_pages > 0 ? 'pass' : 'warn',
            j.seo.indexed_pages + '/' + j.seo.total_pages + ' pages indexed (' + (j.seo.indexing_rate || 0) + '%)');
        }
        addJsonBlock('multisite', j);
      } else if (siteResp.status === 404) {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP 404 — site health endpoint not found',
          'The <code>/api/admin/sites/yalla-london/health</code> route returned 404. This endpoint may not be deployed yet. Ensure the route exists at <code>app/api/admin/sites/[siteId]/health/route.ts</code> and redeploy.');
      } else {
        addResult('multisite', 'Yalla London', 'warn', 'HTTP ' + siteResp.status + ' — ' + (siteResp.errorDetail || ''));
      }
    } catch (e) { log('  ERROR in section 20: ' + e.message); addResult('multisite', 'Site Health', 'fail', 'JS Error: ' + e.message); }

    // ── 21. Content & Indexing Deep Audit ──
    log('  Running content & indexing deep audit...');
    addSection('contentaudit', '21. Content & Indexing Deep Audit');
    try {
      const auditResp = await testFetch('/api/admin/content-audit', { headers: cronHeaders });
      if (auditResp.ok && auditResp.json) {
        const j = auditResp.json;
        const s = j.summary;

        // Global totals
        addResult('contentaudit', 'Total Articles/Posts', s.totalPosts > 0 ? 'pass' : 'warn',
          s.totalPosts + ' total (' + s.totalPublished + ' published, ' + s.totalDrafts + ' drafts)',
          s.totalPosts === 0 ? 'No blog posts yet. The content generation cron needs to run successfully to create posts. This is normal for a fresh deployment.' : undefined);

        addResult('contentaudit', 'URLs Tracked for Indexing', s.totalTrackedUrls > 0 ? 'pass' : 'warn',
          s.totalTrackedUrls + ' URLs in URLIndexingStatus table',
          s.totalTrackedUrls === 0 ? 'No URLs being tracked for indexing. The SEO agent should create URL tracking entries when it runs. Check section 12 (SEO Agent) for status.' : undefined);

        addResult('contentaudit', 'Indexing Requested (Submitted)', s.totalSubmittedPending > 0 || s.totalIndexed > 0 ? 'pass' : 'warn',
          (s.totalSubmittedPending + s.totalIndexed) + ' URLs submitted to Google/IndexNow (' + s.totalSubmittedPending + ' pending, ' + s.totalIndexed + ' confirmed indexed)',
          s.totalSubmittedPending === 0 && s.totalIndexed === 0 ? 'No URLs have been submitted for indexing. Check that <code>INDEXNOW_KEY</code> is set and the SEO agent is running. The agent submits URLs via IndexNow and Google Indexing API.' : undefined);

        addResult('contentaudit', 'Confirmed Indexed in Google', s.totalIndexed > 0 ? 'pass' : 'warn',
          s.totalIndexed + ' pages confirmed indexed (' + s.indexRate + '% index rate)',
          s.totalIndexed === 0 ? 'Zero pages confirmed indexed. This is normal for new sites — Google can take days to weeks to index pages. The SEO agent checks via GSC URL Inspection API. Ensure GSC service account credentials are configured.' : undefined);

        addResult('contentaudit', 'Indexing Errors', s.totalErrors === 0 ? 'pass' : 'warn',
          s.totalErrors + ' URLs with indexing errors',
          s.totalErrors > 0 ? 'Some URLs failed indexing submission. See the error details below for specific causes.' : undefined);

        addResult('contentaudit', 'Untracked Published Posts', s.totalUntracked === 0 ? 'pass' : 'warn',
          s.totalUntracked + ' published posts not yet tracked in URLIndexingStatus',
          s.totalUntracked > 0 ? 'These published posts have no entry in the URL tracking table. The SEO agent should pick them up on its next run and create tracking entries + submit them for indexing.' : undefined);

        // Per-site breakdown
        if (j.perSite && j.perSite.length > 0) {
          for (const site of j.perSite) {
            const ix = site.indexing || {};
            addResult('contentaudit', site.siteName + ' (' + site.domain + ')',
              ix.indexed > 0 ? 'pass' : site.published > 0 ? 'warn' : 'warn',
              site.published + ' published, ' + site.drafts + ' drafts | indexed: ' + ix.indexed + '/' + ix.total + ' (' + ix.indexRate + '%) | submitted: ' + ix.submitted + ' | errors: ' + ix.error);

            // Show not-indexed reasons for this site
            if (site.notIndexedReasons && site.notIndexedReasons.length > 0) {
              for (const r of site.notIndexedReasons) {
                addResult('contentaudit', '  ↳ Not indexed: ' + r.reason, 'warn', r.count + ' URLs',
                  r.reason.includes('not indexed') ? 'Google crawled the page but decided not to index it. Common reasons: thin content (<300 words), duplicate content, low-quality content, or noindex tag. Check Google Search Console → Pages for details.' :
                  r.reason.includes('discovered') ? 'Google knows the page exists but hasn\'t crawled it yet. This is normal for new pages — give it time or request indexing via GSC.' :
                  r.reason.includes('redirect') ? 'Page redirects to another URL. Check for broken redirect chains.' :
                  r.reason.includes('blocked') ? 'Page is blocked by robots.txt or a noindex meta tag. Check the page\'s robots directives.' :
                  'GSC coverage state: ' + r.reason + '. Check Google Search Console → Pages → this specific status for detailed information.');
              }
            }
          }
        }

        // Stuck pages (submitted >7 days ago, still not indexed)
        if (j.stuckPages && j.stuckPages.length > 0) {
          addResult('contentaudit', 'Stuck Pages (submitted >7d ago, not indexed)', 'warn', j.stuckPages.length + ' pages');
          for (const p of j.stuckPages.slice(0, 10)) {
            const daysAgo = Math.round((Date.now() - new Date(p.submittedAt).getTime()) / 86400000);
            addResult('contentaudit', '  ↳ ' + (p.slug || p.url).substring(0, 50), 'warn',
              daysAgo + 'd since submission | attempts: ' + p.attempts + ' | GSC: ' + (p.coverageState || 'unknown'),
              'This page was submitted ' + daysAgo + ' days ago but still isn\'t indexed. Try: (1) Resubmit via GSC "Request Indexing", (2) Check if page returns 200 status, (3) Ensure content is high-quality (>1200 words), (4) Add internal links to this page from indexed pages.');
          }
        } else if (j.stuckPages) {
          addResult('contentaudit', 'Stuck Pages', 'pass', 'None — all submitted pages are progressing');
        }

        // URL errors
        if (j.urlErrors && j.urlErrors.length > 0) {
          addResult('contentaudit', 'URLs with Errors', 'warn', j.urlErrors.length + ' errors');
          for (const e of j.urlErrors.slice(0, 10)) {
            addResult('contentaudit', '  ↳ ' + (e.slug || e.url).substring(0, 50), 'fail',
              'Error: ' + (e.error || 'unknown').substring(0, 100) + ' | attempts: ' + e.attempts,
              'This URL failed indexing. Error: <code>' + escapeHtml((e.error || '').substring(0, 150)) + '</code>. Check if the URL returns HTTP 200 and has proper content.');
          }
        } else if (j.urlErrors) {
          addResult('contentaudit', 'URL Errors', 'pass', 'None');
        }

        // Untracked posts
        if (j.untrackedPosts && j.untrackedPosts.length > 0) {
          addResult('contentaudit', 'Untracked Published Posts', 'warn', j.untrackedPosts.length + ' posts not in URL tracker');
          for (const p of j.untrackedPosts.slice(0, 5)) {
            addResult('contentaudit', '  ↳ ' + (p.title || p.slug).substring(0, 50), 'warn',
              p.siteId + ' — created: ' + new Date(p.createdAt).toLocaleDateString(),
              'This published post has no URL tracking entry. The SEO agent will pick it up on its next run. To force immediate tracking, trigger the SEO agent manually.');
          }
        }

        addJsonBlock('contentaudit', { summary: j.summary, perSite: j.perSite });
      } else if (auditResp.status === 401 || auditResp.status === 403) {
        addResult('contentaudit', 'Content Audit', 'fail', 'HTTP ' + auditResp.status + ' — auth failed');
      } else {
        addResult('contentaudit', 'Content Audit', 'warn', 'HTTP ' + auditResp.status + ' — ' + (auditResp.json?.error || auditResp.text?.substring(0,150) || ''));
        if (auditResp.json) addJsonBlock('contentaudit', auditResp.json);
      }
    } catch (e) { log('  ERROR in section 21: ' + e.message); addResult('contentaudit', 'Content Audit', 'fail', 'JS Error: ' + e.message); }

  } else if (testMode === 'full' && !cronSecret) {
    addSection('pipeline', '7. Content Generation Pipeline');
    addResult('pipeline', 'Pipeline Tests', 'fail', 'Enter CRON_SECRET above and re-run');
  }

  // ── Auto-scan for missing tables (after all tests) ──
  if (testMode === 'full' && cronSecret) {
    // Wait 3s to let DB connection pool drain from previous tests
    log('  Waiting 3s for connection pool to drain...');
    await new Promise(r => setTimeout(r, 3000));
    log('  Auto-scanning database schema for missing tables/columns...');
    addSection('dbcheck', '22. Database Schema Health');
    try {
      const dbScanResp = await testFetch('/api/admin/db-migrate', {
        headers: { 'Authorization': 'Bearer ' + cronSecret },
      });
      if (dbScanResp.ok && dbScanResp.json) {
        const j = dbScanResp.json;
        const s = j.summary || {};
        if (s.needsMigration) {
          addResult('dbcheck', 'Schema Sync', 'fail',
            s.missingTables + ' missing table(s), ' + s.missingColumns + ' missing column(s)',
            'Database schema is out of sync with the Prisma models. This causes runtime errors like <strong>P2022 (column does not exist)</strong> or <strong>P2021 (table does not exist)</strong>. Click <strong>"Fix Missing Tables & Columns"</strong> at the top of this page to resolve, or run <code>npx prisma db push</code> on the server.');
          if (j.missingTables) {
            for (const t of j.missingTables) {
              addResult('dbcheck', 'Missing: ' + t.table, 'fail', 'Model: ' + t.model + ' — table needs to be created',
                'Table <code>' + escapeHtml(t.table) + '</code> does not exist. Any API route that queries <code>prisma.' + escapeHtml(t.model.charAt(0).toLowerCase() + t.model.slice(1)) + '</code> will throw <strong>P2021: The table does not exist in the current database</strong>. Routes affected include any cron job, page, or API route that imports this model.');
            }
          }
          if (j.missingColumns) {
            for (const c of j.missingColumns) {
              addResult('dbcheck', 'Missing: ' + c.table + '.' + c.column, 'fail', c.type + ' — column needs to be added',
                'Column <code>' + escapeHtml(c.column) + '</code> is missing from table <code>' + escapeHtml(c.table) + '</code>. Any query that filters by, selects, or sorts on this column will throw <strong>P2022: The column does not exist</strong>. This is the root cause of many HTTP 500 errors in cron jobs and API routes.');
            }
          }
        } else {
          addResult('dbcheck', 'Schema Sync', 'pass', 'All ' + j.existingTables.length + ' tables and checked columns are in sync');
        }
        addJsonBlock('dbcheck', { summary: s, existingTables: j.existingTables?.length, missingTables: j.missingTables, missingColumns: j.missingColumns });
      } else if (dbScanResp.status === 401) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Auth failed — CRON_SECRET may be wrong');
      } else if (dbScanResp.status === 404) {
        addResult('dbcheck', 'Schema Scan', 'warn', 'Endpoint /api/admin/db-migrate not deployed yet — redeploy to enable',
          'The database schema scan endpoint has not been deployed yet. Push the latest code and redeploy on Vercel to enable this feature.');
      } else {
        addResult('dbcheck', 'Schema Scan', 'warn', 'HTTP ' + dbScanResp.status + ' — ' + (dbScanResp.json?.error || dbScanResp.text?.substring(0, 150) || ''));
        if (dbScanResp.json) addJsonBlock('dbcheck', dbScanResp.json);
      }
    } catch (e) { log('  ERROR in section 22: ' + e.message); addResult('dbcheck', 'Schema Scan', 'warn', 'JS Error: ' + e.message); }
  }

  // ── Final Status ──
  log('All tests complete: ' + pass + ' passed, ' + warn + ' warnings, ' + fail + ' failed');

  const banner = document.getElementById('statusBanner');
  if (fail === 0 && warn === 0) {
    banner.innerHTML = '<div class="status-banner status-ok">ALL SYSTEMS GO</div>';
  } else if (fail === 0) {
    banner.innerHTML = '<div class="status-banner status-warn">OPERATIONAL — ' + warn + ' warning(s)</div>';
  } else {
    banner.innerHTML = '<div class="status-banner status-fail">' + fail + ' ISSUE(S) NEED ATTENTION</div>';
  }

  // ── Generate Copiable JSON Test Result ──
  renderJsonResult();

  document.getElementById('runBtn').disabled = false;
  document.getElementById('runBtn').textContent = 'Run All Tests Again';
}

function renderJsonResult() {
  const jsonResult = {
    timestamp: new Date().toISOString(),
    mode: testMode,
    summary: { passed: pass, warnings: warn, failed: fail, total: pass + warn + fail },
    results: allResults,
  };
  const jsonStr = JSON.stringify(jsonResult, null, 2);

  // Remove any existing JSON export section
  const existing = document.getElementById('section-jsonexport');
  if (existing) existing.remove();

  const html = `<div class="section" id="section-jsonexport">
    <h2>Test Results — Copiable JSON</h2>
    <p style="color:#888;font-size:0.8rem;margin-bottom:8px;">Click the text area below and press Ctrl+A then Ctrl+C to copy, or use the Copy button.</p>
    <button onclick="copyJsonResult()" style="margin:0 0 12px;padding:8px 20px;font-size:0.85rem;background:#7c3aed;">Copy JSON to Clipboard</button>
    <textarea id="jsonResultArea" readonly style="width:100%;height:300px;background:#0d1117;color:#7ee787;border:1px solid #30363d;border-radius:8px;padding:12px;font-family:monospace;font-size:0.75rem;resize:vertical;">${escapeHtml(jsonStr)}</textarea>
  </div>`;
  document.getElementById('results').insertAdjacentHTML('beforeend', html);
}

function copyJsonResult() {
  const area = document.getElementById('jsonResultArea');
  if (!area) return;
  area.select();
  area.setSelectionRange(0, 99999999);
  navigator.clipboard.writeText(area.value).then(() => {
    const btn = event.target;
    btn.textContent = 'Copied!';
    btn.style.background = '#16a34a';
    setTimeout(() => { btn.textContent = 'Copy JSON to Clipboard'; btn.style.background = '#7c3aed'; }, 2000);
  }).catch(() => {
    // Fallback for older browsers
    document.execCommand('copy');
  });
}
</script>
</body>
</html>
