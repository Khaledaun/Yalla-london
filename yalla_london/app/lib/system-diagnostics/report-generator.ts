/**
 * Diagnostic Report Generator
 *
 * Generates structured reports from diagnostic runs:
 *  - LAST-DIAGNOSTIC.md: Latest system state (auto-updated on each run)
 *  - DEVELOPMENT-REPORT.md: Comprehensive development report
 *
 * Reports are designed for both human reading and Claude Code ingestion.
 */

import type { DiagnosticRunResult, DiagnosticResult } from "./types";

interface ReportOptions {
  siteId: string;
  runId: string;
  level: number;
  levelName: string;
  phaseInfo?: string;
}

/**
 * Generate LAST-DIAGNOSTIC.md content.
 * Written after every diagnostic run for CLAUDE.md reference.
 */
export function generateLastDiagnosticReport(
  result: DiagnosticRunResult,
  options: ReportOptions,
): string {
  const lines: string[] = [];
  const now = new Date().toISOString().slice(0, 19).replace("T", " ");

  lines.push("# Last System Diagnostic");
  lines.push("");
  lines.push(`> Auto-generated by System Validator on ${now} UTC`);
  lines.push(`> Run ID: \`${options.runId}\``);
  lines.push(`> Site: \`${options.siteId}\``);
  lines.push(`> Level: ${options.levelName} (Level ${options.level})`);
  lines.push("");

  // Health summary
  lines.push("## Health Summary");
  lines.push("");
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Health Score | **${result.healthScore}/100** |`);
  lines.push(`| Verdict | ${result.verdict} |`);
  lines.push(`| Total Tests | ${result.results.length} |`);
  lines.push(`| Passed | ${result.results.filter((r) => r.status === "pass").length} |`);
  lines.push(`| Warnings | ${result.results.filter((r) => r.status === "warn").length} |`);
  lines.push(`| Failed | ${result.results.filter((r) => r.status === "fail").length} |`);
  lines.push(`| Duration | ${result.durationMs}ms |`);
  lines.push("");

  // Environment
  if (result.envConfirmed.length > 0 || result.envMissing.length > 0) {
    lines.push("## Environment Variables");
    lines.push("");
    lines.push("| Variable | Status |");
    lines.push("|----------|--------|");
    for (const key of result.envConfirmed) {
      lines.push(`| ${key} | Set |`);
    }
    for (const key of result.envMissing) {
      lines.push(`| ${key} | **MISSING** |`);
    }
    lines.push("");
  }

  // Failures (most important — listed first)
  const failures = result.results.filter((r) => r.status === "fail");
  if (failures.length > 0) {
    lines.push("## Failures (Action Required)");
    lines.push("");
    for (const f of failures) {
      lines.push(`### ${f.name}`);
      lines.push(`- **Section:** ${f.section}`);
      lines.push(`- **Detail:** ${f.detail}`);
      lines.push(`- **Explanation:** ${f.explanation}`);
      if (f.diagnosis) lines.push(`- **Diagnosis:** ${f.diagnosis}`);
      lines.push("");
    }
  }

  // Warnings
  const warnings = result.results.filter((r) => r.status === "warn");
  if (warnings.length > 0) {
    lines.push("## Warnings");
    lines.push("");
    for (const w of warnings) {
      lines.push(`- **${w.name}** (${w.section}): ${w.detail}`);
      if (w.diagnosis) lines.push(`  - ${w.diagnosis}`);
    }
    lines.push("");
  }

  // Passing tests (collapsed)
  const passes = result.results.filter((r) => r.status === "pass");
  if (passes.length > 0) {
    lines.push("## Passing Tests");
    lines.push("");
    const bySection = new Map<string, DiagnosticResult[]>();
    for (const p of passes) {
      const list = bySection.get(p.section) ?? [];
      list.push(p);
      bySection.set(p.section, list);
    }
    for (const [section, tests] of bySection) {
      lines.push(`### ${section} (${tests.length} passed)`);
      for (const t of tests) {
        lines.push(`- ${t.name}: ${t.detail}`);
      }
      lines.push("");
    }
  }

  // Recommendations (derived from failures and warnings)
  const recommendations: string[] = [];
  for (const f of result.results.filter((r) => r.status === "fail")) {
    if (f.diagnosis) recommendations.push(f.diagnosis);
  }
  if (result.envMissing.length > 0) {
    recommendations.push(`Set missing env vars: ${result.envMissing.join(", ")}`);
  }
  if (recommendations.length > 0) {
    lines.push("## Recommendations");
    lines.push("");
    for (const rec of recommendations) {
      lines.push(`- ${rec}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate a comprehensive DEVELOPMENT-REPORT.md
 * summarizing all diagnostic runs and known issues.
 */
export function generateDevelopmentReport(
  runs: Array<{ runId: string; siteId: string; level: number; result: DiagnosticRunResult; timestamp: string }>,
  knownGaps: Array<{ area: string; issue: string; severity: string; status: string }>,
): string {
  const lines: string[] = [];
  const now = new Date().toISOString().slice(0, 19).replace("T", " ");

  lines.push("# Development Report");
  lines.push("");
  lines.push(`> Auto-generated on ${now} UTC`);
  lines.push(`> Covers ${runs.length} diagnostic run(s)`);
  lines.push("");

  // Overall health trend
  lines.push("## Health Trend");
  lines.push("");
  if (runs.length > 0) {
    lines.push("| Run | Site | Level | Score | Verdict | Tests | Duration |");
    lines.push("|-----|------|-------|-------|---------|-------|----------|");
    for (const run of runs.slice(-10)) { // Last 10 runs
      lines.push(
        `| ${run.runId.slice(-8)} | ${run.siteId} | L${run.level} | ${run.result.healthScore}/100 | ${run.result.verdict} | ${run.result.results.length} | ${run.result.durationMs}ms |`,
      );
    }
    lines.push("");

    // Trend
    if (runs.length >= 2) {
      const first = runs[0].result.healthScore;
      const last = runs[runs.length - 1].result.healthScore;
      const trend = last > first ? "Improving" : last < first ? "Degrading" : "Stable";
      lines.push(`**Trend:** ${trend} (${first} → ${last})`);
      lines.push("");
    }
  }

  // Known gaps
  if (knownGaps.length > 0) {
    lines.push("## Known Gaps");
    lines.push("");
    lines.push("| Area | Issue | Severity | Status |");
    lines.push("|------|-------|----------|--------|");
    for (const gap of knownGaps) {
      lines.push(`| ${gap.area} | ${gap.issue} | ${gap.severity} | ${gap.status} |`);
    }
    lines.push("");
  }

  // Latest failures
  if (runs.length > 0) {
    const latest = runs[runs.length - 1];
    const failures = latest.result.results.filter((r) => r.status === "fail");
    if (failures.length > 0) {
      lines.push("## Current Failures (from latest run)");
      lines.push("");
      for (const f of failures) {
        lines.push(`- **${f.name}** (${f.section}): ${f.detail}`);
      }
      lines.push("");
    }
  }

  // Recommendations
  lines.push("## Next Steps");
  lines.push("");
  if (runs.length === 0) {
    lines.push("- Run a Level 1 (Quick) diagnostic to establish baseline");
  } else {
    const latest = runs[runs.length - 1];
    const failures = latest.result.results.filter((r) => r.status === "fail").length;
    const warnings = latest.result.results.filter((r) => r.status === "warn").length;
    if (failures > 0) {
      lines.push(`- Fix ${failures} failing test(s) from the latest diagnostic`);
    }
    if (warnings > 3) {
      lines.push(`- Address ${warnings} warnings to improve health score`);
    }
    if (latest.result.healthScore < 70) {
      lines.push("- Health score below 70 — focus on critical infrastructure");
    }
    if (latest.result.healthScore >= 90) {
      lines.push("- Excellent health score — maintain with regular weekly audits");
    }
  }

  return lines.join("\n");
}
